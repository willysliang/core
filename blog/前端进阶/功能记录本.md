---
Author: willysliang
CreateTime: 2022-10-24 10:15:15
Modifier: willysliang
ModifiedTime: 2022-12-28 11:46:22
Description: 功能记录本
---

## 功能记录本

## 初级

### 使用焦点样式丰富用户体验

> 焦点指示器常用于输入元素时显示特殊样式，如下图是原生对焦点样式浏览器用来指示某个元素被聚焦的方式。
>
> ![image-20221003195246576](./image/image-20221003195246576.png)
>
> ### 使用`outline:none`改变默认焦点样式
>
> 使用 `outline: none` 删除默认的蓝色轮廓，同时更改背景颜色和接收焦点时元素的颜色。通过这种方式，用户仍然可以很容易地识别出元素当前的焦点
>
> 注意：当你改变颜色时，你应该检查[颜色对比度](https://contrast-ratio.com/)是否足够。这对于视力低下的人来说尤其重要，但是颜色对比度差会影响到每个人。如果你曾经坐在阳光下上网，你就会知道拥有一个好的颜色对比度是多么重要，这样你才能看到屏幕上的内容
>
> ```css
> a:focus {
> outline: none;
> background-color: #651787;
> color: #fff;
> }
> ```
>
> ### 使用 `:focus-within` 设置可聚焦元素的父元素的样式
>
> 默认情况下，我们使用 `:before` 为表单创建背景，并使用 `transform: translateY(-100%)` 隐藏它。
>
> 一旦用户点击其中一个 `input` 元素，背景将从顶部移入。这是通过使用 `form:focus-within::before` 并将 `translateY` 设置为 `0` 来完成的。此外还使用 `transition` 使其成为平滑效果。
>
> ```html
> <form>
> <label for="username">Username:</label>
> <input id="username" type="text" />
> 
> <label for="password">Password:</label>
> <input id="password" type="password" />
> 
> <input type="submit" value="Login" />
> </form>
> ```
>
> ```css
> form {
>     padding: 10px;
>     position: relative;
>     overflow: hidden;
> }
> form:before {
>     content: '';
>     background: #ddd;
>     position: absolute;
>     left: 0;
>     right: 0;
>     top: 0;
>     bottom: 0;
>     z-index: -1;
>     transform: translateY(-100%);
>     transition: transform 260ms ease-out;
> }
> form:focus-within::before {
>     transform: translateY(0);
> }
> ```
>
> ### 使用 `:focus-visible` 与鼠标/指针交互时不显示焦点样式   
>
> 有时，使用 `:focus` 样式也会对鼠标/指针用户的用户体验产生副作用。以具有上一个/下一个控件的图像库为例。如果用户单击其中一个按钮，它们将聚焦，因此将显示聚焦样式。虽然这对键盘用户来说很好，但对鼠标/指针用户来说可能太多了。
>
> 在这里，如果用户使用鼠标或指针聚焦元素，我们将使用伪类显式删除焦点样式。这样，键盘用户仍然可以看到焦点指示器，而鼠标用户则看不到。
>
> 在之前，你可能会使用以下错误的方法来修复这样的问题。但这样会删除键盘用户的焦点指示器，使您几乎无法使用图像库。
>
> ```css
> button:focus {
> 	outline: none;
> }
> ```
>
> 可以使用 [`:focus-visible`](https://developer.mozilla.org/en-US/docs/Web/CSS/:focus-visible) 伪类，仅当用户使用键盘对焦元素时，才会显示对焦样式。
> 在这里使用 `:not` 伪类来明确删除对焦样式，如果用户使用鼠标或指头对焦元素。这样，键盘用户仍将看到对焦指示器，而鼠标用户看不到。
>
> ```css
> /* 提供基本的焦点样式 */
> button:focus {
> 	/* ...; */
> }
> /* 删除鼠标用户的焦点样式 */
> button:focus:not(:focus-visible) {
> 	outline: none;
> }
> ```

### 垂直水平居中的方式

> 基本结构如下：
>
> ```html
> <div class="container">
> 	<div class="box"></div>
> </div>
> ```
>
> 基本样式如下：
>
> ```css
> .container {
>   width: 200px;
>   height: 200px;
>   background-color: pink;
> }
> 
> .box {
>   width: 50px;
>   height: 50px;
>   background-color: plum;
> }
> ```

#### table-cell 表格

> ```css
> .container {
>   display: table-cell;
>   vertical-align: middle;
> }
> 
> .box {
>   margin: auto;
> }
> ```
>
> 或者
>
> ```css
> .container {
>   display: table-cell;
>   text-align: center;
>   vertical-align: middle;
> }
> 
> .box {
>   display: inline-block;
> }
> ```

#### position 定位

> **未知宽度和高度的元素**，可以使用绝对定位和 `transform` 属性的 `translate`。
>
> ```css
> .container {
>   position: relative;
> }
> 
> .box {
>   position: absolute;
>   top: 50%;
>   left: 50%;
>   transform: translate(-50%, -50%);
> }
> ```
>
> `transform` 还可以使用 `margin` 代替，需要注意的是 `margin` 的值是宽和高值的负一半：
>
> ```css
> .container {
>   position: relative;
> }
> 
> .box {
>   position: absolute;
>   top: 50%;
>   left: 50%;
>   margin: -25px 0 0 -25px; // width 和 height 的负一半
> }
> ```
>
> 另一种方式，设置 `absolute` 的偏移值（`top`、`left`、`right` 和 `bottom`）为 `0`，并使用 `margin: auto`，好处是不需要提前知道元素的尺寸兼容性好。
>
> ```css
> .container {
> position: relative;
> }
> 
> .box {
> position: absolute;
> top: 0;
> right: 0;
> bottom: 0;
> left: 0;
> margin: auto;
> }
> ```

#### Flex 布局

> 使用 `justify-content` 和 `align-item`：
>
> ```css
> .container {
> display: flex;
> justify-content: center;
> align-items: center;
> }
> ```
>
> 使用 `justify-content` 和 `align-self`：
>
> ```css
> .container {
> display: flex;
> justify-content: center;
> }
> 
> .box {
> align-self: center;
> }
> ```
>
> 使用 `margin：auto`：
>
> ```css
> .container {
> display: flex;
> }
> 
> .box {
> margin: auto;
> }
> ```

#### Grid 布局

> `grid` 用于二维布局，但当只有一个子元素时，一维布局与二维布局都一样。
>
> ```css
> .container {
> display: grid;
> justify-content: center;
> align-content: center;
> }
> /* or */
> .container {
> display: grid;
> justify-items: center;
> align-items: center;
> }
> ```
>
> 上面属性的简写形式：
>
> ```css
> .container {
> display: grid;
> place-items: center;
> }
> /* or */
> .container {
> display: grid;
> place-content: center;
> }
> ```
>
> 更简便的技巧：
>
> ```css
> .container {
> display: grid;
> }
> 
> .box {
> margin: auto;
> }
> ```
>
> 另一种方式，我们可以单独控制子元素的对齐方式：
>
> ```css
> .container {
> display: grid;
> }
> 
> .box {
> align-self: center;
> justify-self: center;
> /* 简写形式 */
> /* place-self: center; */
> }
> ```
>

### CSS创建三角形

#### 盒模型的border实现

> - 三角形指向的另一侧（即，如果三角形指向下方，则为顶部）应具有所需的 `border-color`。相邻边框（即左侧和右侧）的 `border-color` 应为 `transparent`
> - 更改 `border-width` 值将更改三角形的比例。
>
> ```css
> .triangle {
>   width: 0;
>   height: 0;
>   border-top: 20px solid #9c27b0;
>   border-left: 20px solid transparent;
>   border-right: 20px solid transparent;
> 
>   /* 简写形式 */
>   /* border: 20px solid transparent;
>   border-top-color: 20px solid plum; */
> }
> ```

#### `clip-path` 属性裁剪

> - [`clip-path`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/clip-path) 属性使用裁剪方式创建元素的可显示区域。区域内的部分显示，区域外的隐藏。
> - 可使用`polygon` 函数实现一个三角形
>
> ```css
> .triangle {
>   clip-path: polygon(0 0, 100% 0, 50% 100%);
>   height: 20px;
>   width: 40px;
>   background-color: plum;
> }
> ```

#### `linear-gradient` 函数

> - [`linear-gradient()`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/gradient/linear-gradient) 函数用于创建一个表示两种或多种颜色线性渐变的图片。
>
> ```css
> .triangle {
>   width: 100px;
>   height: 100px;
>   background: linear-gradient(
>     to bottom right,
>     #fff 0%,
>     #fff 50%,
>     plum 50%,
>     plum 100%
>   );
> }
> ```

### 瀑布流布局

> - [css瀑布流参考](https://blog.csdn.net/qq_53008257/article/details/124638563)
>
> **瀑布流布局**是一种新型的布局方式，可以将大小不一的图片完整的显示在页面上，并且在杂乱的布局中保持着一定的美感。
>
> ![image-20221122164839262](./image/image-20221122164839262.png)
>
> ```html
> <div class="container" id="con">
>   <div class="item">
>     <img src="../img/1.jpeg" alt="">
>   </div>
>   <div class="item">
>     <img src="../img/2.jpeg" alt="">
>   </div>
>   <div class="item">
>     <img src="../img/3.jpeg" alt="">
>   </div>
>   <div class="item">
>     <img src="../img/4.jpeg" alt="">
>   </div>
>   <div class="item">
>     <img src="../img/5.jpeg" alt="">
>   </div>
>   <div class="item">
>     <img src="../img/6.jpeg" alt="">
>   </div>
> </div>
> ```

#### 使用column-count属性实现

> - 使用column-count属性将一个盒子分为多列展示数据 ，使用column-gap：0px将列间间距设置未0，方便我们自定义间距。
>
> **优点**：
>
> 1. 简单，只需给父盒子两行代码
> 2. 列数不会随着浏览器的宽度而改变，例如：指定列数为4就只能显示4列
>
> **缺点**：图片的位置是按照从上往下排序，如果我们需要一些动态加载图片的业务，那么新加入的图片将不会加入页面的最低端，不符合我们的业务需求
>
> ```css
> .container{
>   column-count: 4;//想要排成的列数
>   column-gap: 0;
> }
> .item img{
>   width: 100%;
> }
> ```

#### 使用 flex 布局

> 使用弹性盒子，给弹性元素指定列排列，然后给每个元素指定宽度(宽度设置为（1/列数）如果想要排成4列就设置成25%,如果想要排成5列就设置成25%以此类推)。
>
> **由于设置为列排列，当元素的累计高度没有超过指定的高度时，首先会在第一个列上堆叠元素**
>
> 由于我们设置了flex-wrap:wrap导致如果超出了设置的高度，元素将会换行，由于我们设置的排列方向是按列排列，因此超出的元素将会展示在第二列
>
> 注意：若父容器高度设置过高（或子内容数量过少），就会导致存在有些列为空白情况
>
> ```css
> .container{
>     display: flex;
>     flex-direction: column;
>     flex-wrap: wrap;
>     /* 需要指定高度 */
>     height: 800px;
> }
> .item{
>     width: 25%;
> }
> 
> .item img{
>     width: 100%;
> }
> 
> ```
>
> ### 优化
>
> ```css
> .container{
>     display: flex;
>     flex-direction: column;
>     flex-wrap: wrap;
>     /* 需要指定高度 */
>     height: 1600px
> }
> /**新加入的代码*/
> .item:nth-child(4n+1){
>     order: 1;
> }
> .item:nth-child(4n+2){
>     order:2;
> }
> .item:nth-child(4n+3){
>     order: 3;
> }
> .item:nth-child(4n){
>     order: 4;
> }
> /**新加入的代码*/
> .item{
>     width: 25%;
>     position: relative;
>     counter-increment: item-counter;
> }
> 
> .item img{
>     width: 100%;
> }
> .item::after{
>     position:absolute;
>     background-color: red;
>     color: white;
>     left: 0;
>     top: 0;
>     content: counter(item-counter);
> }
> ```
>
> **由于图片大小差距过大，导致每一行显示图片的数量不一样，导致order失效**。
> 但当每一列图片数量相等的时候，可以达成想要的效果
>
> **优点**：如果每列数量差图片数量相同，则可以实现新的图片显示在最下方的业务
>
> **缺点**:
>
> - 列数不会随着浏览器的宽度而改变
> - 需要指定高度，并且在每一列放置合适数量的图片。
> - 如果没有给容器设置固定宽度，则当容器宽度缩小时，图片的宽度相应的缩小，由于图片的高度是auto，即按图片原比例展示，因此图片高度会相应减少，由于高度指定，图片数量固定，则可能会出现图片占不满列数的情况
>
> ![image-20221122180605976](./image/image-20221122180605976.png)

#### JS 方法实现

> 原理:通过JS，根据每个图片的宽度计算出需要放置多少行，将所有图片设置绝对定位，逐一计算出该图片所在的top和left进行定位。
>
> **优点**:
>
> 1. 列数随浏览器窗口大小动态改变
> 2. 可以实现新图片在最下方展示
>
> **缺点**:
>
> 1. 代码较为复杂
> 2. 由于使用js，会消耗一些浏览器性能，当图片多了的时候可能导致卡顿。
>
> ```css
> .container{
>   position: relative;
> }
> .item{
>   width: 200px;
>   height: auto;
>   position: absolute;
> }
> 
> .item img{
>   width: 100%;
> }
> ```
>
> ```js
> //当页面加载的时候调用
> window.onload = function(){
>   //页面初始化调用
>   waterFall()
>   //每次页面改变大小调用
>   window.onresize = waterFall
> }
> function waterFall(){
>   // 1. 设置container盒子的宽度
>   //      注意：浏览器的可视区域的宽度 / 一个item元素的宽度 = 一行的排列的元素的个数
>   let container = document.getElementById("con")
>   let item = document.getElementsByClassName("item")
>   //获取元素的宽度(含border，padding)
>   let width = item[0].offsetWidth 
>   //计算出浏览器窗口的宽度
>   let clientWidth = document.documentElement.clientWidth;
>   //计算出应该放几列（向下取整）
>   let columnCount = Math.floor(clientWidth / width)
>   //设置容器（父盒子）的宽度
>   container.style.width = columnCount*width+"px"
> 
>   // 2.设置每一个item元素的排列位置
>   //  第一行整体的top值都是0 后面的依次找上一行高度最小的容器，在它下面进行排列
>   let hrr = []
>   for(let i= 0 ;i<item.length;i++){
>     //定位第一行的图片
>     if(i<columnCount){
>       item[i].style.top = "0px"
>       item[i].style.left = i* width+"px" 
>       hrr.push(item[i].offsetHeight)
>     }else{
>       //第一行之后的 选择总高度最小的列
>       let min = Math.min(...hrr)
>       let index = hrr.indexOf(min)
>       //将每个元素定位到当前总高度最小的列下
>       item[i].style.top = min+"px"
>       item[i].style.left = index * width+"px" 
>       //当前定位的元素加入该列
>       hrr[index] += item[i].offsetHeight
>     }
>   }
> }
> ```
>
> 为什么每次都要将图片放置在高度最小的列上呢?
> 因为图片高度不一的情况，**如果按下标顺序一个一个排列，最终虽然每一列上图片的数量是一样的，但是显示的高度可能相差甚远**,因此选择将每个图片放在高度最小的列上让每一列的总高度不会相差太大。实现效果图如下：
>
> ![image-20221122181314569](./image/image-20221122181314569.png)
>
> 当浏览器宽度改变时，图片列数自动匹配。
>
> ![image-20221122181421527](./image/image-20221122181421527.png)

#### 总结

> ![image-20221122181823720](./image/image-20221122181823720.png)

## 中级

### 计算textarea的字符数

> - 需要使用 `maxlength` 属性设置用户可以在 `textarea` 中限制用户输入的最大字符数
> - 通过监听`textarea`的`input`事件来计算长度
> - 注意：若是通过捕获`keyup`事件来计算，其会在某些情况下不起作用，例如
>   1. 用户将文本拖动到文本区域
>   2. 用户在文本区域中单击鼠标右键，然后从关联菜单中选择粘贴
>
> ```html
> <div>
>   <textarea rows="5" maxlength="200" id="message"></textarea>
>   <div id="counter">0</div>
> </div>
> ```
>
> ```js
> const messageEle = document.getElementById('message')
> const counterEle = document.getElementById('counter')
> // 获取 `maxlength` 属性
> const maxLength = messageEle.getAttribute('maxlength')
> 
> counterEle.innerHTML = `0/${maxLength}`
> 
> messageEle.addEventListener('input', function (e) {
>   const target = e.target
>   // 计算当前字符数
>   const currentLength = target.value.length
>   counterEle.innerHTML = `${currentLength}/${maxLength}`
> })
> ```

### 判断对象是否为空

> ### 无法使用等号直接比较
>
> 因为对象是引用类型，所以无法像基本数据类型那样使用`===`或`==`比较（等号是比较内存地址）
>
> ```js
> const obj = {}
> console.log(obj === {}) // false
> ```
>
> ### `for...in`遍历比较
>
> `for...in`可以任意顺序遍历一个对象的除Symbol以外的可枚举属性。
> 根据`for...in`遍历对象，如果进入遍历则为非空对象
>
> ```js
> const obj = {}
> const user = { name: 'willy' }
> const isEmptyObj = (obj) => {
>   for(let key in obj) {
>      return '非空对象'
>   }
>   return '空对象'
> }
> 
> console.log(isEmptyObj(obj))	// 空对象
> console.log(isEmptyObj(user))	// 非空对象
> ```
>
> ### `JSON.stringify()`
>
> 利用JSON的`JSON.stringify()`转换为JSON字符串来进行判断
>
> ```js
> const isEmptyObj = (obj) => JSON.stringify(obj) === '{}' ? '空对象' ： '非空对象'
> ```
>
> ### `Object.keys()`
>
> `Object.keys()`方法会返回一个由一个给定对象的自身可枚举属性组成的数组。如果对象为空，将返回一个空数组。
>
> ```js
> const isEmptyObj = (obj) => Object.keys(obj).length === 0 ? '空对象' : '非空对象'
> ```

### API身份认证

> ```js
> fetch('https://example.com/token', {
>   headers: {
>      Authorization: `Bearer ${token}`
>   }
> })
>   .then((response) => {
>    if (response.ok) return response.json()
>    throw response
> })
>   .then((data) => console.log(data))
>   .catch((error) => console.warn(error))
> ```

### ES JSON 模块提案

> JSON 模块已经存在于 Chrome 91，它看起来就像一个 ES Modules 风格的导入，只是你在最后设置了类型。
>
> ```js
> import configData from './config-data.json' assert { type: 'json' }
> ```
>
> **好处**：一行代码获取 JSON 数据

### 侦听手机浏览器的方法

#### navigator.userAgent设备信息

> - JS 通过`navigator.userAgent`属性拿到一个字符串，只要里面包含`mobi`、`android`、`iphone`等关键字，就可以认定是移动设备
> - 这种方法的优点是简单方便，缺点是不可靠，因为用户可以修改这个字符串，让手机浏览器伪装成桌面浏览器
>
> ```js
> if (/Mobi|Android|iPhone/i.test(navigator.userAgent)) {
>   // 当前设备是移动设备
> }
> 
> // 另一种写法
> if (
>   navigator.userAgent.match(/Mobi/i) ||
>   navigator.userAgent.match(/Android/i) ||
>   navigator.userAgent.match(/iPhone/i)
> ) {
>   // 当前设备是移动设备
> }
> ```
>
> Chromium 系的浏览器，还有一个`navigator.userAgentData`属性，也有类似作用。不同之处是它将 user agent 字符串解析为一个对象，该对象的`mobile`属性，返回一个布尔值，表示用户是否使用移动设备。
>
> ```js
> const isMobile = navigator.userAgentData.mobile; 
> ```

#### window.screen，window.innerWidth

> 另一种方法是通过屏幕宽度，判断是否为手机。
>
> `window.screen`对象返回用户设备的屏幕信息，该对象的`width`属性是屏幕宽度（单位为像素）。
>
> 如果屏幕宽度`window.screen.width`小于500像素，就认为是手机。
>
> 但是这个方法的缺点在于，如果手机横屏使用，就识别不了。
>
> ```js
> if (window.screen.width < 500) {
>   // 当前设备是移动设备 
> }
> ```
>
> 另一个属性`window.innerWidth`返回浏览器窗口里面的网页可见部分的宽度，比较适合指定网页在不同宽度下的样式。
>
> ```js
> const getBrowserWidth = function() {
>     if (window.innerWidth < 768) {
>        return "xs";
>     } else if (window.innerWidth < 991) {
>        return "sm";
>     } else if (window.innerWidth < 1199) {
>        return "md";
>     } else {
>        return "lg";
>     }
> };
> ```

#### window.orientation

> 第三种方法是侦测屏幕方向，手机屏幕可以随时改变方向（横屏或竖屏），桌面设备做不到。
>
> `window.orientation`属性用于获取屏幕的当前方向，只有移动设备才有这个属性，桌面设备会返回`undefined`。
>
> ```js
> if (typeof window.orientation !== 'undefined') {
>   // 当前设备是移动设备 
> }
> ```
>
> 注意，iPhone 的 Safari 浏览器不支持该属性 

#### touch 事件

> 第四种方法是，手机浏览器的 DOM 元素可以通过`ontouchstart`属性，为`touch`事件指定监听函数。桌面设备没有这个属性。
>
> ```js
> function isMobile() { 
>     return ('ontouchstart' in document.documentElement); 
> }
> 
> // 另一种写法
> function isMobile() {
>     try {
>        document.createEvent("TouchEvent"); return true;
>     } catch(e) {
>        return false; 
>     }
> }
> ```

#### window.matchMedia()

> **通过屏幕宽度判断**
>
> CSS 通过 media query（媒介查询）为网页指定响应式样式。如果某个针对手机的 media query 语句生效了，就可以认为当前设备是移动设备。
>
> `window.matchMedia()`方法接受一个 CSS 的 media query 语句作为参数，判断这个语句是否生效。
>
> ```js
> let isMobile = window.matchMedia("only screen and (max-width: 760px)").matches;
> ```
>
> 上面示例中，`window.matchMedia()`的参数是一个 CSS 查询语句，表示只对屏幕宽度不超过 700 像素的设备生效。它返回一个对象，该对象的`matches`属性是一个布尔值。如果是`true`，就表示查询生效，当前设备是手机。
>
> **通过指针精确性判断**
>
> CSS 语句`pointer:coarse`表示当前设备的指针是不精确的。由于手机不支持鼠标，只支持触摸，所以符合这个条件。
>
> ```js
> let isMobile = window.matchMedia("(pointer:coarse)").matches;
> ```
>
> 有些设备支持多种指针，比如同时支持鼠标和触摸。
>
> `pointer:coarse`只用来判断主指针，此外还有一个`any-pointer`命令判断所有指针。
>
> `any-pointer:coarse`表示所有指针里面，只要有一个指针是不精确的，就符合查询条件。
>
> ```js
> let isMobile = window.matchMedia("(any-pointer:coarse)").matches; 
> ```

### 图片懒加载(延迟加载)

> -  当访问一个页面时，先把img元素或者其他元素的背景图片替换成一张大小1*1px图片的路径（只需要请求一次的占位图），只有当图片出现在浏览器的可视区域内时，才设置图片真正的路径，让图片显示出来，这就是图片的懒加载
> -  懒加载的原理是先在页面中把所有的图片统一使用一张占位图进行占位，把真正的路径存在元素的‘data-url’属性中，要使用的时候再设置。
>
> ```js
> // html
>  <div>
>     <img src="./imgloading.jpg" alt="loading..." data-src="./img/1.jpg">
>     <img src="./img/loading.jpg" alt="loading..." data-src="../../willy/二次备份/冰墨/收藏/2.jpg">
>     <img src="./img/loading.jpg" alt="loading..." data-src="./img/3.jpg">
> </div>
>       
> // js
> // onload是等所有的资源文件加载完毕以后再绑定事件
> window.onload = function () {
>   // 获取图片列表，即img标签列表
>   var imgs = document.querySelectorAll('img');
> 
>   // 获取到浏览器顶部的距离
>   function getTop(e) {
>     return e.offsetTop;
>   }
> 
>   // 懒加载实现
>   function lazyload(imgs) {
>     // 可视区域高度
>     var h = window.innerHeight;
>     //滚动区域高度
>     var s = document.documentElement.scrollTop || document.body.scrollTop;
>     for (var i = 0; i < imgs.length; i++) {
>       //图片距离顶部的距离大于可视区域和滚动区域之和时懒加载
>       if ((h + s) > getTop(imgs[i])) {
>         // 真实情况是页面开始有2秒空白，所以使用setTimeout定时2s
>         (function (i) {
>           setTimeout(function () {
>             // 不加立即执行函数i会等于9
>             // 隐形加载图片或其他资源，
>             //创建一个临时图片，这个图片在内存中不会到页面上去。实现隐形加载
>             var temp = new Image();
>             temp.src = imgs[i].getAttribute('data-src');//只会请求一次
>             // onload判断图片加载完毕，真是图片加载完毕，再赋值给dom节点
>             temp.onload = function () {
>               // 获取自定义属性data-src，用真图片替换假图片
>               imgs[i].src = imgs[i].getAttribute('data-src')
>             }
>           }, 2000)
>         })(i)
>       }
>     }
>   }
>   lazyload(imgs);
> 
>   // 滚屏函数
>   window.onscroll = function () {
>     lazyload(imgs);
>   }
> }
> ```
>

### 页面倒计时

#### 倒计时用 setInterval 实现

> ```js
> const totalDuration = 100; // 100s
> let duration = totalDuration;
> let countDownInterval = null;
> let startTime = new Date().getTime();
> let endTime = startTime;
> let prevEndTime = startTime
> let timeDifferance = 0; // 每1s倒计时偏差值，单位ms
> let totalTimeDifferance = 0; // 总共倒计时偏差值，单位ms
> 
> function countDown() {
>   countDownInterval = setInterval(() => {
>     duration = duration - 1;
>     prevEndTime = endTime
>     endTime = new Date().getTime();
>     console.log(`当前执行时间：${endTime}, 首次执行时间：${startTime}`);
>     console.log(`当前和首次执行的时间间隔差：${endTime - startTime}`)
>     timeDifferance = endTime - prevEndTime
>     document.getElementById("app").innerText = duration;
>     document.getElementById("differance").innerText = timeDifferance;
>     if (duration <= 0) {
>       totalTimeDifferance = endTime - startTime - totalDuration * 1000;
>       console.log(`累计时间差: ${totalTimeDifferance}`)
>       clearInterval(countDownInterval);
>     }
>   }, 1000);
> }
> 
> countDown();
> ```
>
> #### 使用 setInterval 实现的缺点
>
> 使用 setInterval 实现，可以看到每次变更倒计时都会出现 `-2ms ~ 7ms` 的偏差值不等。这是因为浏览器可能存在同步或异步任务代码的执行阻塞，导致 setInterval 的回调函数会产生延迟。
>
> ![image-20230423125105265](./image/image-20230423125105265.png)

#### 倒计时用 setTimeout 实现

> ```js
> const totalDuration = 100; // 100s
> let duration = totalDuration;
> let countDownInterval = null;
> let startTime = new Date().getTime();
> let endTime = startTime;
> let prevEndTime = startTime;
> let timeDifferance = 0; // 每1s倒计时偏差值，单位ms
> let totalTimeDifferance = 0; // 总共倒计时偏差值，单位ms
> let interval = 1000; // 1s
> 
> function countDown() {
> duration = duration - 1;
> endTime = new Date().getTime();
> timeDifferance = endTime - prevEndTime;
> console.log(`当前倒计时：${duration}, 每秒执行的偏差值：${timeDifferance}`)
> let nextTime = interval - timeDifferance
> // 如果下一次执行时间超过当前周期，需要特俗处理一下
> if (nextTime < 0) {
>  nextTime = 0
> }
> document.getElementById("nextTime").innerText = nextTime;
> if (duration <= 0) {
>  totalTimeDifferance = endTime - startTime - totalDuration * 1000;
>  console.log(`累计执行的偏差值：${totalTimeDifferance}`)
>  clearTimeout(countDownInterval);
> } else {
>  countDownInterval = setTimeout(() => countDown(), nextTime);
> }
> }
> 
> countDownInterval = setTimeout(() => countDown(), interval);
> ```
>
> #### 使用 setTimeout 实现的缺点
>
> **注意：如果下次执行的时间间隔小于0，则需要特殊处理**
>
> 同样加了线程阻塞代码倒计时10s，误差值可降低到 2.5s，说明优化效果还是很显著的，当然实际过程编程过程中阻塞时间这么严重是很极端的情况，此时重点不再是去降低延迟，而是关注重构导致阻塞的代码。
>
> ![image-20230423125158020](./image/image-20230423125158020.png)

#### 倒计时用 requestAnimationFrame 实现

> ```js
> const totalDuration = 10 * 1000;
> let requestRef = null;
> let startTime;
> let prevEndTime;
> let prevTime;
> let currentCount = totalDuration;
> let endTime;
> let timeDifferance = 0; // 每1s倒计时偏差值，单位ms
> let interval = 1000;
> let nextTime = interval;
> 
> setInterval(() => {
>   let n = 0;
>   while (n++ < 1000000000);
> }, 0);
> 
> const animate = (timestamp) => {
>   if (prevTime !== undefined) {
>     const deltaTime = timestamp - prevTime;
>     if (deltaTime >= nextTime) {
>       prevTime = timestamp;
>       prevEndTime = endTime;
>       endTime = new Date().getTime();
>       currentCount = currentCount - 1000;
>       console.log("currentCount: ", currentCount / 1000);
>       timeDifferance = endTime - startTime - (totalDuration - currentCount);
>       console.log(timeDifferance);
>       nextTime = interval - timeDifferance;
>       // 慢太多了，就立刻执行下一个循环
>       if (nextTime < 0) {
>         nextTime = 0;
>       }
>       console.log(`执行下一次渲染的时间是：${nextTime}ms`);
>       if (currentCount <= 0) {
>         currentCount = 0;
>         cancelAnimationFrame(requestRef);
>         console.log(`累计偏差值： ${endTime - startTime - totalDuration}ms`);
>         return;
>       }
>     }
>   } else {
>     startTime = new Date().getTime();
>     prevTime = timestamp;
>     endTime = new Date().getTime();
>   }
>   requestRef = requestAnimationFrame(animate);
> };
> 
> requestRef = requestAnimationFrame(animate);
> ```
>
> ![image-20230423170418774](./image/image-20230423170418774.png)

#### react + requestAnimationFrame 实现倒计时

> ```jsx
> import React, { useState, useEffect, useRef } from "react";
> const [count, setCount] = useState<number>(0)
> const [duration, setTotalDuration] = useState<number>(0)
> const requestRef = useRef(null);
> const previousTimeRef = useRef(null);
> const currentCountRef = useRef<number>(0);
> 
> const animate = time => {
>   if (previousTimeRef.current !== undefined) {
>     const deltaTime = time - previousTimeRef.current;
>     if (deltaTime > 1000) {
>       if (currentCountRef.current > 0) {
>         previousTimeRef.current = time;
>         setCount(prevCount => {
>           currentCountRef.current = prevCount - 1000
>           return prevCount - 1000
>         });
>       } else {
>         setCount(0)
>         cancelAnimationFrame(requestRef.current);
>         return
>       }
>     }
>   } else {
>     previousTimeRef.current = time;
>   }
>   requestRef.current = requestAnimationFrame(animate);
> }
> 
> useEffect(() => {
>   const totalDuration = 60 * 1000
>   setCount(totalDuration)
>   setTotalDuration(totalDuration)
> }, [])
> 
> useEffect(() => {
>   if (duration <= 0) {
>     return
>   }
>   currentCountRef.current = duration
>   previousTimeRef.current = undefined
>   if (requestRef.current) {
>     cancelAnimationFrame(requestRef.current)
>   }
>   requestRef.current = requestAnimationFrame(animate);
>   return () => cancelAnimationFrame(requestRef.current)
> }, [duration])
> ```



## 前端逻辑

### 数组

#### 判断一个值是否是数组

> ```bash
> ## 判断一个值是否是数组
> const str = 'abc'
> const arr = [1, 2, 3]
> 
> 1. Array.prototype.isArray()
>       Array.isArray(arr)	// true
>       Array.isArray(str)	// false
> 
> 
> 2. Object.prototype.toString.call()
> 		const isArray = (arr) => Object.prototype.toString.call(arr) == '[object Array]'
> 
> 
> 3. instanceof
> 	使用 instanceof 检验构造函数的 prototype 属性是否出现在对象的原型链中，返回一个 Boolean。
>     arr instanceof Array // true
>     str instanceof Array // false
> 	
> 
> 4. constructor
> 	使用 constructor 判断该变量的构造函数是否为 Array
> 		arr.constructor === Array // true
> 		
> 
> 5. 封装
> 		const isArray = Array.isArray || ((list) => ({}.toString.call(list) === '[object Array]'))
> 		cosole.log(isArray([1, 2, 3])) // true
> 		console.log(isArray({}))	// false
> ```

#### 判断数组是否包含某值

> ```bash
> ## 判断数组是否包含某值
> const arr = ['red', 'yellow', 'black', 'white', 'yellow']
> 
> ### 1. Array.prototype.indexOf()：判断数组是否存在某个值，如果存在则返回数组元素下标，否则返回 -1。
>  arr.indexOf('plum')	// -1
>  arr.indexOf('yellow')	// 1
>  arr.indexOf('yellow', 2)	// 4
>  arr.indexOf('red') !== -1	// true
> 
> 
> ### 2. Array.prototype.includes()：判断数组中是否存在某个值，如果存在返回 true，否则返回 false。
>  arr.includes('red')	// true
>  arr.includes('plum')	// false
> 
> 
> ### 3. Array.prototype.find()：返回数组中满足条件的第一个元素的值，如果没有则返回 undefined。
> 		arr.find((item) => item && item === 'black')	// 'black'
> 
> 
> ### 4. Array.prototype.findIndex()：返回数组中满足条件的第一个元素的下标，如果没有找到则返回 -1。
> 		arr.findIndex((item) => item === 'white')	// 3
> 
> 
> ### 5. 常规循环：递减循环通常效率更高。
>  const contains = function (array, str) {
>    let i = a.length
>    while (i--) {
>      if (array[i] === str) return true
>      return false
>    }
>  }
>  contains(arr, 'yellow')	// true
>  contains(arr, 'plum')	// false
> ```

#### 数组扁平化

```bash
## 数组扁平化
const arr = [1, [2, [3, [4, 5]]], 6]    // --> [1, 2, 3, 4, 5, 6]

1. Array.prototype.flat()
		flat 可以指定展开多少层，也可使用 Infinity 作为参数展开无限嵌套数组
      	arr.flat(1) // [1, 2, [3, [4, 5]], 6]
        arr.flat(2) // [1, 2, 3, [4, 5], 6]
        arr.flat(Infinity) // [1, 2, 3, 4, 5, 6]


2. Array.prototype.toString() 或 Array.prototype.join()
		如果数组的元素都是数字，可考虑使用。
        const flatten1 = (arr) => arr.toString().split(',').map((item) => +item)
        flatten1(arr) // [1, 2, 3, 4, 5, 6]
        const flatten2 = (arr) => arr.join(',').split(',').map((item) => +item)
        flatten2(arr) // [1, 2, 3, 4, 5, 6]


3. 扩展运算符（注：仅适用于一层）
		[].concat(...arr) // [1, 2, [3, [4, 5]], 6]
		[].concat.apply([], arr) // [1, 2, [3, [4, 5]], 6]


4. 序列化 + 正则replace
		const str = `[${JSON.stringify(arr).replace(/(\[|\])/g, '')}]`
		JSON.parse(str) // [1, 2, 3, 4, 5, 6]
		
		
5. 递归 Array.prototype.reduce() + concat()
    const flatten = (arr) => {
      return arr.reduce(
        (acc, val) => Array.isArray(val) ? acc.concat(flatten(val)) : acc.concat(val),
        [],
      )
    }
    flatten(arr) // [1, 2, 3, 4, 5, 6]
```



#### 从数组中删除重复的对象

```bash
## 从数组中删除重复的对象

检查两个对象是否具有相同的属性和值的唯一方法是实际检查每个对象的属性和值。
	- 仅检索数组中每一项与其后的每一项，以避免多次比较同一对象。
	- 仅检查未发现与任何其他项重复的项。
	- 先检查两个对象是否具有相同的键，再检查每个属性的值是否相同。
	
```

```ts
/**
 * @function deepEqual 深度对比两个值是否相等
 * @param {any} value1 要对比的值
 * @param {any} value2 要对比的值
 * @returns {boolean} 是否相等
 * @example deepEqual([], [])
 */
export const deepEqual = (value1: any, value2: any): boolean => {
  // 两边类型是否一致
  const valueType = (v) => Object.prototype.toString.call(v)
  if (valueType(value1) !== valueType(value2)) return false

  /** 类型判断仅需要判断一边就行 */
  if (value1 && typeof value1 === 'object') {
    // 数组的对比
    if (Array.isArray(value1)) {
      // 是否等长
      if (value1.length !== value2.length) return false

      // 是否存在不同的值
      for (let i = 0; i < value1.length; i++) {
        if (!deepEqual(value1[i], value2[i])) return false
      }

      // 排除了上述所有检查，则必为相同
      return true
    }

    // Map 的对比
    if (value1 instanceof Map) {
      if (value1.size !== value2.size) return false
      for (const [key, value] of value1) {
        if (!value2.has(key) || value2.get(key) !== value) return false
      }

      return true
    }

    // Set 的对比
    if (value1 instanceof Set) {
      if (value1.size !== value2.size) return false
      for (const item of value1) {
        if (!value2.has(item)) return false
      }

      return true
    }

    // 其他情况的对比
    const valueKeys1 = Object.keys(value1)
    const valueKeys2 = Object.keys(value2)
    if (valueKeys1.length !== valueKeys2.length) return false
    for (const key of valueKeys1) {
      if (!(key in value2) || !deepEqual(value1[key], value2[key])) return false
    }
    return true
  }

  // 是否直接相等
  return value1 === value2
}


/**
 * @function removeDuplicates 删除数组的重复项对象
 * @param {Record<string, unknown>[]} arr 可能具有重复项的数组
 * @returns {Record<string, unknown>[]} 去重后的对象数组
 */
export function removeDuplicates(arr: Record<string, unknown>[]) {
  /** 已经去重的数组 */
  const result: Record<string | number, unknown>[] = []

  /** 重复索引 */
  const duplicatesIndices = new Map<number, boolean>()

  for (let index = 0; index < arr.length; index++) {
    // 如果已经重复，则无需检查
    if (duplicatesIndices.has(index)) continue

    const current = arr[index]

    // 此时必然是不重复的，直接加入该对象
    result.push(current)

    // 遍历数组当前项之后的其他项
    for (
      let comparisonIndex = index + 1;
      comparisonIndex < arr.length;
      comparisonIndex++
    ) {
      // 如果之前就已经计算到这里重复，则无需检查
      if (duplicatesIndices.has(comparisonIndex)) continue

      const valuesEqual = deepEqual(current, arr[comparisonIndex])

      // 检查值是否全部相等，以此来加入重复对象
      if (valuesEqual) duplicatesIndices.set(comparisonIndex, true)
    }
  }

  return result
}


/** 测试用例 */
const test1 = [
  { id: 1, name: 'Alice' },
  { id: 2, name: 'Bob' },
]
console.log(removeDuplicates(test1))
// 期望： [{ id: 1, name: 'Alice' }, { id: 2, name: 'Bob' }]

const test2 = [
  { id: 1, name: 'Alice' },
  { id: 1, name: 'Alice' },
  { id: 2, name: 'Bob' },
]
console.log(removeDuplicates(test2))
// 期望：[{ id: 1, name: 'Alice' }, { id: 2, name: 'Bob' }]

const test3 = [
  { id: 1, name: 'Alice' },
  { id: 1, name: 'Alice' },
  { id: 1, name: 'Alice' },
]
console.log(removeDuplicates(test3))
// 期望：[{ id: 1, name: 'Alice' }]

const test4 = [
  { id: 1, name: 'Alice', age: 30 },
  { id: 1, name: 'Alice' },
  { id: 1, name: 'Alice', gender: 'female' },
]
console.log(removeDuplicates(test4))
// 期望：[{ id: 1, name: 'Alice', age: 30 }, { id: 1, name: 'Alice' }, { id: 1, name: 'Alice', gender: 'female' }]

const test5 = [
  { id: 1, data: { score: 10, passed: true } },
  { id: 1, data: { score: 10, passed: true } },
  { id: 1, data: { passed: true, score: 10 } },
  { id: 2, data: { score: 8, passed: false } },
]
console.log(removeDuplicates(test5))
// 期望：[{ id: 1, data: { score: 10, passed: true } }, { id: 2, data: { score: 8, passed: false } }]

const test6 = [
  { id: 1, tags: ['science', 'math'] },
  { id: 1, tags: ['science', 'math'] },
  { id: 2, tags: ['science'] },
]
console.log(removeDuplicates(test6))
// 期望：[{ id: 1, tags: ['science', 'math'] }, { id: 2, tags: ['science'] }]

```



### 对象

#### 判断对象是否为空

```bash
## 判断对象是否为空
### 1. JSON.stringify()：
使用 `JSON.stringify()` 将对象转化为字符串 '{}' 来进行判断。
  const isEmpty = (obj) => JSON.stringify(obj) === '{}'
  isEmpty({})	// true
  isEmpty({ name: 'willy' }) // false


### 2. Object.keys()
		`Object.keys()` 方法会返回一个由一个给定对象的自身可枚举属性组成的数组。如果对象为空，将返回一个空数组。
    - 所以检查对象是否为空的最简单方法是检查它是否有键。
    - Object.keys() 传入非对象参数将强制转换为对象。
    		const isEmpty = (obj) => Object.keys(obj).length === 0
    		isEmpty({})	// true
        isEmpty({ name: 'willy' }) // false


### 3. for...in
		`for...in` 语句以任意顺序遍历一个对象的除 Symbol 以外的可枚举属性。
		根据 for...in 遍历对象，如果存在则返回 false，否则返回 true。
        const isEmpty = (obj) => {
          for (let prop in obj) {
            // 判断是否自身属性
            if (Object.prototype.hasOwnProperty.call(obj, prop)) {
              return false
            }
          }
          return JSON.stringify(obj) === '{}'
        }
        isEmpty({})	// true
        isEmpty({ name: 'willy' }) // false

```



### 函数

#### 管道运算符

```bash
### 管道运算符
管道是将一个函数的输出直接发送到另一个函数。

例：
伪代码表示：`output = input -> func1 -> func2 -> func3`。
在这种情况下，将 `input` 通过管道输送到 `func1`，将 `func1` 通过管道输送到 `func2` 的输出，在将 `func2` 通过管道输送到 `func3`，然后再汇算结果进行输出。
在不支持管道的情况下，实现方式为：`const output = func3(func2(func1(input)))`。

手动实现：
- 使用扩展运算符（`...`）允许将任意数量的参数传递到创建 `pipe` 函数中，传入的参数都存放在 `args` 数组中。
- 使用 `Array.prototype.reduce()` 方法遍历数组 `args`。执行 `reduce` 时，累加器会将前一个累加器传递给当前元素的结果。

```

```js
/** 管道函数 */
const pipe = (...args) => args.reduce((acc, el) => el(acc))

const title = 'Front End Interview'

const toLowerCase = (str) => str.toLowerCase()
const addHyphens = (str) => str.replace(/\s/g, '-')

// 案例：对标题转化为小写，并且通过 `-` 来进行单词的连接
pipe(title, toLowerCase, addHyphens) // "front-end-interview"

```



### 网络

#### WEB应用从服务器主动推送数据到客户端的方式

> ```bash
> ## WEB应用从服务器主动推送数据到客户端的方式
> 1. html5 的 websocket
> 2. websocket 通过 Flash
> 3. XHR 长时间连接
> 4. 不可见的 iframe
> 5. <script> 标签的长时间连接(可跨域)
> 6. ajax 轮询调用请求
> 
> 
> 
> ### Ajax 轮询
> Ajax 轮询是定时通过 Ajax 查询服务端，客户端按规定定时向服务端发送 ajax 请求，服务器接到请求后马上返回响应信息并关闭连接。
> 优点： 逻辑简单容易实现。
> 缺点：
>     * 需要不断向服务器发送消息询问，请求中有大半是无用，浪费带宽和服务器资源。
>     * 通过模拟服务器发起的通信，不是实时通信，不顾及应用的状态改变并且盲目检查更新，导致服务器资源浪费，且会加重网络负载，拖累服务器。
>     * 前端长时间处于轮询占用CPU，并且由于JS是单线程，轮询间隔无法保证。
> 实例：适于小型应用。
> 
> 
> ### WebSocket 通过 Flash
> Flash Socket：在页面中内嵌入一个使用了Socket类的 `Flash` 程序，`JavaScript`通过调用此`Flash`程序提供的Socket接口与服务器端的Socket接口进行通信，JavaScript在收到服务器端传送的信息后控制页面的显示。
>  * 优点：实现真正的即时通信，而不是伪即时。
>  * 缺点：客户端必须安装Flash插件；非HTTP协议，无法自动穿越防火墙。
>  * 实例：网络互动游戏。
> 
> 
> ### XHR 长时间连接（长轮询）
> 客户端打开一个到服务器端的 `AJAX` 请求然后等待响应；服务器端需要一些特定的功能来允许请求被挂起，只要一有事件发生，服务器端就会在挂起的请求中送回响应并关闭该请求。
> 客户端 JavaScript 响应处理函数会在处理完服务器返回的信息后，再次发出请求，重新建立连接；如此循环。
> 优点： 
>  		 * 对于前端来说实现简单，与普通的网络请求没有太大区别。
>  		 * 在无消息的情况下不会频繁的请求。
> 缺点： 
>  		 * 需要服务器端有特殊的功能来临时挂起连接，服务器hold连接会消耗资源。
>  		 * 客户端发起的连接较多时，服务器端会长期保持多个连接，具有一定的风险。
> 实例：WebQQ、Hi网页版、Facebook IM。
> 
> 
> ### 不可见的iframe（长连接）
> 在页面中嵌入一个隐藏的`iframe`，将这个隐藏的`iframe`的`src`属性设置为对一个长连接的请求或者采用XRH请求，服务器端就能源源不断地往客户端输入数据。
>  * 优点：消息即时到达，不发无用的请求；管理起来也相对方便。
>  * 缺点：服务器维护一个长连接会增加开销。
>  * 实例：Gmail聊天
> 
> 
> ### `<script>` 标签
> 把 script 标签附加到页面上以让脚本执行。服务器会挂起连接直到有事件发生，接着把脚本内容发送回浏览器，然后重新打开另一个 script 标签来获取下一个事件，从而实现长轮询的模型。
> 	 * 缺点：前后端实现都很麻烦
> 	 
> 	 
> ### html5 websocket
> `WebSocket`是HTML5开始提供的一种在单个 `TCP` 连接上进行全双工通讯的协议。
> 在WebSocket API中，浏览器和服务器只需要做一个握手的动作，然后，浏览器和服务器之间就形成了一条快速通道。两者之间就直接可以数据互相传送。
>  * 优点： 实现简单、可靠。
>  * 缺点： 部分低版本浏览器可能不支持。
> ```

### TypeScript

#### add函数，要求参数类型相同，否则报错

> ```bash
> ## add函数，要求参数类型相同，否则报错
> const func = (a, b) => a + b; 要求编写Typescript，要求a，b参数类型一致，都为number或者都为string
> 
> 
> ### 1. 使用 扩展运算符 + 数组设定类型
> const add = (...values: Array<string> | Array<number>) => values.reduce((total, num) => total + num, 0)
> add(1, 2, 3)
> add('a', 'b', 'c')
> add('a', 1, 2)
> 
> 
> ### 2. 函数重载
> interface Add {
>  (a: string, b: string): string
>  (a: number, b: number): number
> }
> const add: Add = (a, b) => values.reduce((total, num) => total + num, 0)
> 
> 
> ### 3. 泛型（答案错误的，仅供参考，在传递字符串的时候会报错）
> type IFun<T extends number | string> = (...values: Array<T>) => T extends number ? number : string
> const add: IFun<number> = (...values) => values.reduce((total, num) => total + num, 0)
> add(1, 2)
> add('a', 'b') // 报错
> add('a', 1) // 报错
> ```



### 设计模式

#### 工厂模式

> **工厂模式：同样的形式参数返回不同的实例**
>
> ```js
> /** 工厂构造函数 */
> function Superman () { this.name = '超级管理员' }
> function CommonMan () { this.name = '普通用户' }
> 
> /** 简单工厂 */
> function Factory () {}
> Factory.prototype.getInstance = function (className) {
>  try {
>     return eval('new' + className + '()')
>  } catch {
>     throw new Error('参数错误，不存在该工厂构造函数')
>  }
> }
> 
> const factory = new Factory()
> const obj1 = factory.getInstance('Superman')
> const obj2 = factory.getInstance('CommonMan')
> console.log(obj1.name, obj2.name)	// 超级管理员， 普通用户
> ```

#### 代理模式

> **代理模式：新建个类包装老类，对被包装的类进行管控及分发**
>
> ```js
> function Person () { }
> Person.prototype.sayName = function () { console.log('willysliang') }
> Person.prototype.sayAge = function () { console.log(30) }
> 
> /** 代理类 */
> function PersonProxy () {
>  const that = this
>  this.person = new Person()
>  // 代理调用 Person 的方法
>  this.callMethod = function (functionName) {
>     try {
>       that.person[functionName]()	// 代理
>     } catch {
>       throw new Error('参数错误，原对象不存在该方法')
>     }
>  }
> }
> 
> const person1 = new PersonProxy()
> person1.callMethod('sayName')
> person1.callMethod('sayAge') // 代理调用Person的方法 sayAge()
> ```

#### 单例模式

> **单例模式：任意对象都是单例，无须特别处理**
>
> ```js
> // demo1
> const obj = { name: 'willysliang', age: 24 }
> 
> 
> // demo2
> let box = null
> const createBox = (_a, _b) => {
>  if (!box) { box = Object.create(null) }
>  box.a = _a
>  box.b = _b
>  return box
> }
> 
> const obj1 = createBox(3, 6)
> console.log(obj1) // {a: 3, b: 6}
> 
> const obj2 = createBox(10, 20)
> console.log(obj1) // {a: 10, b: 20}
> console.log(obj2) // {a: 10, b: 20}
> ```

#### 发布订阅模式

> ```js
> // 发布者
> function Publisher () {
>  this.listeners = []
> }
> Publisher.prototype.addListener = function (listener) {
>  this.listeners.push(listener)
> }
> Publisher.prototype.removeListener = function (listener) {
>  delete this.listeners[listener]
> },
>  Publisher.prototype.notify = function (obj) {
>  for(let i = 0; i < this.listeners.length; i++) {
>     const listener = this.listeners[i]
>     if (typeof listener !== 'undefined') {
>       listener.process(obj)
>     }
>  }
> }
> }
> 
> // 订阅者
> function Subscriber () {  }
> Subscriber.prototype.process = function (obj) {
>  console.log(obj)
> }
> 
> const publisher = new Publisher()
> publisher.addListener(new Subscriber())
> publisher.addListener(new Subscriber())
> publisher.notify({ name: 'willy', age: 24 }) // 发布一个对象到所有订阅者
> publisher.notify('this is string value') // 发布一个字符串到所有订阅者
> ```



## 数据处理

### 树形菜单

#### 根据子节点ID找父节点

> ```js
> let arr = [  //数组树型结构
> {
>   children: '',
>   id: '11111'
> },
> {
>   children: [
>       {
>         children: '',
>         id: '22221'
>       },
>       {
>         name: [
>           {
>             children: '',
>             id: '33332'
>           }
>         ],
>         id: '22222'
>       }
>   ],
>   id: '11112'
> },
> {
>   children: [
>       {
>         children: [
>           {
>             children: [
>               {
>                 children: [],
>                 id: '44444'
>               }
>             ],
>             id: '33334'
>           }
>         ],
>         id: '22224'
>       }
>   ],
>   id: '11114'
> },
> ]
> ```

##### 逆向递归--多维数组根据子节点ID查找所有相关联父节点ID

> 1. 判断数组是否为空，以此来跳出循环
> 2. 对数组进行遍历，查找子节点的id的位置
>     - 若该层数组没有找到，则通过递归往深一层找
> 3. 找到父节点后，则把父节点Id取出，并根据父节点id继续递归查找
>
> ```js
> let result = [];  //用来接收相关联父级id的集合
> getParentNode = (arr, id) => {
>   if (!arr.length) return;
>   arr.forEach(item => {
>     // 数组不存在子节点 或 子节点长度为0，则不执行
>     if (!item.children || !item.children.length) return;
>     // 利用some筛选子级有没有符合条件的，有就重新递归，没有就继续递归
>     if (item.children.some(row => row.id == id)) {
>       result.unshift(item.id)
>       //重新递归
>       getParentNode(a, item.id)
>     } else {
>       //继续递归
>       getParentNode(item.children, id)
>     }
>   });
> }
> getParentNode(arr, '44444');	// 要查找的子节点id
> ```
>
> ```js
> // 知晓子节点寻找父节点
> treeFindPath(tree, func, path = []) {
>   if (!tree) return []
>   for (const data of tree) {
>     path.push(data.code)
>     if (func(data)) return path
>     if (data.children) {
>       const findChildren = treeFindPath(data.children, func, path)
>       if (findChildren.length) return findChildren
>     }
>     path.pop()
>   }
>   return []
> };
> let ssfj = treeFindPath(treeData,data=> data.code==rows[0].werks && data.type == 30);
> ```

#### 数组转树形结构

> ```js
> const json = require("./json")
> let data = json.data.rows.qmQmsRalUserareaList;
> toTree = (arr) => {
> let werks = {};
> let list = [];
> arr.forEach((item, i) => {
>  werks[item.werksShortname] 
>    ? werks[item.werksShortname] = [...werks[item.werksShortname], i]  
>  	: werks[item.werksShortname] = [i]
> });
> Object.keys(werks).forEach((item, i) => {
>  item.forEach((val, j) => {
>    // list[i].push({})
>  })
> })
> console.log( werks)
> }
> toTree(data)
> ```



## 文件

### 下载文件

#### 使用  download 属性

> - 将 `download` 属性添加到链接将强制浏览器下载文件，而不是导航到链接。并且可以向 `download` 属性传递一个字符串值作为可下载文件的名称。
> - 注意：IE11 不支持 download 属性，但有`polyfill`来支持这些不支持的环境中运行该属性
> - 下载限制：只有当文件与当前网站同域时，download属性才会起作用。如果 `href` 属性与站点的来源不同，则该属性无效。
>
> ```html
> <a href="/path/to/file" download>下载</a>
> <a href="/logo.png" download="logo">home</a>
> ```

#### 触发  click  事件

> - 这个想法来自于创建一个链接，并触发它的 `click` 事件。
>
>
> ```js
> // 创建一个新链接
> const link = document.createElement('a')
> link.download = 'file name'
> link.href = '/path/to/file'
> 
> // 添加到文档中
> document.body.appendChild(link)
> 
> // 触发点击事件
> link.click()
> 
> // 移除元素
> document.body.removeChild(link)
> ```

#### 下载生成数据的文件

> - 下载带有动态数据的文件是很常见的，例如一个JSON、一段文字或一个图像
> - 从数据中，我们可以将其转换为 `blob`，然后触发上述提到的 `click` 事件。以下示例代码创建一个 JSON blob 并下载它：
>
> ```js
> const data = JSON.stringify({ message: 'Hello world' })
> const blob = new Blob([data], { type: 'application/json' })
> 
> // 创建新的 URL
> const url = window.URL.createObjectURL(blob)
> 
> // 创建链接并触发下载
> // ...
> 
> // 释放上面创建的 URL
> window.URL.revokeObjectURL(url)
> ```

### 文件上传

#### 上传文件多选、限制文件类型、获取文件元数据

> - 文件上传的传统形式是使用`input`定义`type`为`file`类型接收上传的文件数据；通过监听`change`事件来获取上传的文件，并获取其文件的元数据
> - 使用`multiple`属性来设置是否可选上传多个文件（Boolean类型）
> - 使用`accpet`属性来限制上传文件的类型（不是所设置的类型会不显示出来）
> - 有一个非标准属性 `webkitdirectory`，使我们能够上传整个目录（虽然最初仅针对基于 WebKit 的浏览器实施，但 WebkitDirectory 在微软 Edge 以及 Firefox 50 及以后也可用。然而，即使它有相对广泛的支持，它仍然不是标准的，不应该使用，除非你别无选择）
>
> ```html
> <!-- html -->
> <!-- 单个文件上传 -->
> <input type="file" class="file-uploader" />
> <!-- 多个文件上传 -->
> <input type="file" class="file-uploader" multiple /> 
> <!-- 文件上传限制 -->
> <input type="file" class="file-uploader" accept=".jpg, .png" />
> <!-- 上传目录 -->
> <input type="file" id="file-uploader" webkitdirectory />
> 
> <!-- js -->
> <script>
>   const fileUploader = document.querySelectorAll(".file-uploader");
> 
>   fileUploader.forEach((item, i) => {
>     // 添加 change 事件监听器读取 event.target.files 文件对象
>     fileUploader[i].addEventListener("change", (event) => {
>       // 获取文件列表数组
>       const files = event.target.files;
> 
>       // 循环浏览文件并获取元数据
>       for (const file of files) {
>         const name = file.name
>         const type = file.type ? file.type : 'NA'
>         const size = file.size
>         const lastModified = file.lastModified
>         console.log({ file, name, type, size, lastModified })
>       }
>     });
>   })
> </script>
> ```

#### 上传文件前预览文件

##### window.URL.createObjectURL()

> **`URL.createObjectURL()`** 方法包含一个表示参数中给出的对象的 URL。这个新的 URL 对象表示指定的 [`File`](https://developer.mozilla.org/zh-CN/docs/Web/API/File) 对象或 [`Blob`](https://developer.mozilla.org/zh-CN/docs/Web/API/Blob) 对象。
>
> ```html
> <!-- html -->
> <input type="file" class="file-uploader" multiple />
> <img id="preview" />
> 
> <!-- js -->
> <script>
>   const fileUploader = document.querySelectorAll(".file-uploader");
>   const previewEle = document.getElementById('preview');
> 
>   fileUploader.forEach((item, i) => {
>     fileUploader[i].addEventListener("change", (event) => {
>       // 获取所选文件
>       const file = event.target.files[0];
> 
>       // 创建引用该文件的新 URL
>       const url = URL.createObjectURL(file);
> 
>       // 设置预览元素的源
>       previewEle.src = url;
>     });
>   })
> </script>
> ```

##### FileReader.readAsDataURL()

> - 使用 [`FileReader`](http://www.w3.org/TR/FileAPI/#FileReader-interface) 对象将文件转换为二进制字符串。然后添加 `load` 事件侦听器，以获得成功文件上传的二进制字符串。
> - `FileReader.readAsDataURL()` 方法用于读取指定的 `Blob` 或 `File`对象。
>
> ```html
> <!-- html -->
> <input type="file" class="file-uploader" multiple />
> <img id="preview" />
> 
> <!-- js -->
> <script>
>   const fileUploader = document.querySelectorAll(".file-uploader");
>   const previewEle = document.getElementById('preview');
> 
>   fileUploader.forEach((item, i) => {
>     // 获取 FileReader 的实例
>     const reader = new FileReader()
> 
>     fileUploader[i].addEventListener("change", (event) => {
>       const file = event.target.files[0];
> 
>       // 上传后获取文件对象，以 URL 二进制字符串的形式读取数据
>       reader.readAsDataURL(file)
> 
>       // 加载后，对字符串进行处理
>       reader.addEventListener('load', (e) => {
>         // 设置预览元素的源
>         previewEle.src = reader.result;
>       })
>     });
>   })
> </script>
> ```

#### 限制上传文件的大小

> 在读取了文件的大小元数据，可以使用它进行文件大小验证。可以允许用户上传高达 1MB 的图像文件
>
> ```html
> <input type="file" id="file-uploader" />
> ```
>
> ```js
> const fileUploader = document.getElementById("file-uploader");
> 
> fileUploader.addEventListener("change", (event) => {
>   // 读取文件大小
>   const file = event.target.files[0];
>   const size = file.size;
> 
>   // 检查文件大小是否大于 1MB，提示对应消息。
>   let msg = "";
>   if (size > 1024 * 1024) {
>      msg = `允许的文件大小为 1MB。您尝试上载的文件大小为${size}`;
>   } else {
>      msg = `${size}文件已成功上载。`;
>   }
>   console.log(msg);
> });
> ```

#### 显示上传进度条

> 先在页面中放置一个 `progress` 标签
>
> ```html
> <label id="progress-label" for="progress"></label>
> <progress id="progress" value="0" max="100" value="0">0</progress>
> ```
>
> 定义 `progress` 事件的回调函数
>
> ```js
> const reader = new FileReader()
> 
> reader.addEventListener('progress', (e) => {
>   if (e.loaded && e.total) {
>      // 计算完成百分比
>      const percent = (e.loaded / e.total) * 100
>      // 将值设置为进度组件
>      progress.value = percent
>   }
> })
> ```

#### 拖拽上传文件

> ```html
> <!-- css -->
> <style>
>   .dashboard {
>     border-radius: 10px;
>     width: 400px;
>     height: 400px;
>     margin: 20px auto 0;
>     box-sizing: border-box;
>     padding: 12px;
>     border: 2px dashed #f8bbd0;
>     border-radius: 5px;
>     font-size: 20px;
>     color: #2c1612;
>     cursor: text;
>     white-space: pre-wrap;
>     /*word-break: break-all;*/
>     word-wrap: break-word;
>     overflow-y: auto;
>   }
> </style>
> 
> <!-- html -->
> <div id="dashboard" class="dashboard"></div>
> 
> <!-- js -->
> <script type="text/javascript">
>   var dashboard = document.getElementById("dashboard");
>   dashboard.addEventListener("dragover", function (e) {
>      e.preventDefault();
>      e.stopPropagation();
>   });
>   dashboard.addEventListener("dragenter", function (e) {
>      e.preventDefault();
>      e.stopPropagation();
>   });
>   dashboard.addEventListener("drop", function (e) {
>      // 必须要禁用浏览器默认事件
>      e.preventDefault();
>      e.stopPropagation();
>  
>      // 获取文件
>      var files = this.files || e.dataTransfer.files;
>      var reader = new FileReader();
>      reader.readAsText(files[0], "utf-8");
>      reader.onload = function (evt) {
>          var text = evt.target.result;
>          dashboard.innerText = text;
>      };
>   });
> </script>
> ```

#### 用对象处理文件

> 使用 `URL.createObjectURL()` 方法从文件创建一个唯一的 URL。使用 `URL.revokeObjectURL()` 方法释放它。
>
> DOM 和 `URL.createObjectURL()` 和 `URL.revokeObjectURL()` 方法允许您创建简单的 URL 字符串，可用于引用任何可以使用 DOM 文件对象引用的数据，包括用户计算机上的本地文件。
>
> ```html
> <div>
> <h1>使用 Object URL</h1>
> <input type="file" id="file-uploader" accept=".jpg, .jpeg, .png" />
> <div id="image-grid"></div>
> </div>
> ```
>
> ```js
> const fileUploader = document.getElementById('file-uploader')
> const reader = new FileReader()
> const imageGrid = document.getElementById('image-grid')
> 
> fileUploader.addEventListener('change', (event) => {
>   const files = event.target.files
>   const file = files[0]
> 
>   const img = document.createElement('img')
>   imageGrid.appendChild(img)
>   img.src = URL.createObjectURL(file)
>   img.alt = file.name
> })
> ```

### 图片路径转base64

> ```bash
> # 2022年8月19日17:14:00  图片上传转换为base64格式封装
> 	1. 通过创建一个canvas画布：document.createElement('canvas')
> 	2. 把图片路径传递到画布，然后让画布获取图片的信息（如图片宽高和路径内容）
> 	3. 通过 canvas.getContext('2d').drawImage() 绘画出图片信息
> 	4. 通过 canvas.toDataURL('image/jpeg') 绘画成图片 base64 信息
> ```

#### 将图像文件转换为base64

> ```js
> /* image转Base64 */
> imageToBase64(file) {
>   let reader = new FileReader()
>   reader.readAsDataURL(file)
>   reader.onload = () => {
>     console.log('file 转 base64结果：' + reader.result)
>     const imgBase64 = reader.result
>     }
>   reader.onerror = (error) => {
>     console.log('Error: ', error)
>   }
> }
> 
> 
> /* Base64图像直接显示在标签 */
> <img :src="imgBase64" />
> ```

#### 网络图片转base64（单张）

> ```js
> //异步执行
> const imageUrlToBase64 = (imageUrl) => {
>   let imageFile = new Image();
>   imageFile.setAttribute('crossOrigin', 'anonymous'); //解决跨域问题
>   imageFile.src = imageUrl
>   //image.onload为异步加载
>   imageFile.onload = () => {
>     const canvas = document.createElement('canvas');
>     canvas.width = imageFile.width;
>     canvas.height = imageFile.height;
> 
>     const context = canvas.getContext('2d');
>     context.drawImage(imageFile, 0, 0, canvas.width, canvas.height)
> 
>     //使用toDataUrl将图片转换成jpeg的格式,不要把图片压缩成png，因为压缩成png后base64的字符串可能比不转换前的长
>     return canvas.toDataURL('image/jpeg') // 返回值为就是base64类型
>   }
> }
> ```

#### 网络图片转base64（多张）

> ```js
> /***
>  * 采用递归同步执行
>  * 每次获取存储图片路径的数组的第一个图片地址进行计算，
>  * 然后存储到导出的数组中，并删除该第一位数组，然后携带所导出的数据进行递归
> */
> const resultImgData = [];
> 
> const imageUrlToBase64 = (imgUrlList, i) => {
>   let imageFile = new Image();
>   imageFile.setAttribute('crossOrigin', 'anonymous'); //解决跨域问题
>   imageFile.src = imgUrlList[i]
>   //image.onload为异步加载
>   imageFile.onload = () => {
>     const canvas = document.createElement('canvas');
>     canvas.width = imageFile.width;
>     canvas.height = imageFile.height;
> 
>     const context = canvas.getContext('2d');
>     context.drawImage(imageFile, 0, 0, canvas.width, canvas.height)
> 
>     resultImgData.push(canvas.toDataURL('image/jpeg'))
>     imgUrlList.shift();
>     if(++i <= len) {
>       imageUrlToBase64(imgUrlList, i)
>     }
>   }
> }
> 
> const imgUrlList = [
>   'blob:http://localhost:3000/7fa9ee7e-29c4-4f9e-9762-0a02ad00760a',
>   'blob:http://localhost:3000/7fa9ee7e-29c4-4f9e-9762-0a02ad00760a',
>   'blob:http://localhost:3000/7fa9ee7e-29c4-4f9e-9762-0a02ad00760a',
> ]
> 
> imageUrlToBase64(imgUrlList);
> console.log("导出的图片地址", resultImgData);
> ```

#### base64转换图片显示

> ```vue
> <template>
> <img 
>    style="width:200px; height:200px;" 
>    :src="'data:img/png;base64,' + imgData.imgBase64" 
>    alt="图片加载失败" 
>    :title="imgData.imgTitle"
>  />
> </template>
> 
> <script setup>
>   import { reactive } from 'vue'
>   const imgData = reactive({
>     imgBase64: " base64的编码 ",  // 照片base64数据是来自后端 或 根据图片来转换
>     imgTitle: "图片标题"
>   })
> </script>
> ```

### 下载/打印为文件流的pdf

> **注意：若使用Blod，则需要在请求中增加数据格式`responseTtpe: blod`**
>
> ```js
> // post请求
> axios({
>   method: 'post',
>   url: 'api/user/',
>    data: {
>        firstName: 'Fred',
>        lastName: 'Flintstone'
>     },
>     responseType: 'blob'
> }).then(response => {
>    this.download(response)
> }).catch((error) => {
>   this.$message.error(error)
> })
> 
> // get 请求
> axios({
>   methods: "get",
>   url: env['qm_assist'] + `q/printPDF?id=${this.id}&sapNum=${this.sapNum}`,
>    responseType: 'blod'
> }).then(res => {
>      let blob = new Blob([res.data], {
>        type: "application/pdf;charset=utf-8",
>      })
>      console.log(blob, res)
>      this.printpdf(blob) 
>   }).catch(err => {
>      this.$message.error(error)
>  })
> 
> 
> // 下载文件
> download(data) {
>   if (!data) { return; }
>   let url = window.URL.createObjectURL(new Blob([data]))
>    let link = document.createElement('a')
>    link.style.display = 'none'
>    link.href = url
>    link.setAttribute('download', 'excel.xlsx')
> 
>    document.body.appendChild(link)
>   link.click()
> }
> ```

#### 下载

> **思路：点击下载用了a标签来接收，由于a标签点击自动下载pdf，新创建一个a标签之后，下载完成之后要释放掉URL对象**
>
> 1. 先获取后台返回所保存的pdf的路径（pdf存在服务器中的url）
> 2. 创建一个a标签，并给该a标签赋予下载
> 3. 把该a标签追加到页面的body标签中
> 4. 给a标签触发点击事件
> 5. 移除该a标签
>
>   ```js
> //1. 下载功能，dataResult是后台返回的文件流
> const downloadFile = (dataResult) = > {
>   let pdfUrl = window.URL.createObjectURL(
>   	new Blob([dataResult.data], { type: `application/pdf` })
>   )
>   const fileName = item.name; // 下载文件的名字
>   const link = document.createElement('a');
>   link.href = pdfUrl;
>   link.setAttribute('download', fileName);
>   document.body.appendChild(link);
>   link.click();
>   document.body.removeChild(link)
> }
> 
> 
> //2. 下载功能，dataResult是后台返回的base64
> const downloadFileBase64 = () => {
>   let blob = this.dataURLtoBlob(dataResult);
>   const elink = document.createElement('a')
>   elink.download = item.name; // 下载文件的名字
>   elink.href = window.URL.createObjectURL(blob)
>   elink.click()
>   window.URL.revokeObjectURL(elink.href) // 释放URL 对象
> }
>   ```

#### 打印

> **思路：因为我的打印是打印的pdf，并不是当前页面，如果直接使用window.print()，则是打印的当前页面**
>
> **注意：{ type: 'application/pdf' }要加上，否则有可能无法进行打印**
>
> ```ts
> //1. 打印功能，dataResult是后台返回的base64
> let blob = this.dataURLtoBlob(dataResult);
> const date = (new Date()).getTime()
> let ifr = document.createElement('iframe')
> ifr.style.frameborder = 'no'
> ifr.style.display = 'none'
> ifr.style.pageBreakBefore = 'always'
> ifr.setAttribute('id', 'printPdf' + date)
> ifr.setAttribute('name', 'printPdf' + date)
> ifr.src = window.URL.createObjectURL(blob)
> document.body.appendChild(ifr)
> this.doPrint('printPdf' + date)
> window.URL.revokeObjectURL(ifr.src) // 释放 URL 对象
> 
> 
> // 2. 打印功能，res.data是后台返回的文件流
> const printFile = (res) => {
>      let blob = new Blob([res.data], { type: "application/pdf;charset=utf-8" })
>      let reader = new FileReader()
>      reader.readAsDataURL(blob)
>     reader.addEventListener('loadend', () => {
>        // 通知主进程打印
>        ipcRenderer.send("IPCR_PDF_PRINT", {
>          baseCode: Buffer.from(reader.result.split('base64,')[1], 'base64'),
>        })
>      }
>                           }
> ```

### 打印DOM内容

#### 打印dom图片

> ```html
> <img id="image" src="https://images.pexels.com/photos/753626/pexels-photo-753626.jpeg?auto=compress&cs=tinysrgb&dpr=1&w=500"/>
> <button id="print">打印</button>
> ```
>
> ```js
> // 添加打印事件
> const printBtn = document.getElementById("print");
> printBtn.addEventListener("click", function () {
>   // 创建一个虚拟的 iframe 标签，并将其隐藏
>   const iframe = document.createElement("iframe");
>   Object.assign(iframe.style, {
>      height: 0,
>      width: 0,
>      visibility: "hidden",
>   });
> 
>   // 设置 iframe 的源，并添加到 body 标签下
>   iframe.setAttribute("srcdoc", "<html><body>");
>   document.body.appendChild(iframe);
> 
>   // 尽管 iframe 源是一个简单的 HTML，而不是 src 属性定义的远程路径，但我们必须等待 iframe 完全加载再进行处理
>   iframe.addEventListener("load", function () {
>      // 克隆图像
>      const image = document.getElementById("image").cloneNode();
>      image.style.maxWidth = "100%";
> 
>      // 将图像附加到 iframe 的 body 上
>      const body = iframe.contentDocument.body;
>      body.style.textAlign = "center";
>      body.appendChild(image);
> 
>      // 当图像准备就绪时调用打印
>      image.addEventListener("load", function () {
>          iframe.contentWindow.print();
>      });
>   });
> });
> ```

#### 打印设定标签内容

```html
<div id="printCont">
  <h1>要打印的标签标题</h1>
  <p>要打印的标签内容</p>
  <img src="https://images.pexels.com/photos/753626/pexels-photo-753626.jpeg?auto=compress&cs=tinysrgb&dpr=1&w=500" />
</div>
<button class="print-btn" id="handlePrint">打印</button>
```

```js
// 添加打印事件
const printBtn = document.getElementById("handlePrint");
printBtn.addEventListener("click", function () {
  // 创建一个虚拟的 iframe 标签，并将其隐藏
  const iframe = document.createElement("iframe");
  Object.assign(iframe.style, {
    height: 0,
    width: 0,
    visibility: "hidden",
  });

  // 设置 iframe 的源，并添加到 body 标签下
  iframe.setAttribute("srcdoc", "<html><body>");
  document.body.appendChild(iframe);

  // 尽管 iframe 源是一个简单的 HTML，而不是 src 属性定义的远程路径，但我们必须等待 iframe 完全加载再进行处理
  iframe.addEventListener("load", function () {
    // 克隆图像
    const printEle = document.getElementById("printCont").cloneNode(true);

    printEle.style.maxWidth = "100%";

    // 将图像附加到 iframe 的 body 上
    const body = iframe.contentDocument.body;
    body.style.textAlign = "center";
    body.appendChild(printEle);

    iframe.contentWindow.print();
  });
});
```



### 将表格导出到 csv

```ts
/**
 * @function toCsv 将 `table` 的所有单元格导出为 CSV 格式
 * @param tableEle
 * @returns
 * @desc
 *  1. 选择所有行，在它们上面循环并将每一行导出到 CSV。
 *  2. 在每一行中，我们遍历所有单元格，并使用 `textContent` 检索它们的文本内容
 */
const toCsv = (table: HTMLElement) => {
  const rows = table.querySelectorAll('tr')

  return ([] as HTMLTableRowElement[]).slice
    .call(rows!)
    .map((row) => {
      const cells = row.querySelectorAll('th, td')
      return [].slice
        .call(cells)
        .map((cell: any) => {
          return cell.textContent
        })
        .join(',')
    })
    .join('\n')
}

const download = (text, fileName) => {
  const link = document.createElement('a')
  link.setAttribute(
    'href',
    `data:text/csv;charset=utf-8,${encodeURIComponent(text)}`,
  )
  link.setAttribute('download', fileName)

  link.style.display = 'none'
  document.body.appendChild(link)

  link.click()

  document.body.removeChild(link)
}

const table = document.getElementById('exportMe')
const exportBtn = document.getElementById('export')
exportBtn?.addEventListener('click', () => {
  // 导出到 csv
  const csv = toCsv(table!)
  // 下载
  download(csv, 'download.csv')
})

```



## 主题

### 主题切换方案

#### 方案1：link标签动态引入

> ```bash
> ## 做法
> 其做法就是提前准备好几套`CSS`主题样式文件，在需要的时候，创建`link`标签动态加载到`head`标签中，或者是动态改变`link`标签的`href`属性
> 
> ## 优点：
> - 实现了按需加载，提高了首屏加载时的性能
> 
> ## 缺点：
> - 动态加载样式文件，如果文件过大网络情况不佳的情况下可能会有加载延迟，导致样式切换不流畅
> - 如果主题样式表内定义不当，会有优先级问题
> - 各个主题样式是写死的，后续针对某一主题样式表修改或者新增主题也很麻烦
> ```
>
> ![image-20220906160246298](./image/image-20220906160246298.png)
>
> ![主题切换方案一](./image/Theme_switching_plan_1.gif)

#### 方案2：提前引入所有主题样式，做类名切换

> 这种方案与第一种比较类似，为了解决反复加载样式文件问题提前将样式全部引入，在需要切换主题的时候将指定的根元素类名更换，相当于直接做了样式覆盖，在该类名下的各个样式就统一地更换了。其基本方法如下：
>
> ```css
> /* day样式主题 */
> body.day .box {
>   color: #f90;
>   background: #fff;
> }
> /* dark样式主题 */
> body.dark .box {
>   color: #eee;
>   background: #333;
> }
> 
> .box {
>   width: 100px;
>   height: 100px;
>   border: 1px solid #000;
> }
> ```
>
> ```vue
> <template>
> <button onclick="change('day')">day</button>
> <button onclick="change('dark')">dark</button>
> <p>hello</p>
> </template>
> 
> <script setup>
>   const change = (theme) => {
>     document.body.className = theme;
>   }
> </script>
> ```
>
> ![主题切换方案二](./image/Theme_switching_plan_2.gif)
>
> ```bash
> ## 优点：
> - 不用重新加载样式文件，在样式切换时不会有卡顿
> 
> ## 缺点：
> - 首屏加载时会牺牲一些时间加载样式资源
> - 如果主题样式表内定义不当，也会有优先级问题
> - 各个主题样式是写死的，后续针对某一主题样式表修改或者新增主题也很麻烦
> 
> ## 小结：
> 通过以上两个方案，我们可以看到对于样式的加载问题上的考量就类似于在纠结是做SPA单页应用还是MPA多页应用项目一样。两种其实都误伤大雅，但是最重要的是要保证在后续的持续开发迭代中怎样会更方便。因此我们还可以基于以上存在的问题和方案做进一步的增强。
> ```

#### 方案3：CSS变量+类名切换

> ```bash
> ## 实现
> 在`Vue3`官网有一个暗黑模式切换按钮，点击之后就会平滑地过渡，虽然`Vue3`中也有一个`v-bind`特性可以实现动态样式绑定，但经过观察以后`Vue`官网并没有采取这个方案。
> 大体思路跟方案2相似，依然是提前将样式文件载入，切换时将指定的根元素类名更换。不过这里相对灵活的是，默认在根作用域下定义好CSS变量，只需要在不同的主题下更改CSS变量对应的取值即可。
> 在Vue3官网还使用了`color-scheme: dark;`将系统的滚动条设置为了黑色模式，使样式更加统一。
>      html.dark {
>          color-scheme: dark;
>      }
> 
> 
> ## 优点：
> - 不用重新加载样式文件，在样式切换时不会有卡顿
> - 在需要切换主题的地方利用var()绑定变量即可，不存在优先级问题
> - 新增或修改主题方便灵活，仅需新增或修改CSS变量即可，在var()绑定样式变量的地方就会自动更换
> 
> 
> ## 缺点：
> - IE兼容性（忽略不计）
> - 首屏加载时会牺牲一些时间加载样式资源
> ```
>
> **实现方案如下**
>
> ```css
> /* 定义根作用域下的变量 */
> :root {
>   --theme-color: #333;
>   --theme-background: #eee;
> }
> /* 更改dark类名下变量的取值 */
> .dark{
>   --theme-color: #eee;
>   --theme-background: #333;
> }
> /* 更改pink类名下变量的取值 */
> .pink{
>   --theme-color: #fff;
>   --theme-background: pink;
> }
> 
> .box {
>   transition: all .2s;
>   width: 100px;
>   height: 100px;
>   border: 1px solid #000;
>   /* 使用变量 */
>   color: var(--theme-color);
>   background: var(--theme-background);
> }
> ```
>
> ![主题切换方案三](./image/Theme_switching_plan_3.gif)

#### 方案4：Vue3新特性（v-bind）

> 虽然这种方式存在局限性只能在Vue开发中使用，但是为Vue项目开发者做动态样式更改提供了又一个不错的方案。
>
> ### 简单用法
>
> ```vue
> <script setup>
>   // 这里可以是原始对象值，也可以是ref()或reactive()包裹的值，根据具体需求而定
>   const theme = { color: 'red' }
> </script>
> 
> <template>
> <p>hello</p>
> </template>
> 
> <style scoped>
>   p {
>     color: v-bind('theme.color');
>   }
> </style>
> ```
>
> `Vue3`中在`style`样式通过`v-bind()`绑定变量的原理其实就是给元素绑定CSS变量，在绑定的数据更新时调用[CSSStyleDeclaration.setProperty](https://developer.mozilla.org/zh-CN/docs/Web/API/CSSStyleDeclaration/setProperty)更新CSS变量值。
>
> ### 实现思考
>
> 前面方案3基于CSS变量绑定样式是在`:root`上定义变量，然后在各个地方都可以获取到根元素上定义的变量。现在的方案我们需要考虑的问题是，如果是基于JS层面如何在各个组件上优雅地使用统一的样式变量？
> 我们可以利用Vuex或Pinia对全局样式变量做统一管理，如果不想使用类似的插件也可以自行封装一个hook，大致如下：
>
> ```js
> /* theme.ts */
> // 定义暗黑主题变量
> export const theme_dark = {
>     fontSize: '16px',
>     fontColor: '#eee',
>     background: '#333',
> };
> 
> // 定义白天主题变量
> export const theme_day = {
>     fontSize: '20px',
>     fontColor: '#f90',
>     background: '#eee',
> };
> ```
>
> ```ts
> /* useTheme.ts */
> import { shallowRef } from 'vue';
> // 引入主题
> import { theme_day, theme_dark } from './theme';
> 
> // 定义在全局的样式变量
> const theme = shallowRef({});
> 
> export function useTheme() {
>   // 尝试从本地读取
>   const localTheme = localStorage.getItem('theme');
>   theme.value = localTheme ? JSON.parse(localTheme) : theme_day;
> 
>   const setDayTheme = () => {
>      theme.value = theme_day;
>   };
> 
>   const setDarkTheme = () => {
>      theme.value = theme_dark;
>   };
> 
>   return {
>      theme,
>      setDayTheme,
>      setDarkTheme,
>   };
> }
> ```
>
> **使用自己封装的主题hook**
>
> ```vue
> <script setup lang="ts">
>   import { useTheme } from './useTheme.ts';
>   import MyButton from './components/MyButton.vue';
> 
>   const { theme } = useTheme();
> </script>
> 
> <template>
> <div class="box">
>    <span>Hello</span>
> </div>
> <my-button />
> </template>
> 
> <style lang="scss">
>   .box {
>     width: 100px;
>     height: 100px;
>     background: v-bind('theme.background');
>     color: v-bind('theme.fontColor');
>     font-size: v-bind('theme.fontSize');
>   }
> </style>
> ```
>
> ````vue
> <!-- myButton.vue -->
> <script setup lang="ts">
>   import { useTheme } from '../useTheme.ts';
> 
>   const { theme, setDarkTheme, setDayTheme } = useTheme();
> 
>   const change1 = () => {
>     setDarkTheme();
>   };
> 
>   const change2 = () => {
>     setDayTheme();
>   };
> </script>
> 
> <template>
> <button class="my-btn" @click="change1">dark</button>
> <button class="my-btn" @click="change2">day</button>
> </template>
> 
> <style scoped lang="scss">
>   .my-btn {
>     color: v-bind('theme.fontColor');
>     background: v-bind('theme.background');
>   }
> </style>
> ````
>
> ![主题切换方案四](./image/Theme_switching_plan_4.gif)
>
> ```bash
> 其实从这里可以看到，跟Vue的响应式原理一样，只要数据发生改变，Vue就会把绑定了变量的地方通通更新。
> 
> 
> ### 优点：
> - 不用重新加载样式文件，在样式切换时不会有卡顿
> - 在需要切换主题的地方利用v-bind绑定变量即可，不存在优先级问题
> - 新增或修改主题方便灵活，仅需新增或修改JS变量即可，在v-bind()绑定样式变量的地方就会自动更换
> 
> 
> ### 缺点：
> - ~~IE兼容性（忽略不计）~~
> - 首屏加载时会牺牲一些时间加载样式资源
> - 这种方式只要是在组件上绑定了动态样式的地方都会有对应的编译成哈希化的CSS变量，而不像方案3统一地就在:root上设置（不确定在达到一定量级以后的性能），也可能正是如此，Vue官方也并未采用此方式做全站的主题切换
> ```

#### 方案5：SCSS + mixin + 类名切换

> 主要是运用SCSS的混合+CSS类名切换，其原理主要是首先要在页面的根元素上定义一个 `dataset`: `<html lang="en" data-theme="theme1">`，然后将使用到mixin混合的地方编译为固定的CSS以后，再通过类名切换去做样式的覆盖，实现方案如下：
> **定义SCSS变量**：
>
> ```css
> /* variable.scss */
> /* 字体定义规范 */
> $font_samll:12Px;
> $font_medium_s:14Px;
> $font_medium:16Px;
> $font_large:18Px;
> 
> /* 背景颜色规范(主要) */
> $background-color-theme: #d43c33;//背景主题颜色默认(网易红)
> $background-color-theme1: #42b983;//背景主题颜色1(QQ绿)
> $background-color-theme2: #333;//背景主题颜色2(夜间模式)
> 
> /* 背景颜色规范(次要) */ 
> $background-color-sub-theme: #f5f5f5;//背景主题颜色默认(网易红)
> $background-color-sub-theme1: #f5f5f5;//背景主题颜色1(QQ绿)
> $background-color-sub-theme2: #444;//背景主题颜色2(夜间模式)
> 
> /* 字体颜色规范(默认) */
> $font-color-theme : #666;//字体主题颜色默认(网易)
> $font-color-theme1 : #666;//字体主题颜色1(QQ)
> $font-color-theme2 : #ddd;//字体主题颜色2(夜间模式)
> 
> /* 字体颜色规范(激活) */
> $font-active-color-theme : #d43c33;//字体主题颜色默认(网易红)
> $font-active-color-theme1 : #42b983;//字体主题颜色1(QQ绿)
> $font-active-color-theme2 : #ffcc33;//字体主题颜色2(夜间模式)
> 
> /* 边框颜色 */
> $border-color-theme : #d43c33;//边框主题颜色默认(网易)
> $border-color-theme1 : #42b983;//边框主题颜色1(QQ)
> $border-color-theme2 : #ffcc33;//边框主题颜色2(夜间模式)
> 
> /* 字体图标颜色 */
> $icon-color-theme : #ffffff;//边框主题颜色默认(网易)
> $icon-color-theme1 : #ffffff;//边框主题颜色1(QQ)
> $icon-color-theme2 : #ffcc2f;//边框主题颜色2(夜间模式)
> $icon-theme : #d43c33;//边框主题颜色默认(网易)
> $icon-theme1 : #42b983;//边框主题颜色1(QQ)
> $icon-theme2 : #ffcc2f;//边框主题颜色2(夜间模式)
> ```
>
> **定义混合mixin**：
>
> ```scss
> /* mixin.scss */
> @import "./variable.scss";
> 
> @mixin bg_color(){
>   background: $background-color-theme;
>   [data-theme=theme1] & {
>      background: $background-color-theme1;
>   }
>   [data-theme=theme2] & {
>      background: $background-color-theme2;
>   }
> }
> @mixin bg_sub_color(){
>   background: $background-color-sub-theme;
>   [data-theme=theme1] & {
>      background: $background-color-sub-theme1;
>   }
>   [data-theme=theme2] & {
>      background: $background-color-sub-theme2;
>   }
> }
> 
> @mixin font_color(){
>   color: $font-color-theme;
>   [data-theme=theme1] & {
>      color: $font-color-theme1;
>   }
>   [data-theme=theme2] & {
>      color: $font-color-theme2;
>   }
> }
> @mixin font_active_color(){
>   color: $font-active-color-theme;
>   [data-theme=theme1] & {
>      color: $font-active-color-theme1;
>   }
>   [data-theme=theme2] & {
>      color: $font-active-color-theme2;
>   }
> }
> 
> @mixin icon_color(){
>    color: $icon-color-theme;
>    [data-theme=theme1] & {
>        color: $icon-color-theme1;
>    }
>    [data-theme=theme2] & {
>        color: $icon-color-theme2;
>    }
> }
> 
> @mixin border_color(){
>   border-color: $border-color-theme;
>   [data-theme=theme1] & {
>      border-color: $border-color-theme1;
>   }
>   [data-theme=theme2] & {
>      border-color: $border-color-theme2;
>   }
> }
> ```
>
> ```vue
> <!-- Header -->
> <template>
> <div class="header" @click="changeTheme">
>    <div class="header-left">
>        <slot name="left">左边</slot>
>    </div>
>    <slot name="center" class="">中间</slot>
>    <div class="header-right">
>        <slot name="right">右边</slot>
>    </div>
> </div>
> </template>
> 
> <script>
>   export default {
>      name: 'Header',
>      methods: {
>          changeTheme () {
>            document.documentElement.setAttribute('data-theme', 'theme1')
>          }
>      }
>   }
> </script>
> 
> <style scoped lang="scss">
>   @import "../assets/css/variable";
>   @import "../assets/css/mixin";
>   .header{
>     width: 100%;
>     height: 100px;
>     font-size: $font_medium;
>     @include bg_color();
>   }
> </style>
> ```
>
> ![主题切换方案五](./image/Theme_switching_plan_5.gif)
> 可以发现，使用mixin混合在SCSS编译后同样也是将所有包含的样式全部加载：
> ![ce812151cabd40eb882833c2767c1bc](./image/ce812151cabd40eb882833c2767c1bc.png)
>
> ```bash
> 这种方案最后得到的结果与方案2类似，只是在定义主题时由于是直接操作的SCSS变量，会更加灵活。
> 
> ## 优点：
> - 不用重新加载样式文件，在样式切换时不会有卡顿
> - 在需要切换主题的地方利用mixin混合绑定变量即可，不存在优先级问题
> - 新增或修改主题方便灵活，仅需新增或修改SCSS变量即可，经过编译后会将所有主题全部编译出来
> 
> 
> ## 缺点：
> - 首屏加载时会牺牲一些时间加载样式资源
> ```

#### 方案6：CSS变量+动态setProperty

> 此方案较于前几种会更加灵活，不过视情况而定，这个方案适用于由用户根据颜色面板自行设定各种颜色主题，这种是主题颜色不确定的情况，而前几种方案更适用于定义预设的几种主题。
> 方案参考：[vue-element-plus-admin](https%3A%2F%2Fgitee.com%2Fkailong110120130%2Fvue-element-plus-admin)
> 主要实现思路如下：
> 只需在全局中设置好预设的全局CSS变量样式，无需单独为每一个主题类名下重新设定CSS变量值，因为主题是由用户**动态**决定。
>
> ```css
> :root {
> --theme-color: #333;
> --theme-background: #eee;
> }
> ```
>
> 定义一个工具类方法，用于修改指定的CSS变量值，调用的是[CSSStyleDeclaration.setProperty](https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FAPI%2FCSSStyleDeclaration%2FsetProperty)
>
> ```typescript
> export const setCssVar = (prop: string, val: any, dom = document.documentElement) => {
>   dom.style.setProperty(prop, val)
> }
> ```
>
> 在样式发生改变时调用此方法即可
>
> ```js
> setCssVar('--theme-color', color)
> ```
>
> ![主题切换方案六](./image/Theme_switching_plan_6.gif)
>
> ### vue-element-plus-admin主题切换源码：
>
> ![image-20220906163752395](./image/image-20220906163752395.png)
> 这里还用了`vueuse`的`useCssVar`不过效果和`Vue3`中使用`v-bind`绑定动态样式是差不多的，底层都是调用的[CSSStyleDeclaration.setProperty](https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FAPI%2FCSSStyleDeclaration%2FsetProperty)这个api
> ![image-20220906163956648](./image/image-20220906163956648.png)
>
> ```bash
> ## 优点：
> - 不用重新加载样式文件，在样式切换时不会有卡顿
> - 仔细琢磨可以发现其原理跟方案4利用Vue3的新特性v-bind是一致的，只不过此方案只在`:root`上动态更改CSS变量而Vue3中会将CSS变量绑定到任何依赖该变量的节点上。
> - 需要切换主题的地方只用在`:root`上动态更改CSS变量值即可，不存在优先级问题
> - 新增或修改主题方便灵活
> 
> 
> ## 缺点：
> - ~~IE兼容性（忽略不计）~~
> - 首屏加载时会牺牲一些时间加载样式资源（相对于前几种预设好的主题，这种方式的样式定义在首屏加载基本可以忽略不计）
> ```

#### 方案总结

> **说明**：两种主题方案都支持并不代表一定是最佳方案，视具体情况而定。
>
> | 方案/主题样式                           | 固定预设主题样式                                         | 主题样式不固定  |
> | --------------------------------------- | -------------------------------------------------------- | --------------- |
> | 方案1：link标签动态引入                 | √（文件过大，切换延时，不推荐）                          | ×               |
> | 方案2：提前引入所有主题样式，做类名切换 | √                                                        | ×               |
> | 方案3：CSS变量+类名切换                 | √（推荐）                                                | ×               |
> | 方案4：Vue3新特性（v-bind）             | √（性能不确定）                                          | √（性能不确定） |
> | 方案5：SCSS + mixin + 类名切换          | √（推荐，最终呈现效果与方案2类似，但定义和使用更加灵活） | ×               |
> | 方案6：CSS变量+动态setProperty          | √（更推荐方案3）                                         | √（推荐）       |

#### vue3 配置使用scss全局变量

> 只要在 vue.config.js 配置一下就可以了，配置的环境是 vue3，但是 vue2 也应该适用
>
> ```js
> /* vue.config.js */
> module.exports = {
>   css: {
>      loaderOptions: {
>          sass: {
>            // 具体路径根据你们项目来
>            additionalData: `@import "@/assets/theme.scss";`
>          },
>          scss: {
>            additionalData: `@import "@/assets/theme.scss";`
>          }
>      }
>   }
> }
> ```



### 暗黑模式

设置暗黑模式

````bash
#### 暗黑模式的实现
- `invert` — 反转元素和图片的颜色。在 100% 的情况下会完全反转，即黑色变为白色，白色变为黑色，#222 -> #ddd。
- `hue-rotate` — 帮助我们处理所有其他非黑色和白色的颜色。 将色相旋转 180 度，我们确保应用程序的颜色主题不会改变，而只是减弱其颜色。

注意，它还会反转应用程序中的所有图像和视频。如果不想给图片、视频应用暗黑模式，
````

```css
html[theme='dark-mode'] {
  filter: invert(1) hue-rotate(180deg);
}

img,
video {
  filter: invert(1) hue-rotate(180deg);
}
```



#### 检测暗模式

```bash
macOS、Windows 10 等现代操作系统允许用户选择他们希望在所有应用程序中看到的外观。

可以通过查看 `prefers-color-scheme` 媒体查询来检测该选项。它可以是以下值之一：
    - `light`：用户希望以浅色模式查看页面
    - `dark`：用户希望在暗黑模式下查看页面
    - `no-preference`：系统不知道用户的偏好
通过检查此媒体查询值，我们可以确定用户是否喜欢暗模式，获取系统是否处于暗模式下有两种方式。

```

使用 CSS 媒体查询检测 CSS 中的首选配色方案：

```css
@media (prefers-color-scheme: light) {
  body {
    filter: invert(0);
  }
}

/* Dark mode */
@media (prefers-color-scheme: dark) {
  body {
    filter: invert(100%) hue-rotate(180deg);
  }
}
```

使用 `matchMedia` 方法检测 JS 中的首选配色方案：

```js
const checkType = (type) =>
  window.matchMedia &&
  window.matchMedia(`(prefers-color-scheme: ${type})`).matches

const mode = {
  is: {
    dark: checkType('dark'),
    light: checkType('light')
  }
}

mode.is.dark // true
mode.is.light // false
```

如果用户在页面打开时更改首选项配色，我们可以使用 `addListener` 方法监听系统颜色的切换，来动态更改颜色。

```js
window.matchMedia('(prefers-color-scheme: dark)').addListener((e) => {
  const isDarkMode = e.matches
  console.log(`${isDarkMode ? '🌚' : '🌞'}.`)
})
```

强制设置暗模式：

```js
const forceDarkMode = () =>
  [...document.styleSheets[0].rules].forEach((rule) => {
    const mediaText = (rule.media && rule.media.mediaText) || []
    const hasColorScheme = mediaText.includes('prefers-color-scheme')
    const hasLightScheme = hasColorScheme && mediaText.includes('light')

    // 如果需要，请删除亮模式。
    if (hasLightScheme) {
      rule.media.deleteMedium('(prefers-color-scheme: light)')
    }

    // 添加暗模式
    rule.media && rule.media.appendMedium('(prefers-color-scheme: dark)')
  })
```





