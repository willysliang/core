---
Author: willysliang
CreateTime: 2022-08-21 16:07
Modifier: willysliang
ModifiedTime: 2023-01-13 14:17:23
Description: 计算机网络
---

## 计算机网络

## 网络分层

目前存在的两种网络分层模型：**OSI模型**和**TCP/IP模型**。

![image-20220818194218705](./images/image-20220818194218705.png)

### TCP/IP模型

```bash
## TCP/IP 模型
TCP/IP 模型分为四层：
   * 应用层（Application）
   * 传输层（Host-to-Host Transport）
   * 互联网层(Internet)
   * 网络接口层(Network Interface)

发送放应用程序的数据总是从最上层开始，层层向下，最终经由物理层发送出去；
相应的，在接收方的物理层接收到数据后，层层向上，最终经由应用层分发到具体的应用程序进程中。
在数据层层向下的过程中，每一层都会对数据进行一些封装处理（如打包或编码）；
而在数据层层向上的过程中，每一层都会对数据进行一些逆处理（如解包或解码）。
这些对数据的处理和逆处理的过程就是为了实现该层的服务。

```



### OSI 网络模型

OSI（开放系统互联-Open Systems Interconncection）是网络通信的一种通用框架，它分为七层，并且定义了在每一层上数据的处理方法。

| 层数 |         层名          | 常见知识点                                                   |        设备        |
| :--- | :-------------------: | :----------------------------------------------------------- | :----------------: |
| 7    |  应用层(Application)  | HTTP、SMTP、SNMP、FTP、Telnet、SIP、SSH、NFS、RTSP、XMPP、Whois、ENRP |                    |
| 6    | 表示层(Presentation)  | XDR、ASN.1、SMB、AFP、NCP                                    |                    |
| 5    |    会话层(Session)    | ASAP、TLS、SSH、ISO 8327 / CCITT X.225、RPC、NetBIOS、ASP、Winsock、BSD sockets |                    |
| 4    |   传输层(Transport)   | TCP、UDP、RTP、SCTP、SPX、ATP、IL                            |                    |
| 3    |    网络层(Network)    | IP、ICMP、IGMP、IPX、BGP、OSPF、RIP、IGRP、EIGRP、ARP、RARP、 X.25 |       路由器       |
| 2    | 数据链路层(Data Link) | 以太网、令牌环、HDLC、帧中继、ISDN、ATM、IEEE 802.11、FDDI、PPP |       交换机       |
| 1    |   物理层(Physical)    | 线路、无线电、光纤、信鸽                                     | 网卡、集线器 (Hub) |

```bash
# 应用层
是最靠近应用程序的OSI层。由用户使用相应的接口实现自己的服务。
协议有：HTTP FTP SMTP等


# 表示层
数据的表示、安全、压缩。可确保一个系统的应用层所发送的信息被另一个系统的应用层读取。格式有: JPEG、ASCII、加密格式等。
在表示层，数据按照网络能理解的方案进行格式化。管理数据的加密与解密。


# 会话层
建立、管理、终止会话，对应主机进程，指本地主机与远程主机正在进行的会话。负责在网络的两节点之间建立、维持和终止通信。
会话层的功能包括：建立通信链接，保持会话过程通信连接的畅通，同步两个节点之间的对话，决定通信是否被终端以及通信中断时从何处重新发送。
当通过拨号向你的ISP（因特网服务提供商）请求连接到因特网时，ISP服务器上的会话层向你与你的PC客户机上的会话层进行协商连接。若你的电话线偶然脱落时，会话层将会检测到连接中断并重新发起连接。会话层通过决定节点通信的优先级和通信时间的长短来设置通信期限。



# 传输层
定义传输数据的协议端口号，以及流控和差错校验。

协议有：TCP UDP等，数据包一旦离开网卡即进入网络传输层。定义了一些传输数据的协议和端口号，如：TCP（传输控制协议，传输效率低，可靠性强，用于传输可靠性要求高，数据量大的数据），UDP（用户数据报协议，用于传输可靠性要求不高，数据量小的数据）。主要是讲从下层接收的数据进行分段和传输，到达目的地后再进行重组。常常把这一层数据叫做段。

OSI模型中最终要的一层。传输协议同时进行浏览控制或是基于接收方可接收数据的快慢程度规定适当的发送速率。除此之外，传输层按照网络能处理的最大尺寸将较长的数据包进行强制分割。例如，以太网无法接收大于1500字节的数据包。发送方节点的传输层将数据分割成较小的数据片，同时对每一数据片安排一个序列号，以便数据到达接收方节点的传输层时，能以正确的顺序重组。该过程称作排序。


# 网络层
进行逻辑地址寻址，实现不同网络之间的路径选择等。协议有：ICMP IGMP IP ARP RARP等。
在位于不同地理位置的网络中的两个主机系统之间提供连接和路径选择。Internet的发展使得从世界各站点访问信息的用户量大大增加，网络层正式管理这种连接的层。

OSI模型的第三层，其主要功能是将网络地址翻译成对应的物理地址，并决定如何将数据从发送方路由到接收方。

网络层通过综合考虑发送优先权、网络拥塞程度、服务质量以及可选路由的花费来决定从一个网络中节点A到另一个网络节点B的最佳路径。由于网络层处理，并智能指导数据传送，路由器连接网络各段，所以路由器属于网络层。在网络中，”路由“是基于编址方案、使用模式以及可达性来指导数据的发送。

网络层用于本地LAN网段之上的计算机系统建立通信，它之所以可以这样做，是因为它有自已的路由地址结构，这种结构与第二层机器地址是分开的、独立的。这种协议称为路由或可路由协议。路由协议包括IP、Novell公司的IPX以及AppleTalk协议。



# 数据链路层
建立逻辑连接、进行硬件地址寻址、差错校验等功能。将比特组合成字节进而组合成帧，用MAC地址访问介质，错误发现但不能纠正。

主要功能是如何在不可靠的物理线路上进行数据的可靠传递。为了保证传输，从网络层接收的数据被分割成特定的可被物理层传输的帧。帧是用来移动数据的结构包，它不仅包括原始数据，还包括发送方和接收方的物理地址以及检错和控制信息。其中的地址确定了帧将发往何处，而纠错和控制信息则确保帧无差错到达。如果在传送数据时，接收点检测到所传数据中有差错，就要通知发送方重发这一帧。

数据链路层在物理层提供比特流服务的基础上，建立相邻节点之间的数据链路，通过差错控制提供数据帧在信道上无差错的传输，并进行各电路上的动作系列。作用主要是物理地址寻址、数据的成帧、流量控制、数据的检错、重发等。



# 物理层
建立、维护、断开物理连接。
主要定义物理设备标准，如网线的接口类型，光纤的接口类型，各种传输介质的传输速率等。主要作用是传输比特流（就是有1、0转化为电力强弱来进行传输，到达目的地后在转化为1、0）
```



### TCP与UDP

```bash
## TCP 与 UDP
- TCP：面向连接、基于字节流、数据传输可靠（会判断是否丢包）、拥塞控制。适用于文件传输（因为数据传输可靠）
- UDP：无连接（不需要三次握手）、基于报文、单播/多播的功能、容易丢包从而导致数据不可靠性、不具备拥塞控制、传输效率高。适用于视频会议、电话、直播等（因为不需要建立连接、不会数据拥塞、保证内容的实时性）



### TCP 滑动窗口
在 TCP 链接中，对于发送端和接收端而言，TCP 需要把发送的数据放到发送缓存区, 将接收的数据放到接收缓存区。而经常会存在发送端发送过多，而接收端无法消化的情况，所以就需要流量控制，就是在通过接收缓存区的大小，控制发送端的发送。如果对方的接收缓存区满了，就不能再继续发送了。而这种流量控制的过程就需要在发送端维护一个发送窗口，在接收端维持一个接收窗口。 
TCP 滑动窗口分为两种: 发送窗口和接收窗口。
```



## 常见的网络端口及对应服务

|              服务               | 端口                                             |
| :-----------------------------: | ------------------------------------------------ |
|       FTP（文件传输协议）       | 20 用于数据传输，21 用于已建立的连接             |
|      SSH （安全外壳协议）       | 22                                               |
|       Telnet（远程登录）        | 23                                               |
|    SMTP（简单邮箱传输协议）     | 25                                               |
|           DNS（域名）           | 53                                               |
|              DHCP               | 67/UDP 用于 DHCP 服务器，68/UDP 用于 DHCP 客户端 |
|     HTTP（超文本传输协议）      | 80                                               |
|       POP3（邮箱协议 3 ）       | 110                                              |
|              HTTPS              | 443                                              |
| socks（防火墙安全会话转换协议） | 1080                                             |
|     MySQL（数据库默认端口）     | 3306                                             |



## HTTP网络请求协议

> #### http协议的特点
>
> - 简单快速：每个资源（比如图片、页面）都通过 url 来定位，想访问什么资源，直接输入url即可。
> - 灵活：http协议的头部有一个数据类型，通过http协议，就可以完成不同数据类型的传输。
> - **无连接**：连接一次，就会断开，不会继续保持连接。
> - **无状态**：客户端和服务器端是两种身份。第一次请求结束后就断开；第二次请求时，**服务器端并没有记住之前的状态**(记住状态的一般是session/cookies等)
> - **一次完整的HTPP请求**需要请求头、请求体、响应头、响应体
>
> #### http报文组成
>
> ![image-20210918094312634](./image/image-20210918094312634.png)

### 请求头

> 请求体：指提交给服务器的数据。如果是往服务器提交数据，需要在请求头中设置`Content-Type: application/x-www-form-urlencoded`(在ajax中需要手动设置)
>
> ![image-20210918094409349](./image/image-20210918094409349.png)
>
> ```bash
> User-Agent：浏览器的具体类型　　如：User-Agent：Mozilla/5.0 (Windows NT 6.1; rv:17.0) Gecko/20100101 Firefox/17.0
> 
> Accept：浏览器支持哪些数据类型　　如：Accept: text/html,application/xhtml+xml,application/xml;q=0.9;
> 
> Accept-Charset：浏览器采用的是哪种编码　　如：Accept-Charset: ISO-8859-1
> 
> Accept-Encoding：浏览器支持解码的数据压缩格式　　如：Accept-Encoding: gzip, deflate
> 
> Accept-Language：浏览器的语言环境　　如：Accept-Language zh-cn,zh;q=0.8,en-us;q=0.5,en;q=0.3
> 
> Host：请求的主机名，允许多个域名同处一个IP地址，即虚拟主机。Host:www.baidu.com
> 
> Connection：表示是否需要持久连接。
> 属性值可以是Keep-Alive/close，HTTP1.1默认是持久连接，它可以利用持久连接的优点，当页面包含多个元素时（例如Applet，图片），显著地减少下载所需要的时间。
> 要实现这一点，Servlet需要在应答中发送一个Content-Length头，最简单的实现方法是：先把内容写入ByteArrayOutputStream，然后在正式写出内容之前计算它的大小。如：Connection: Keep-Alive
> 
> Content-Length：表示请求消息正文的长度。对于POST请求来说Content-Length必须出现。
> 
> Content-Type：WEB服务器告诉浏览器自己响应的对象的类型和字符集。例如：Content-Type: text/html; charset='gb2312'
> 
> Content-Encoding：WEB服务器表明自己使用了什么压缩方法（gzip，deflate）压缩响应中的对象。
> 例如：Content-Encoding：gzip
> 
> Content-Language：WEB服务器告诉浏览器自己响应的对象的语言。
> 
> Cookie：最常用的请求头，浏览器每次都会将cookie发送到服务器上，允许服务器在客户端存储少量数据。
> 
> Referer：包含一个URL，用户从该URL代表的页面出发访问当前请求的页面。服务器能知道你是从哪个页面过来的。
> Referer: http://www.baidu.com/
> ```

### 响应报文

> 响应报文是服务器返回给客户端的，组成部分有响应行(设置响应状态)、响应头(设置Cookie、缓存等)、响应主体(响应返回的js或html页面)
>
> ![img](./images/20180228_1510-1720669279310.jpg)
>
> **常见的响应头**
>
> ```bash
> Cache-Control：响应输出到客户端后，服务端通过该报文头属告诉客户端如何控制响应内容的缓存。
> 如Cache-Control: max-age=3600 则是让客户端对响应内容缓存3600秒，也即在3600秒内如果客户再次访问该资源，则直接从客户端的缓存中返回内容给客户，不要再从服务端获取（这个功能是靠客户端实现的，服务端只是通过这个属性提示客户端从缓存中取，是否执行则还是决定于客户端，如果是自己宣称支持HTTP的客户端，则就应该这样实现）
> 
> ETag: "737060cd8c284d8af7ad3082f209582d"
> 一个代表响应服务端资源（如页面）版本的报文头属性，如果某个服务端资源发生变化了，这个ETag就会相应发生变化。它是Cache-Control的有益补充，可以让客户端“更智能”地处理什么时候要从服务端取资源，什么时候可以直接从缓存中返回响应。
> 
> Location: http://www.google.com.hk
> 我们在Asp.net中让页面Redirect到一个某个A页面中，其实是让客户端再发一个请求到A页面，这个需要Redirect到的A页面的URL，其实就是通过响应报文头的Location属性告知客户端的，如下的报文头属性，将使客户端redirect到iteye的首页中：
> 
> Set-Cookie: UserID=JohnDoe; Max-Age=3600; Version=1
> 服务端可以设置客户端的Cookie，其原理就是通过这个响应报文头属性实现的。
> ```

### MIME类型

```bash
## 设置资源类型（MIME类型）
媒体类型（通常称为 Multipurpose Internet Mail Extensions 或 **MIME** 类型）是一种标准，用来表示文档、文件或字节流的性质和格式。
HTTP 服务可以设置响应头 `Content-Type` 来表明响应体的 MIME 类型，浏览器会根据该类型决定如何处理资源。


### mime 的类型结构
mime 的类型结构：`type/subtype`，由类型与子类型两个字符串中间用 `/` 分隔而组成。不允许空格存在。
    - *type* 表示可以被分多个子类的独立类别。
    - *subtype* 表示细分后的每个类型。
注意：MIME 类型对大小写不敏感，但是传统写法都是小写。

```

#### 独立类型

```bash
## 独立类型
对于 text 文件类型若没有特定的 subtype，就使用 `text/plain`。
对于二进制文件没有特定或已知的 subtype，就使用 `application/octet-stream`，浏览器再遇到该类型的响应时，会对响应体内容进行独立存储，也就是我们常见的 '下载' 效果。

```

独立类型表明了对文件的分类，可以是如下之一：

| 类型          | 描述                                                         | 典型示例                                                     |
| :------------ | :----------------------------------------------------------- | :----------------------------------------------------------- |
| `text`        | 表明文件是普通文本，理论上是人类可读                         | `text/plain`, `text/html`, `text/css, text/javascript`       |
| `image`       | 表明是某种图像。不包括视频，但是动态图（比如动态 gif）也使用 image 类型 | `image/gif`, `image/png`, `image/jpeg`, `image/bmp`, `image/webp`, `image/x-icon`, `image/vnd.microsoft.icon` |
| `audio`       | 表明是某种音频文件                                           | `audio/*`,<br/>`audio/midi`, <br/>`audio/mpeg`, <br/>`audio/webm`,<br/>`audio/ogg`,<br/>`audio/wav`, |
| `video`       | 表明是某种视频文件                                           | `video/webm`, `video/ogg`                                    |
| `application` | 表明是某种二进制数据                                         | `application/*`,<br/>`application/json`,<br/>`application/javascript`,<br/>`application/ecmascript`,<br/>`application/octet-stream`,<br/>`application/octet-stream`,<br/>`application/pkcs12`, <br/>`application/vnd.mspowerpoint`, <br/>`application/xhtml+xml`, <br/>`application/xml`, <br/>`application/pdf` |

#### Multipart 类型

```bash
## Multipart 类型
**Multipart** 类型表示细分领域的文件类型的种类，经常对应不同的 MIME 类型。这是*复合*文件的一种表现方式。
`multipart/form-data` 可用于联系 HTML Forms 和 `POST`方法，
此外 `multipart/byteranges`使用状态码`206` `Partial Content`来发送整个文件的子集，而 HTTP 对不能处理的复合文件使用特殊的方式：将信息直接传送给浏览器（这时可能会建立一个“另存为”窗口，但是却不知道如何去显示内联文件）


### 例子
multipart/form-data
multipart/byteranges
```



## HTTP 协议版本

> ```bash
> ## http 协议版本
> http 协议是应用层协议，都是建立在传输层之上的。传输层上不只有 TCP 协议，还有 UDP 协议。
> http1.0 ~ http2.0 都是基于 TCP 协议的，因此都会有 TCP 带来的硬伤和局限性；
> 而 http3.0 则是建立在 UDP 基础之上的，所以其余 http2.0 之间有质的不同。
> ```

### `HTTP/1.0`

> ```bash
> ## HTTP/1.0
> 浏览器与服务器只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个 TCP 连接（TCP连接新建的成本很高，因为需要客户端和服务器三次握手），服务器完成请求处理后立即断开 TCP 连接，服务器不跟踪每个客户也不记录过去的请求。
> 
> ### http1.0 特点：
>   - 仅支持短暂保持短暂的 TCP 连接。
>   - 不追踪 IP。
>   - 可以使用 expires 进行强缓存
>   - 可以使用 last-modified 进行协商缓存
> ```

### `HTTP/1.1`

> ```bash
> ## HTTP/1.1
> 1. 管道化（Pipelining）
> 提出管道化方案解决连接延迟，服务端可设置 Keep-Alive 来让连接延迟关闭时间，但因为浏览器自身的 Max-Connection 最大连接限制，同一个域名下的请求连接限制（同域下谷歌浏览器是一次限制最多6个连接），只能通过多开域名来实现，这也是静态资源选择放到 CDN 上或其他域名下来提高资源加载速度。管道化方案需要前后端支持，但绝大部分 HTTP 代理器对管道化的支持并不友好。
> 
> 2. 管道化只支持 GET/HEAD
> 管道化只支持 GET/HEAD 方式传送数据，不支持 POST 等其它方式传输。
> 
> 3. 头部信息冗余
> HTTP 是误装填的，客户端/服务端只能通过 HEAD 的数据维护获取状态信息，这会造成每次连接请求时都会携带大量冗余的头部信息，头部信息包括 Cookie 信息等。
> 
> 4. 超文本协议
> HTTP/1.x 是超文本协议传输，在发送请求时会找出数据的开头和结尾帧的位置，并去除多余空格，选择最优方式传输。
> 如果使用 HTTPS，还会对数据进行加密处理，一定程度上会造成传输速度上的损耗。
> 
> 5. 队头阻塞
> 管道化通过延迟连接关闭的方案，虽然可同时发起对服务端的多个请求，但服务端的 response 依旧遵循 FIFO（先进先出）规则依次返回。在高并发延迟的场景下阻塞会更明显。
> 如客户端发送 1、2、3、4 四个请求，如果 1 没有返回给客户端，那么 2、3、4 也不会返回，这就是所谓的队头阻塞。
> 
> 
> ### http1.1 特点
> 1. 支持长连接（connection），支持文件断点续传
> 2. 纯文本报头
> 3. 增加了更多的请求头和响应头
> 4. 连接过多，会容易队首阻塞，串行传输
> 5. 可使用 etag、cache-control 进行 http缓存
> ```

### `HTTP/2.0`

> ```bash
> ## HTTP/2.0
> 1. 持久化连接 - 多路复用
> 采用多路复用，而非有序并阻塞，一个域只要一个 TCP 连接即可实现并发请求，降低延时，提高了带宽的利用率。
> HTTP的持久连接可以有效减少TCP建立连接和断开连接的次数，这样的好处是减少了服务器额外的负担，并提升整体HTTP的请求时间。
> 
> 2. 报头压缩
> 客户端/服务端进行渐进更新维护，才用 HPACK 压缩，节省了报文头占用流量，降低开销。
> 	- 相同的头部信息不会通过请求发送，沿用之前请求携带的头部信息。
> 	- 新增/修改的头部信息会被加入到 HEAD 中，两端渐进更新。
> 
> 
> 3. 请求优先级
> 每个流都有自己的优先级别，客户端可指定优先级，并可以做流量控制。
> 
> 
> 4. 服务端主动推送
> HTTP/2 让服务器可以响应主动 '推送' 资源到客户端缓存中。
> 例如我们加载 index.html，我们可能还需要 `index.js、index.css` 等文件。传统的请求只有当拿到 index.html，解析 html 中对 `index.js、index.css` 的引用才会再请求资源加载。
> 但是通过服务端数据，可以提前将资源推送给客户端缓存中，这样客户端需要使用时，直接调用缓存的资源即可，不用再发送请求。
> 
> 
> 5. 二进制协议
> 采用二进制协议，而不是像 `HTTP/1.X` 采用超文本协议的文本格式。客户(服务)端发送(接收)数据时，会将数据打散乱序发送，接收数据时，接收端再通过 `streamID` 标识来将数据合并。
> 二进制协议解析起来更高效，'线上'更紧凑，更重要的是错误更少。
> 
> 5.1 二进制分帧层
> 在二进制分帧层上，HTTP2.0会将所有传输的信息分割为更小的消息和帧，并对它们采用二进制格式的编码压缩，其中 HTTP1.x 的头部信息会被封装到 Headers 帧，而我们的 request body 则封装到 Data 帧里面。
>     - 维护一份相同的静态字典，包含常见的头部名称，以及常见的头部名称和值的组合。
>     - 维护一份相同的动态字典，可以动态的添加内容。
>     - 通过静态Huffman编码对传输的首部字段进行编码。
> 
> 
> ### 注意
> HTTP2 相对于 HTTP1.1 并不全是优点：因为 HTTP2 将多个HTTP 流放在同一个 TCP 连接中，遵循同一个流量状态控制。只要第一个 HTTP 流遇到阻塞，则后面的 HTTP 流就没办法发出去，这就是'行头阻塞'。
> 
> 
> ### http2.0 特点
> 1. 多路复用，并行请求
> 2. 二进制报头，分帧层（headers帧层和data帧层）
> 3. 对报头使用二进制格式编码化压缩，降低开销
> 4. 服务器主动推送，减少请求延时
> 5. 默认使用加密，增加伪头字段
> ```
>
> #### 多路复用
>
> ![image-20220818194817607](./image/image-20220818194817607.png)
>
> #### 二进制分帧层
>
> ![image-20220818194753613](./image/image-20220818194753613.png)

### `HTTP/3.0`

> ```bash
> ## HTTP/3.0
> HTTP/3.0 采用 `QUIC` 协议，基于 UDP 协议，避免了 TCP 协议的一些缺点，采用 TLS1.3 将 HTTPS 所需的 RTT 降至最少为 0。
> 
> 
> ### HTTP/3.0 在结合 HTTPS 下跟 HTTP/2.0 的对比
> - HTTP/2.0下：
> 		'HTTPS通信时间总和 = TCP连接时间 + TLS连接时间 + HTTP交互时间 = 1.5RTT + 1.5RTT + 1RTT = 4RTT'
> - HTTP/3.0下：
> 		- 首次链接时，QUIC 采用 TLS1.3，需要 1RTT，一次 HTTP 数据请求，共 2RTT。
> 		- 重连时直接使用 Session ID，不需要再次进行 TLS 验证，所以只需要 1RTT。
> 
> 
> ### TCP 协议的不足
> 1. TCP 可能会间歇性地挂起数据传输
> 如果一个序列号比较低的数据段还没有接收到，即使其他序列号较高的段已经接收到，TCP 的接收机滑动窗口也不会继续处理。这将导致 TCP 流瞬间挂起，在更糟糕的情况下，即使所有的段中有一个没有收到，也会导致关闭连接。这个问题被称为 TCP 流的行头阻塞（HoL）。
> 
> 2. TCP 不支持流级复用
> 虽然 TCP 确实允许在应用层之间建立多个逻辑连接，但它不允许在一个 TCP 流中复用数据包。使用 `HTTP/2.0` 时，浏览器只能与服务器打开一个 TCP 连接，并使用同一个连接来请求多个对象，如 `CSS、JavaScript` 等文件，在接收这些对象的同时，TCP 会将所有对象序列化在同一个流中。因此它不知道 TCP 段的对象级分区。
> 
> 3. TCP 会产生冗余通信
> TCP 连接握手会有冗余的消息交换序列，即使是与已知主机建立的连接也是如此。
> 
> 
> ### QUIC 协议的优势
> 1. 选择 UDP 作为底层传输层协议
> 在 TCP 之上建立新的传输机制，将继承 TCP 的上述所有缺点。因此 UDP 是一个明智的选择。此外，QUIC 是在用户层构建的，所以不需要每次协议升级时进行内核修改。
> 
> 2. 流复用和流控制
> QUIC 引入了连接上的多路流复用概念。QUIC 通过设计实现单独的、针对每个流的流控制，解决了整个连接的行头阻塞问题。
> 
> 3. 灵活的拥塞控制机制
> TCP 的拥塞控制是刚性的。该协议每次检测到拥塞时，都会将拥塞窗口大小减少一半。
> 相比之下，QUIC 的拥塞控制设计得更加灵活，可以更有效地利用可用的网络带宽，从而获得更好的吞吐量。
> 
> 4. 更好的错误处理能力
> QUIC 使用增强的丢失恢复机制和转发纠错功能，以更好地处理错误数据包，该功能对于那些只能通过缓慢的无线网络访问互联网的用户来说是福音，因为这些网络用户在传输过程中经常出现高错误率。
> 
> 5. 更快的握手
> QUIC 使用相同的 TLS 模块进行安全连接。但与 TCP 不同的是，QUIC 的握手机制经过优化，避免了每次两个已知对等者之间的建立通信时的冗余协议交换。
> 
> 
> ### http3.0 特点
> 1. 连接迁移
> 2. 无队头阻塞
> 3. 自定义的拥塞控制
> 4. 前向安全和前向纠错
> ```
>
> **TCP与QUIC的对比**
>
> ![image-20230113134619773](./image/image-20230113134619773.png)
>
> **TCP间歇性挂起数据传输示例图**
>
> ![image-20230113132620254](./image/image-20230113132620254.png)
>
> **TCP产生冗余通信示意图**
>
> ![TCP产生冗余通信示例图](./image/TCP_generates_redundant_communication_example_diagram.webp)

### `https`

> ```bash
> ## https
> 1. http: 是一个客户端和服务端请求和应答的标准（TCP），用于从 WWW 服务器传输超文本到本地浏览器的超文本传输协议。
> 2. https：是以安全为目标的 HTTP 通道，即 HTTP 下加入 SSL 层进行加密。其作用是建立一个信息安全通道，以来确保数据的传输，确保网站的真实性。
> 
> 
> ### https 协议的工作原理 
> 客户端在使用 https 方式与 web 服务器通信时有以下几个步骤：
>     1. 客户使用 https url 访问服务器，则要求 web 服务器建立 ssl 链接。
>     2. web 服务器接收到客户端的请求之后，会将网站的证书(证书中包含了公钥)，返回(传输)给客户端。
>     3. 客户端和 web 服务器端开始协商 ssl 链接的安全等级，也就是加密等级。
>     4. 客户端浏览器通过双方协商一致的安全等级，建立会话密钥，然后通过网站的公钥来加密会话密钥，并传输给网站。
>     5. web 服务器通过自己的私钥解密出会话密钥。
>     6. 服务器通过会话密钥加密与客户端之间的通信。
> 
> 
> ### http 和 https 的区别及优缺点
> 1. http 是超文本传输协议，信息是明文传输，https 协议要比 http 协议安全，https 是具有安全性的 ssl 加密传输协议，可防止数据传输过程中不被窃取、改变，确保了数据的完整性。
> 2. http 协议的默认端口为 80，https 的默认端口为 443。
> 3. http 的连接是无状态的。https 握手阶段比较耗时，会使页面加载时间延长 50%，增加 10%~20% 的耗电。
> 4. https 缓存不如 http 高效，会增加数据开销。
> 5. https 协议需要 ca 证书，费用较高，功能越强大的证书费用越高。
> 6. ssl 证书需要绑定 IP，不能在同一个 IP 上绑定多个域名，IPV4 资源支持不了这种消耗。
> 7. https 是现行架构下最安全的解决方案，虽然不是绝对安全，但是它大幅增加了中间人攻击的成本。
> 
> 
> ### Https
> 1. 本质的区别是：Https是密文传输数据，Http是明文传输数据。
> 2. Https在 Http 的基础上解决了以下 3 个问题：
> 		- HTTP通信使用明文(不加密)，内容可能会被窃听。
> 		- HTTP不验证通信方的身份，因此有可能遭遇伪装。
> 		- HTTP无法证明报文的完整性，所以有可能已遭篡改。
> ```

### `HTTP2 + HTTPS`的反优化策略

> ```bash
> ## `HTTP2 + HTTPS` 下产生的反优化策略
> 1. 减少请求数
> HTTP/1.1 因为存在'队头阻塞'，所以通常采用合并资源、捆绑文件(雪碧图等)等方式来减少请求数。
> 但在 HTTP/2.0 中我们更需要注重网站的缓存调优，传输轻量、细粒度的资源，方便独立缓存和并行传输。
> 
> 2. 多域名存储
> HTTP/1.1 因为浏览器有最大连接数限制，所以我们会将资源分发到不同的域名下存放以此来增大最大连接数。
> 但在 HTTP/2.0 中一个域只有一个连接，所以我们不需要去分多个域名存储，多域名存储甚至会造成额外的 TLS 消耗。
> ```

### 为什么 https 是安全的？

> ```bash
> ## 为什么 Https 是安全的？
> 1. Https 出现的原因
> 在 Https 出现之前，所有的请求都是以明文方式发送的，如果有人在传输中偷听或抓包的话，则你的所有通信内容都会泄露。
> 比较安全的方式是将通信内容加密后再发送给对方。加密方法有两种：对称加密和非对称加密。
> 
> 
> 2. 对称加密
> 对称加密指的是加密和解密用同一个密钥。
> 但是在通信之前，客户端和服务端不会有这样同一把密钥的。需要其中一方将密钥发送给对方。
> 在整个传输过程中没有任何验证操作，所以黑客也可以截取到这把密钥从而破译出加密的内容。
> 所以纯对称加密是不安全的。
> 
> 
> 3. 非对称加密
> 非对称加密是指加密和解密用不同的密钥。可以使用私钥加密，公钥解密；也可以公钥加密，私钥解密。
> 但是会有这种情况。服务端拥有私钥和公钥，将公钥发送给客户端。既然客户端可以拥有公钥，黑客也可以拥有公钥，那么服务端发送给客户端的所有内容黑客也可以解读的。
> 客户端用公钥加密发送给服务端不受影响，因为黑客没有服务器的私钥，所以纯非对称加密是不安全的。
> 
> 
> 4. Https 传输密钥的过程
> Https 采用对称加密来加密通信内容，所用的密钥称为 A。
> 用非对称加密来加密密钥 A 再发送给对方。
> 
> 
> 5. 为什么 Https 是可靠的？
> Https 是可靠的，因为它解决了三个问题：
> 	1. 加密通信，即使别人获取到信息也无法复原成原来的信息。
> 	2. 防止中间人攻击。黑客没法冒充服务端。因为在 2 步，服务端给客户端一个 CA 证书。
> 			- 如果客户端验证了这个证书，说明这个证书和公钥是由服务端发来的且真实可靠的。
> 			- 如果客户端验证不了这个证书，就说明这个证书不可靠，有可能是假的。
> 	3. CA 证书的公信力。CA 证书需要由公司或个人发出申请，再通过邮箱验证等方法验证域名存在。避免了黑客冒充网站获取证书的可能。
> 在技术层面上，CA 机构的公钥是写在操作系统或者浏览器里的。只有CA机构的私钥加密的内容才能完成解密。确保了证书的确是CA机构发行的。
> ```
>
> ![image-20230328152834836](./image/image-20230328152834836.png)
>
> ![image-20230328151112478](./image/image-20230328151112478.png)



## 浏览器加载网页会经历的过程

```bash
1. DNS 解析
2. 建立 TCP 连接
3. 发起网络请求（通常是发起 HTTP 请求从服务端获取页面所需资源，如 HTML、CSS、JS、图片资源等）
4. 服务端处理并响应请求
5. 浏览器接收响应数据后，解析 HTML 和渲染页面
6. 在解析过程中遇到加载 JS 代码会暂停页面的渲染（包括解析到外部的资源，会发起 HTTP 请求获取并加载）
7. 页面加载完毕
当所有资源都加载完成并且页面渲染完毕后，浏览器会触发 DOMContentLoaded 事件，表示页面已经加载完成。此时用户可以开始与页面进行交互。如果页面中包含了外部资源（如图片、视频等），则会继续加载这些资源，直到所有资源都加载完成。
在浏览器首次加载和渲染完成之后，可能用户没法立即触发页面交互和操作。而是会根据业务代码加载过程，页面还会分别进入页面开始渲染、渲染完成、用户可交互等阶段。除此之外，页面交互过程中，还会根据业务逻辑进行逻辑运算、页面更新等情况。
```

#### 浏览器加载页面的大致过程

```bash
1. DNS 解析：浏览器首先会解析输入的网址，将域名解析成对应的 IP 地址。如果域名已经被解析过并且存在于本地缓存中，浏览器会直接使用缓存的 IP 地址，否则会向 DNS 服务器发送请求以获取 IP 地址。

2. 建立 TCP 连接：浏览器通过 DNS 解析得到的 IP 地址向服务器发起 TCP 连接请求。TCP 连接的建立过程包括三次握手，确保服务器和浏览器之间建立可靠的连接。

3. 发送 HTTP 请求：浏览器向服务器发送 HTTP 请求，请求网页的内容。请求的内容包括 HTML 文件、CSS 文件、JavaScript 文件、图片、视频等资源。

4. 服务器响应请求：
	- 服务器接收到浏览器发送的 HTTP 请求后，根据请求的内容进行处理。处理的过程可能涉及到数据库查询、动态页面生成等操作。
	- 服务器将处理结果封装成 HTTP 响应，并发送给浏览器。响应的内容包括状态码、响应头信息以及请求的实际内容。 

5. 接收响应数据：浏览器接收到服务器返回的 HTTP 响应后，开始接收响应的数据。如果响应的内容是 HTML 文件，则浏览器会逐步解析 HTML 文件并开始渲染页面。
	- 浏览器解析 HTML 文件，构建 DOM 树（文档对象模型）。DOM 树表示网页的结构，包括 HTML 元素、属性等信息。
	- 浏览器解析 CSS 文件，构建 CSSOM 树（样式对象模型）。CSSOM 树表示网页的样式信息，包括元素的样式属性、选择器等。
	- 浏览器将 DOM 树和 CSSOM 树合并，构建渲染树（Render Tree）。渲染树包含需要显示的节点和这些节点的样式信息，不包含不需要显示的节点。

6. 布局和绘制：浏览器根据渲染树计算每个节点在页面中的位置和大小，这个过程称为布局或回流（Layout or Reflow）。然后浏览器使用计算好的布局信息将页面内容绘制到屏幕上。

7. JavaScript 解析和执行：如果 HTML 文件中包含了 JavaScript 代码，则浏览器会解析并执行 JavaScript 代码。JavaScript 的执行过程中可能会修改 DOM 树和 CSSOM 树，从而触发重绘和重排。

8. 加载完成：当所有资源都加载完成并且页面渲染完毕后，浏览器会触发 DOMContentLoaded 事件，表示页面已经加载完成。此时用户可以开始与页面进行交互。如果页面中包含了外部资源（如图片、视频等），则会继续加载这些资源，直到所有资源都加载完成。
```

#### TCP在什么时候会断开连接

```bash
#### 现代浏览器在与服务器建立了一个 TCP 连接后是否会在一个 HTTP 请求完成后断开？什么情况下会断开？
在 HTTP/1.0 中，一个服务器在发送完一个 HTTP 响应后，会断开 TCP 链接。但是这样每次请求都会重新建立和断开 TCP 连接，代价过大。所以虽然标准中没有设定，某些服务器对 `Connection: keep-alive` 的 Header 进行了支持。即是完成这个 HTTP 请求之后，不要断开 HTTP 请求使用的 TCP 连接。这样的好处是连接可以被重新使用，之后发送 HTTP 请求的时候不需要重新建立 TCP 连接，以及如果维持连接，那么 SSL 的开销也可以避免。

持久连接：既然维持 TCP 连接好处这么多，HTTP/1.1 就把 Connection 头写进标准，并且默认开启持久连接，除非请求中写明 Connection: close，那么浏览器和服务器之间是会维持一段时间的 TCP 连接，不会一个请求结束就断掉。

所以，默认情况下建立 TCP 连接不会断开，只有在请求报头中声明 `Connection: close` 才会在请求完成后关闭连接。
```



### 从输入URL到页面展示的过程

> 1. 首先在浏览器中输入URL
> 2. **DNS查询（查找缓存）**
>    1. 浏览器首先搜索浏览器自身缓存的DNS记录（浏览器会记录DNS一段时间，因此是第一个地方解析DNS请求）
>    2. 如果浏览器缓存中没有找到需要的记录或记录已过期，则搜索hosts文件和操作系统缓存
>    3. 如果在hosts文件和操作系统缓存中没有需要的记录或记录已过期，则向域名解析服务器发送解析请求
>    4. 如果域名解析服务器也没有该域名的记录，则开始递归+迭代解析
>    5. 获取域名对应的IP后，一步步向上返回，直到返回给浏览器
> 3. **发起TCP三次握手建立TCP连接**
>    1. 解析出IP地址后，根据IP地址和默认80端口，和服务器建立TCP连接
>    2. 第一次握手：建立连接时，客户端向服务端发送请求报文
>    3. 第二次握手：服务器收到报文后，如果同意连接，则向客户端发送确认报文
>    4. 第三次握手：客户端收到服务器的确认后，再次向服务器给出确认报文，完成连接
> 4. **浏览器向web服务器发起http请求**
>    - 浏览器发起读取文件的HTTP请求，，该请求报文作为TCP三次握手的第三次数据发送给服务器
>    - 请求行：指定http请求的方法、url、http协议版本等
>    - 请求头：描述浏览器的相关信息，如语言、编码等
>    - 请求正文：当发送POST、PUT请求时，通常需要向服务器传递数据，这些数据就储存在请求正文中
> 5. **服务器处理HTTP请求，并返回响应报文**(状态码、响应头、响应正文)
>    - 服务器响应请求并返回结果：服务器对浏览器请求做出响应，并把对应的html文件发送给浏览器
>    - 响应头：包含了响应的相关信息，如日期等
>    - 响应正文：服务器返回给浏览器的文本信息，通常html、js、css和图片等就包含在里面
> 6. **浏览器解析HTML内容，进行页面渲染**
>    - 客户端（浏览器）接受到http服务器发送过来的响应报文，并开始解析html文档并渲染页面。
>    - 浏览器接收到数据包后的解析流程为：构建DOM树、构建CSS规则树、构建render树、进行页面布局、遍历render树绘制页面元素
>      - 构建DOM树：词法分析然后解析成DOM树（dom tree），是由dom元素及属性节点组成，树的根是document对象
>      - 构建CSS规则树：生成CSS规则树（CSS Rule Tree）
>      - 构建render树：Web浏览器将DOM和CSSOM结合，并构建出渲染树（render tree）
>      - 布局（Layout）：计算出每个节点在屏幕中的位置
>      - 绘制（Painting）：即遍历render树，并使用UI后端层绘制每个节点。
> 7. **发起TCP四次挥手关闭TCP连接**
>    1. 客户端发送数据并关闭数据传送通道
>    2. 服务端接发回确认收到数据
>    3. 服务端发送完数据并关闭数据传送通道
>    4. 客户端发回确认收到数据
>
> #### 重绘和回流(重排)  
>
> 1. `重排/回流（Reflow）`：当`DOM`的变化影响了元素的几何信息，浏览器需要重新计算元素的几何属性，将其安放在界面中的正确位置，这个过程叫做重排。表现为重新生成布局，重新排列元素。如浏览器页面初始化、添加/删除可见的DOM元素、元素位置、尺寸、内容改变、窗口尺寸改变
> 2. `重绘(Repaint)`: 当一个元素的外观发生改变，但没有改变布局,重新把元素外观绘制出来的过程叫重绘。表现为某些元素的外观被改变；如不影响页面布局的操作：css改动、改变某个元素的背景色、文字颜色、边框颜色
> 3. **注意：『重排』必将引起『重绘』，『重绘』不一定会引起『重排』**
>
> 单单改变元素的外观，肯定不会引起网页重新生成布局，但当浏览器完成重排之后，将会重新绘制受到此次重排影响的部分
>
> 重排和重绘代价是高昂的，它们会破坏用户体验，并且让UI展示非常迟缓，而相比之下重排的性能影响更大，在两者无法避免的情况下，一般我们宁可选择代价更小的重绘。
>
> #### 如何触发回流和重绘？
>
> 任何改变用来构建渲染树的信息都会导致一次回流或重绘：
>
> - 添加、删除、更新DOM节点
> - 通过display: none隐藏一个DOM节点-触发回流和重绘
> - 通过visibility: hidden隐藏一个DOM节点-只触发重绘，因为没有几何变化
> - 移动或者给页面中的DOM节点添加动画
> - 添加一个样式表，调整样式属性
> - 用户行为，例如调整窗口大小，改变字号，或者滚动。
>
> #### 如何避免回流和重绘？
>
> 不在布局信息改变时做 DOM 查询、提前定义class类定义要修改的dom属性。对于重排的元素使其脱离文档流再改变
>
> - `集中改变样式`，不要一条一条地修改 DOM 的样式。
>
> - 不要把 DOM 结点的属性值放在循环里当成循环里的变量。
>
> - 尽可能在 DOM 树的最末端改变 class。
>
> - 避免设置多层内联样式
>
> - 为动画的 HTML 元件使用 `fixed` 或 `absoult` 的 `position`，那么修改他们的 CSS 是不会 reflow 的。
>
> - 不使用 table 布局。因为可能很小的一个小改动会造成整个 table 的重新布局。
>
> - 尽量只修改`position：absolute`或`fixed`元素，对其他元素影响不大
>
> - 动画开始`GPU`加速，`translate`使用`3D`变化
>
> - 提升为合成层
>
>     将元素提升为合成层有以下优点：
>
>     - 合成层的位图，会交由 GPU 合成，比 CPU 处理要快
>     - 当需要 repaint 时，只需要 repaint 本身，不会影响到其他的层
>     - 对于 transform 和 opacity 效果，不会触发 layout 和 paint

### DNS

> - DNS(Domain Name System)域名系统，即根据服务器根据域名的层级来查找IP地址。
>
> - `主机名.次级域名.顶级域名.根域名`
>
> - 解析过程
>
>   - 从"根域名服务器"查到"顶级域名服务器"的NS记录和A记录（IP地址）
>
>   2. 从"顶级域名服务器"查到"次级域名服务器"的NS记录和A记录（IP地址）
>   3. 从"次级域名服务器"查出"主机名"的IP地址

### TCP和UDP的区别

> - TCP是面向连接，UDP是面向无连接的（即发送数据前不需要简历连接）
> - TCP提供可靠的服务；通过TCP连接传送的数据，无差错，不丢失，不重复，且按需到达；UDP尽最大努力交付，即不保证可靠交付；因TCP可靠、面向连接且不会丢失数据，因此不适合大数据量的交换。
> - TCP是面向字节流，UDP面向报文，并且网络出现拥塞不会使得发送速率降低（因此会出现丢包，所以常用于实时的应用，如IP电话和视屏会议等）
> - TCP只能1对1，UDP支持1对1和1对多
> - TCP的首部较大为20字节，而UDP只有8字节
> - TCP是面向连接的可靠传输，而UDP是不可靠的
> - **TCP是可靠传输的原因**：数据报校验, 失序数据重排序, 丢弃重复数据,应答机制,超时重发,流量控制等

### TCP三次握手

> - 客户端和服务端都需要各自收发，因此需要三次握手（C 发起请求连接S 确认，也发起连接C）
>
> ****
>
> - 第一次握手：客户端通知服务端想建立TCP连接，服务端接收到客户端的请求建立报文就表示第一次握手结束。
>   第二次握手：服务端通知客户端同意连接TCP连接，同时确认自己(服务端)也想跟客户端建立连接。
>   第三次握手：客户端通知服务端，自己接收到服务端发送的同步报文和确认报文，TCP连接建立完成。
>
> - 第一次握手：服务端只可以确认自己可以接受客户端发送的报文段
>   第二次握手：客户端可以确认服务端收到了自己发送的报文段，并且可以确认自己可以接受服务端发送的报文段。
>   第三次握手：服务端可以确认客户端收到了自己发送的报文段。
>
> ![image-20211224134943355](./image/image-20211224134943355-1718553798515.png)

### TCP四次挥手

> 由于TCP连接是全双工的，因此每个方向都必须单独进行关闭。这原则是当一方完成它的数据发送任务后就能发送一个FIN来终止这个方向的连接。收到一个 FIN则意味着这一方向上没有数据流动，一个TCP连接在收到一个FIN后仍能发送数据。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。
>
> - 第一次挥手：由浏览器 => 服务器，表示通知服务器请求报文发送完毕，可以关闭服务器到客户的数据传送
> - 第二次挥手：由服务器 => 浏览器，表示服务器确认请求报文已经接收完成，同意浏览器关闭请求
> - 第三次挥手：由服务器 => 浏览器，表示服务器的响应报文已经发送完毕，通知浏览器关闭连接
> - 第四次挥手：由浏览器 => 服务器，表示响应报文接收完毕，浏览器同意关闭连接
>
> ****
>
> 1. 客户端发送一个FIN，用来关闭客户到服务器的数据传送
> 2. 服务器收到这个FIN，它发回一个ACK，确认序号为收到的序号加1。和SYN一样，一个FIN将占用一个序号。
> 3. 服务器关闭客户端的连接，发送一个FIN给客户端。
> 4. 客户端发回ACK报文确认，并将确认序号设置为收到序号加1。
>
> ****
>
> 1. `客户端进程发出连接释放报文`，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，`客户端进入FIN-WAIT-1（终止等待1）状态`。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。
> 2. `服务器收到连接释放报文，发出确认报文`，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，`服务端就进入了CLOSE-WAIT（关闭等待）状态`。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。
> 3. 客户端收到服务器的确认请求后，此时，`客户端就进入FIN-WAIT-2（终止等待2）状态`，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。
> 4. `服务器将最后的数据发送完毕后，就向客户端发送连接释放报文`，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，`服务器就进入了LAST-ACK（最后确认）状态`，等待客户端的确认。
> 5. `客户端收到服务器的连接释放报文后，必须发出确认`，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，`客户端就进入了TIME-WAIT（时间等待）状态`。注意此时TCP连接还没有释放，必须经过2∗∗MSL（最长报文段寿命）的时间后，`当客户端撤销相应的TCB后，才进入CLOSED状态`。
> 6. 服务器只要收到了客户端发出的确认，`立即进入CLOSED状态`。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，`服务器结束TCP连接的时间要比客户端早一些`。
>
> ![image-20211025153149658](./image/image-20211025153149658-1718553798516.png)



```bash
1. 为什么开启TCP链接需要三次握手，而关闭TCP连接需要四次
当建立连接时服务端收到客户端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。
但是关闭连接时，当服务端收到FIN报文时，很可能并不会立即关闭连接，所以只能先回复一个ACK报文，告诉客户端，“你发的FIN报文我收到了”。只有等到我服务端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四次挥手。



2. 为什么客户端发送ACK之后不直接关闭，而是要等一阵子才关闭？
客户端收到服务端的连接释放报文段后，对此发出确认报文段（ACK=1，seq=u+1，ack=w+1），客户端进入TIME_WAIT（时间等待）状态。此时TCP未释放掉，需要经过时间等待计时器设置的时间2MSL（最大报文生存时间）后，客户端才进入CLOSED状态。
如果不等待，客户端直接跑路，当服务端还有很多数据包要给客户端发，且还在路上的时候，若客户端的端口此时刚好被新的应用占用，那么就接收到了无用数据包，造成数据包混乱。



3. 为什么TIME_WAIT状态需要经过2MSL（最大报文生存时间）才能返回到CLOSE状态？
理论上，四个报文都发送完毕，就可以直接进入CLOSE状态了，但是可能网络是不可靠的，有可能最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。Server如果没有收到ACK，将不断重复发送FIN片段。所以Client不能立即关闭，它必须确认Server接收到了该ACK。
Client会在发送出ACK之后进入到TIME_WAIT状态。Client会设置一个计时器，等待2MSL的时间。如果在该时间内再次收到FIN，那么Client会重发ACK并再次等待2MSL。
所谓的2MSL是两倍的 MSL(Maximum Segment Lifetime)。
MSL指一个片段在网络中最大的存活时间，2MSL就是一个发送和一个回复所需的最大时间。如果直到2MSL，Client都没有再次收到FIN，那么Client推断ACK已经被成功接收，则结束TCP连接。
2MSL,即：1 个 MSL 确保四次挥手中主动关闭方最后的 ACK 报文最终能达到对端； 1 个 MSL 确保如果对端没有收到 ACK 重传的FIN 报文可以到达。
```



### FTP协议

>- FTP允许用户以文件操作的方式(如文件的增、删、改、查、传送等)与另一主机相互通信。然而，用户并不真正登录到自己想要存取的计算机上面而成为完全用户，可用FTP程序访问远程资源，实现用户往返传输文件、目录管理以及访问电子邮件等，即是双方计算机可能配有不同的操作系统和文件存储方式。
>- FTP是应用层的一个文件传输协议，使用了两个并行的TCP来传输文件，一个是**控制连接(21端口)**，一个是**数据连接(20端口)** 
>  在介绍FTP的工作原理时候，通常会讲到两个信道(控制信道、数据信道)和两种模式(主动模式、被动模式)
>- **控制信道和数据信道**：
>- 控制信道是创建会话的必要条件,通常传输控制信息，如口令，用户标识，存放、获取文件等命令
>- 数据信道则是临时创立的，它通常被用来传输文件。当发送完文件之后数据连接会自动关闭
>- **主动模式(服务器主动发起请求)**：
>- 控制信道：客户端(端口随机) -----> 服务器21端口
>- 数据信道：客户端(端口随机) <----- 服务器20端口
>- 在主动模式下，客户端向服务器的FTP端口21发起连接请求，服务器接收连接后，创建一条命令链路。当需要传输数据时，客户端在链路上用PORT命令告诉服务器:"我打开了X端口，需要你连接我"。接着服务器从20端口向客户端的X端口发起连接请求，之后双方可以利用数据通道来传输数据
>- **被动模式(服务器被动响应请求):**
>- 控制信道：客户端(端口随机) -----> 服务器21端口
>- 数据信道：客户端(端口随机) <----- 服务器随机端口
>- 被动模式下控制信道的传输方式和主动一致，但是在需要数据传输的时候，服务器在控制信道上用PASV的命令告诉客户端，我开启了XX端口，你过来连接我，之后服务器被动等待客户端连接它的XX端口，创建连接后开始传输数据
>- 在创建连接的过程中，有很多FTP独有的命令。例如在被动模式下的控制信道，经过三次握手后，客户端会向服务器发送PASV命令，意为：你是否支持被动模式，服务器如果支持则会返回227:a,b,c,d,e,f。其中a,b,c,d为IP地址。端口为e*256+f，到了第二信道，双方的通信端口都是随机的，这样较为安全。
>- 当有防火墙的时候，需要转换IP端口，防火墙做了什么？



## 浏览器缓存

```bash
浏览器在本地磁盘对用户最近请求过的文档（文件）进行存储（缓存），以便在下一次访问时重复使用，即当访问者再次访问同一页面时，浏览器就可以直接从本地磁盘加载文档，从而节省带宽、提升访问速度、降低服务器压力。



#### 缓存种类
浏览器的缓存按位置分类一共有四种，按照优先级从高到低排列分别是：(由上到下寻找，找到即返回；找不到则继续)
    1. Service Worker：借鉴了 WebWorker，其主要功能是：离线缓存(Service Woker Cache)、消息推送和网络代理。
    2. Memory Cache：内存缓存。从效率上来讲，它是最快的；从存活时间来讲，它又是最短的。当渲染进程结束后，内存缓存就消失。
    3. Disk Cache：存储在磁盘中的缓存，从存取效率上讲是比内存缓存慢的，优势在于存储容量和存储时长。
    4. Push Cache：推送缓存，它是浏览器缓存的最后一道防线，它属于 HTTP/2.0 的内容。

浏览器在选择 Disk Cache 与 Memory Cache 的存储上：
	内容使用率高的，文件优先进入磁盘。
	比较大的 JS/CSS 文件直接放入磁盘，反之放入内存中。
	
按缓存方式分类有2种：
	1.强制缓存（强缓存）
	2.协商缓存 （对比缓存）



#### 添加缓存位置流程
1. 根据 Service Worker 中的 handler 决定是否存入 Cache Storage (额外的缓存位置)。
2. 根据 HTTP 头部的相关字段(Cache-control, Pragma 等)决定是否存入 disk cache
3. memory cache 保存一份资源 的引用，以备下次使用。
```



### Service Worker

```bash
### Service Worker
- 常见的浏览器的存储有 Cookie、LocalStorage、SessionStorage，浏览器的数据库 IndexedDB，直接用它们可以实现对缓存的部分控制，但是你没办法拦截网络的加载，比如页面都还没加载，你的代码都还没开始工作，导致无法拦截这个JS或图片使其不再加载。
- 而 ServiceWorker（简称sw），就是应运而生的一个高级缓存控制器，用于给 web 应用提供高级的可持续的后台处理能力。


sw是一种在浏览器后台运行的 JavaScript 脚本，介于服务器和网页之间的拦截器，它可以拦截和处理网页发出的网络请求，以及管理缓存和离线数据。
它由开发者编写的额外的脚本控制，且缓存位置独立。


Service Worker可以实现以下功能：
    - 离线缓存：Service Worker可以缓存网页资源，使得用户在离线状态下仍能正常访问已经缓存的资源。
    - 推送通知：Service Worker可以接收来自服务器的推送通知，并在用户离线时显示通知。
    - 资源拦截：Service Worker可以拦截网页发出的网络请求，并根据需要返回缓存中的资源或者从服务器请求最新的资源。
    - 跨域通信：Service Worker可以和其他域名的网页进行通信，从而实现一些跨域的功能。


- 一般来说，ServiceWorker 可以有效提升用户的 '弱网体验'，常用于移动端网页。
- 显著的缺陷是使用上简单，但是维护艰难，一般需要 框架 或 第三方库 来管理。

注意：如果只是做调试，ServiceWorker 开启后最好到 `Application` 里把它注销掉，否则可能会影响你的开发（如果你注册的端口号和网页刚好与现在所测试的端口一致）



#### Service Worker 的特点
- 在页面中注册并安装成功后，运行于浏览器后台，不受页面刷新的影响，可以监听和截拦作用域范围内所有页面的 HTTP 请求。
- 网站必须使用 HTTPS。除了使用本地开发环境调试时(如域名使用 localhost 忽略不受限)
		- ServiceWorker 是基于 `HTTPS` 的，因为 `Service Worker` 中涉及到请求拦截，所以它必须使用 `HTTPS` 协议来保证安全性。
- 运行于浏览器后台，可以控制打开的作用域范围下所有的页面请求
- ServiceWorker 是基于 `Web Worker` 的，可以访问 `cache` 和 `indexedDB`
- 单独的作用域范围，单独的运行环境和执行线程
- 不能操作页面 DOM。但可以通过事件机制来处理
- 事件驱动型服务线程



#### Service Worker 没有命中缓存
如果 Service Worker 没能命中缓存，一般情况会使用 fetch() 方法继续获取资源。这时浏览器就去 memory cache 或者 disk cache 进行下一次找缓存的工作了。经过 Service Worker 的 fetch() 方法获取的资源，即便它并没有命中 Service Worker 缓存，甚至实际走了网络请求，也会标注为 from ServiceWorker。


#### service worker 对比 浏览器http缓存
相比浏览器缓存：浏览器缓存依赖服务端配置，并且有具体的失效时间，并不是前端完全控制的缓存方案，另外不同的缓存还会有相应的大小限制。而service worker能解决精细化缓存控制。
```

#### 生命周期钩子函数

````bash
每个 Service Worker 都有一个独立于 Web 页面的生命周期，生命周期有5步：注册、安装成功（安装失败）、激活、运行、销毁。

主要的事件包括：install、activate、message、fetch、push、async。

由于是离线缓存，所以在首次注册、二次访问、服务脚本更新等会有不同的生命周期。
````

![img](./image/v2-0de87c5c369805807ad499d6cc35c7bf_r.jpg)

##### **1、注册**

在我们页面主线程执行注册，通过script标签嵌入到body标签最后，注册完成后会返回一个promise对象

register('/sw.js', { scope: '/' })的第一个参数文件地址是相对于当前origin的，而不是app的根目录

```html
<script>
   if ('serviceWorker' in navigator) {
     navigator.serviceWorker.register('/sw.js', { scope: '/a/b' }).then(function (registration) { // 指定cache storage只在origin下的/a/b路径下生效，类似cookie的domain
       //  navigator.serviceWorker.register('/a/b/sw.js')，与上面意思相同
       console.log('ServiceWorker registration successful with scope: ', registration.scope);
     }).catch(function (err) {
       console.log('ServiceWorker registration failed: ', err);
     });
   }
</script>
```

##### **2、安装**

触发install事件，install 事件一般是被用来填充你的浏览器的离线缓存能力，为了达成这个目的，使用 一个 service worker 上的全局对象 cache，它使我们可以存储网络响应发来的资源，并且根据它们的请求来生成key。这个 API 和浏览器的标准的缓存工作原理很相似，但是是特定你的域的。它会一直持久存在，直到你告诉它不再存储，你拥有全部的控制权。

```js
self.addEventListener('install', event => {
    /* event.waitUtil 用于在安装成功之前执行一些预装逻辑
     但是建议只做一些轻量级和非常重要资源的缓存，减少安装失败的概率
     安装成功后 ServiceWorker 状态会从 installing 变为 installed */
    event.waitUntil( // Service Worker 事件回调的参数是一个 ExtendableEvent 对象，在 Service Worker 中需要使用 ExtendableEvent.waitUntil() 方法来保证生命周期的执行顺序
        caches.open(PRECACHE) // 创建一个名为PRECACHE的新缓存
            .then(cache => cache.addAll(preCacheUrls)) // preCacheUrls是相对于origin的url的数组，这些url就是你想要缓存的资源列表
            .then(self.skipWaiting())
    );
});
```

##### **3、激活**

触发activate事件，处理相关事件内容，一般会在这个阶段做删除历史缓存操作

```js
self.addEventListener('activate', event => {
    const currentCaches = [PRECACHE, RUNTIME];
    event.waitUntil(
        caches.keys().then(cacheNames => {
            return cacheNames.filter(cacheName => !currentCaches.includes(cacheName));
        }).then(cachesToDelete => {
            return Promise.all(cachesToDelete.map(cacheToDelete => {
                return caches.delete(cacheToDelete);
            }));
        }).then(() => self.clients.claim()) // 为了保证 Service Worker 激活之后能够马上作用于所有的终端，通常在激活 Service Worker 后，通过在其中调用 self.clients.claim() 方法控制未受控制的客户端
    );
});
```

##### **4、运行**

fetch事件：每次任何被 service worker 控制的资源被请求到时，都会触发 fetch 事件，包括跨域请求

```js
self.addEventListener('fetch', event => {
    // Skip cross-origin requests, like those for Google Analytics.
    // 判断请求内容是否跨域
    if (event.request.url.startsWith(self.location.origin)) {
        event.respondWith(
            caches.match(event.request).then(cachedResponse => {
                // 缓存中有，直接返回
                if (cachedResponse) {
                    return cachedResponse;
                }
                // 缓存中没有，发网络请求，成功后缓存到名为runtime的缓存中
                return caches.open(RUNTIME).then(cache => {
                    return fetch(event.request).then(response => {
                        // Put a copy of the response in the runtime cache.
                        return cache.put(event.request, response.clone()).then(() => {
                            return response;
                        });
                    });
                });
            })
        );
    }
});
```

##### **5、push事件**

通过监听push事件，实现消息推送

```js
self.addEventListener('push', function (event) {
 // 检查服务端是否发来了任何有效载荷数据
  var payload = event.data ? JSON.parse(event.data.text()) : 'no payload';
  var title = 'Progressive Times';
  event.waitUntil(
    // 使用提供的信息来显示 Web 推送通知
    self.registration.showNotification(title, {                           
      body: payload.msg,
      url: payload.url,
      icon: payload.icon
    })
  );
});
```

##### **6、销毁**

当安装失败或者进程被关闭时

```js
if ('serviceWorker' in navigator) {
   navigator.serviceWorker.getRegistrations().then(function (regs) {
     for (var reg of regs) {
       if (reg.scope === 'http://localhost:3030/'){
         reg.unregister(); // 取消注册
       }
     }
   });
 }
```

##### **案例**

> #### 首页使用 service Worker API
>
> ```html
> <!-- serviceWorker 的demo 调用。 注意：需要在首页 index.html 中使用 -->
> <script>
>   if ('serviceWorker' in navigator) {
>       window.addEventListener('load', () => {
>          navigator.serviceWorker
>            .register('./serviceWorker.js', {
>            scope: './serviceWorkerLoad.html',
>          })
>            .then((registration) => {
>            console.log(
>              'ServiceWorker registration successful with scope: ',
>              registration.scope,
>            )
> 
>            // 当前 serviceWorker 的登记状态
>            const serviceWorker =
>                  registration.installing ||
>                  registration.waiting ||
>                  registration.active
>            if (serviceWorker) {
>              console.log('serviceWorker.state: ' + serviceWorker.state)
>              serviceWorker.addEventListener('statechange', (e) => {
>                console.log('serviceWorker state is ' + e.target.state)
>              })
>            }
>          })
>            .catch((err) => {
>            console.log('ServiceWorker registration failed: ', err)
>          })
>       })
>   } else {
>       console.log('该浏览器不支持 ServiceWorker API')
>   }
> </script>
> ```
>
> #### 在首页中加载的 service Worker.js 文件
>
> ```js
> /**
>  * 监听安装事件
>  * install 事件一般是被用来设置你的浏览器的离线缓存逻辑
>  */
> this.addEventListener('install', (event) => {
>   // 通过这个方法可以防止缓存未完成就关闭 serviceWorker
>   event.waitUnil(
>     // 创建一个名叫 v1 的缓存版本
>     caches.open('v1').then((cache) => {
>       // 指定要缓存的内容，地址为相对于跟域名的访问路径
>       return cache.addAll([
>         './vite.svg',
>         './serviceWorkerLoad.js',
>         './serviceWorkerLoad.html',
>         './serviceWorkerLoad.css',
>       ])
>     }),
>   )
> })
> 
> /**
>  * 注册 fetch 事件，拦截全站的请求
>  */
> this.addEventListener('fetch', (event) => {
>   event.respondWith(
>     caches.match(event.request).then((response) => {
>       return response || fetch(event.request)
>     }),
>   )
> })
> ```
>
> #### 第一次加载页面后控制台输出的结果
>
> ![image-20230113113405647](./image/image-20230113113405647.png)
>
> #### 在页面刷新一次后（不能ctrl+F5清空缓存刷新），在浏览器的`Application`里能看到`Service Workers`多了一条
>
> ![image-20230113113135295](./image/image-20230113113135295.png)
>
> #### 通过控制台的链接跳入所在页面，并刷新页面后网络里的 `Sizes` 多了个 `ServiceWorker` 的标志
>
> ![image-20230113113533446](./image/image-20230113113533446.png)
>
> #### 点开网络详情Timing 里也多了个 `ServiceWorker` 的标志
>
> ![image-20230113113706350](./image/image-20230113113706350.png)



#### 缓存策略

```bash
#### 常用缓存策略
- NetworkFirst：网络优先
- CacheFirst：缓存优先
- NetworkOnly：仅使用正常的网络请求
- CacheOnly：仅使用缓存中的资源
- StaleWhileRevalidate：从缓存中读取资源的同时发送网络请求更新本地缓存


#### 策略选择
1. 对于 HTML：如果想让页面离线可以访问，使用 NetworkFirst，如果不需要离线访问，使用 NetworkOnly，其他策略均不建议对 HTML 使用。
2. 对于 CSS 和 JS：
    - 针对跨域的的 CSS，JS 资源，SW 并没有办法判断从 CDN 上请求下来的资源是否正确（HTTP 200），如果缓存了失败的结果，问题就大了。因此针对跨域静态资源，建议使用 Stale-While-Revalidate 策略，先从缓存中读取，再更新本地缓存内容，既保证了页面速度，即便失败，用户刷新一下就更新了。对于不在同一域下的任何资源，绝对不能使用 Cache only 和 Cache first。
    - 如果你的 CSS，JS 与站点在同一个域下，并且文件名中带了 Hash 版本号（webpack打包后），那可以直接使用 Cache First 策略。通过预缓存即可。
3. 图片：可考虑使用 Cache First，并设置一定的失效时间，请求一次就不会再变动了。
```



#### 版本可控的 Service Worker

```bash
1. 注册作用域的问题
不要直接注册在根域名下，使用scope隔离，防止彼此之间造成影响
建议使用第一个参数路径的方式限制 scope，不要同时设置第二个参数 scope，避免因作用域范围大小冲突，而注册失败



2. 缓存内容范围和策略
考虑到html文件中包含大小前端打包的脚本，样式等静态资源链接，为避免页面无法及时更新，可不缓存html文件（可以考虑使用networkFirst策略），只考虑缓存静态资源（JS，CSS，图片，音乐，字体文件等）
针对项目中打包的静态资源（webpack打包后文件名中带了hash版本号），采用Cache First策略，通过预缓存设置即可



3. 注册更新问题
当页面注册好了一个 Service Worker 之后，Service Worker 会被安装、激活、然后通过 fetch 事件监听作用域下站点的网络请求等等行为，并且没有额外操作的情况下会一直存在，虽然Service worker本身Update算法可以在注册的时候diff到URL或者内容的更改，从而启动新的 sw.js 文件的安装、激活等流程，但前提是保证sw.js文件自身不会被缓存，另外，就算满足了不被缓存的前提，可以diff到变化，但是因为用户当前的页面已经使用老的缓存中的内容加载完成，所以用户仍然需要等到第二次进入页面的时候才能真正使用新的静态资源。

所以存在两个问题
	- 保障Service worker文件不被浏览器缓存
	- 保障页面实时更新，解决在用户刷新页面之前，仍然使用旧的缓存内容的问题

解决方案通常需要让文件完全无缓存：
	- 一种是在服务器端控制请求文件的 Cache-Control （服务端做无缓存控制）
	- 另一种就是在前端通过版本号来改变浏览器缓存策略。
	- 前端间接版本控制
```

**一种是在服务器端控制请求文件的 Cache-Control （服务端做无缓存控制）**

缺点：需要等到第二次进入页面才能刷新，且需要服务器配置，有局限性

```yml
location ~ \/sw\.js$ {
  add_header Cache-Control no-store;
  add_header Pragma no-cache;
}
```

**另一种就是在前端通过版本号来改变浏览器缓存策略**

直接使用buildTime做版本控制：可以解决被浏览器缓存的问题了，但是会出现更糟糕的情况，每次执行注册 Service Worker 代码逻辑的时候，Service Worker 都能 diff 到变化（URL 的变化也是一种更新的 diff），每次都会在第一次安装，第二次激活并且更新缓存，这种做法使得 Service Worker 的缓存完全没有生效，和每次都和请求最新的 Network 请求内容没什么区别，理论上讲，这种方式由于缓存的频繁读取和删除，甚至比每次直接无缓存刷新的性能更加糟糕。

```js
if (navigator.serviceWorker) {
  navigator.serviceWorker.register('/sw.js?v=' + Date.now());
}
```

**前端间接版本控制**

考虑如果不能对 sw.js 直接做版本控制，能不能对别的文件做无缓存的版本控制，然后在这个文件中再执行 Service Worker 的注册逻辑？也就是对注册逻辑做版本控制。文件命名为sw-register.js

每次页面load结束，请求一次sw-register.js文件，而sw.js文件的版本每上线一次更新一次，若无更新不会重新注册，另外还可通过事件unregister通知旧cache内容清除完成，页面重新reload

不仅解决版本控制问题，还可以同时解决内容实时更新生效，代价是增加了一次sw-register文件请求，由于该文件只负责注册，体积不大，仅仅1kb左右。

通过控制注册逻辑文件，可以更加灵活完美的解决版本控制问题。

```html
<script>
  // sw-register.js文件中定义unregister事件
  // 每次删除旧cache内容，主动通知浏览器reload
  window.addEventListener('sw.unregister', function(event) {
    location.reload();
  }, false);
  window.onload = function () {
    var script = document.createElement('script');
    var firstScript = document.getElementsByTagName('script')[0];
    script.type = 'text/javascript';
    script.async = true;
    // 每次load结束请求sw-register.js文件
    script.src = '/sw-register.js?v=' + Date.now();
    firstScript.parentNode.insertBefore(script, firstScript);
  };
</script>
```



### Memory Cache

```bash
内存中的缓存(与之相对 disk cache 就是硬盘上的缓存)。不受开发者控制，也不受 HTTP 协议头的约束，是一个黑盒。

几乎所有的网络请求资源都会被浏览器自动加入到 memory cache 中。但是也正因为数量很大但是浏览器占用的内存不能无限扩大这样两个因素，memory cache 只能是“短期存储”。通常浏览器窗口中的一个页签TAB 关闭后该次浏览的 memory cache 便失效 (为了给其他 TAB 腾出位置)。而如果极端情况下 (例如一个页面的缓存就占用了超级多的内存)，那可能在 TAB 没关闭之前，排在前面的缓存就已经失效了。

注意：在从 memory cache 获取缓存内容时，浏览器会忽视例如 `max-age=0, no-cache` 等头部配置。
例如页面上存在几个相同 src 的图片，即便它们可能被设置为不缓存，但依然会从 memory cache 中读取。这是因为 memory cache 只是短期使用，大部分情况生命周期只有一次浏览而已。而 max-age=0 在语义上普遍被解读为“不要在下次浏览时使用”，所以和 memory cache 并不冲突。

如果想让一个资源进入缓存，就连短期也不行，就使用 `no-store`。如果存在这个头部配置，即便是 memory cache 也不会存储，自然也不会从中读取了。



#### preloader
一种浏览器技术，用于在网页加载过程中预先加载一些资源（如图片、CSS文件、JavaScript文件等），以便在用户访问网页时可以更快地呈现页面内容。
Preloader 通常使用JavaScript代码来实现，它可以在网页加载时异步加载资源，而不会阻塞页面的渲染（一边解析执行 js/css，一边去请求下一个(或下一批)资源）。
被 preloader 请求够来的资源就会被放入 memory cache 中，供之后的解析执行操作使用。
```

### disk cache

```bash
disk cache 也叫 HTTP cache（它遵守 HTTP 协议头中的字段，平常说的强制缓存，对比缓存，以及 Cache-Control 等），是存储在硬盘上的缓存，因此它是持久存储的，是实际存在于文件系统中的。而且它允许相同的资源在跨会话，甚至跨站点的情况下使用，例如两个站点都使用了同一张图片。

disk cache 会严格根据 HTTP 头信息中的各类字段来判定哪些资源可以缓存，哪些资源不可以缓存；哪些资源是仍然可用的，哪些资源是过时需要重新请求的。当命中缓存之后，浏览器会从硬盘中读取资源，虽然比起从内存中读取慢了一些，但比起网络请求还是快了不少的。绝大部分的缓存都来自 disk cache。

disk cache同样也会面临空间不足的时候，当 disk cache 空间不足时，会根据 LRU（Least Recently Used - 最近最少使用）算法淘汰掉最近最少使用的缓存数据，腾出空间存储新的缓存数据。

LRU 算法的基本思想是，当缓存空间满时，将最近最少使用的缓存数据淘汰掉，腾出空间存储新的缓存数据。
具体实现方式是，每次访问缓存数据时，都将该数据移动到链表头部，这样链表尾部的数据就是最近最少使用的数据，可以直接淘汰掉。
```



### HTTP 缓存

```bash
## HTTP 缓存
- 描述：http 缓存是在第一次获取资源后，根据返回的HTTP 响应头信息来告诉如何缓存资源。
- 作用：HTTP缓存主要是为了防止用户重复请求相同资源而产生的解决方案。
- 类别：HTTP缓存分为强制缓存和协商缓存。

- 强缓存是直接从浏览器缓存中获取资源，返回的状态码是200（若是设置缓存有效时间，超出有效时间则会发送请求到服务器来获取资源）
- 协商缓存是由服务器来确定缓存资源是否可用，存在缓存时返回状态码为304且不带响应体的报文，新资源则返回状态码为200且响应体为请求数据的报文。


### 缓存的优点
- 减少了不必要的数据传输
- 减轻了对服务器的压力，提升系统的性能
- 加快了用户加载网页的速度
- 提升了用户体验


### 缓存的缺点
- 无法保证缓存数据与数据库中的数据保持同步
- 可能会出现缓存失效


### 强缓存和协商缓存的区别
1. 强制缓存发生在浏览器端，协商缓存发生在服务器端。
2. 强制缓存在浏览器强制刷新的情况下不会生效，而协商缓存则不受影响。
3. 强制缓存返回的报文状态码为 200，协商缓存返回的报文状态码为 304。
```

![http缓存流程图](./image/http_caching_process.jpg)

![20210204170209785](./image/20210204170209785.png)

#### 强缓存

```bash
### 强制缓存
当客户端请求后，会先访问缓存数据库看缓存是否存在。如果存在则直接返回；不存在则请求真的服务器，响应后再写入缓存数据库。强制缓存直接减少请求数，是提升最大的缓存策略。 

- 再次请求时无需向服务器发送请求，直接从浏览器缓存中获取资源，其请求返回的状态码是200。
- 可以通过在服务器中设置 http 中响应头的 Expires 和 cache-control 字段来设置强制缓存，告诉浏览器缓存的有效期。

- 缺点：这种方法会有一个固定时间，所带来的问题是如果服务器数据进行了更新，但是还没有到强缓存的过期时间，则数据无法更新。
- 当 `Expires` 和 `Cache-Control` 同时存在时，优先考虑 `Cache-Control` 字段。当缓存资源失效(即没有命中强缓存)，接下来就进入协商缓存。



#### Response Headers 的 Expires 字段
Expires 字段是http1.0时的规范，用于表示资源过期时间的请求头字段。
  - `Expires`：这个响应头具有严格的格式要求，其值固定格式为绝对时间的GMT格式的时间字符串。
  - 注意： Expires 是属于 HTTP 1.0，现在默认浏览器均默认使用 HTTP 1.1
  - 注意2：Expires 是根据本地时间来判断的，假设客户端和服务器时间不同，会导致缓存命中误差
	- 范例：`Expires: Mon, 25 Oct 2021 20:11:12 GMT`



#### Response Headers 的 Cache-Control 字段
- 为解决expires根据本地时间判断导致缓存命中误差，在http1.1规范中，提出了cache-control字段，且同时使用时优先级高于Expires。
- `Cache-Control`：具有强大的缓存控制能力，值为相对时间。
    - `max-age`：缓存最大有效时长，表示客户端在这个有效期内如果又请求该资源，就直接读取缓存。
    		- 为相对时间，例如 `Cache-Control:max-age=3600`，代表着资源的有效期是3600秒，即客户端过了3600秒缓存过期。
    - `s-maxage`：和max-age一样，但这个是设定代理服务器的缓存时间
    - `must-revalidate`：如果超过了 max-age 的时间，浏览器必须向服务器发送请求，验证资源是否还有效
    - `no-cache`：不使用本地缓存（禁止强缓存），但可以使用协商缓存。
    - `no-store`：直接禁止浏览器缓存数据，每次用户请求该资源，都会向服务器发送一个请求，每次都会下载完整的资源。
    - `public`：可以被所有的用户缓存，包括终端用户和 CDN 等中间代理服务器。但当用户重新刷新页面时就会重新发送请求获取资源。
    - `private`：只让客户端用户的浏览器可缓存该资源，不允许 CDN 等中继缓存服务器（代理服务器）对其缓存。
    - `immutable`：表示即使用户重新刷新页面，也不会重新发送请求，还是直接读取缓存。

注意：no-cache 与 no-store 的区别
    -	no-cache 表示不缓存过期资源，缓存会向服务器进行有效处理确认之后，再处理资源。
    - no-store 表示真正的不进行缓存。



#### 强制缓存流程图
               client         server
GET /a.ab389z.js ------->
                      <------- 200 OK
(再也不会发请求)
```

![image-20230227113939923](./image/image-20230227113939923.png)

![image-20230227113748135](./image/image-20230227113748135.png)

```js
// nodejs 后端实现强缓存

const http = require('http')
const fs = require('fs')
const server = http.createServer((req, res) => {
  const time = new Date()
  time.setTime(time.getTime() + 100 * 1000) // 时间戳计算后 10s
  const expires = time.toUTCString() // GMT（格林尼治标准时间）时间格式
  res.setHeader('Expires', expires)

  // 优先级高于 Expires
  res.setHeader('Cache-Control', 'max-age=30')
  const html = fs.readFileSync('./src/index.html', 'utf8')
  res.end(html)
})
server.listen(3000)
```



#### 协商缓存

```bash
### 协商缓存
- 协商缓存需要向服务器请求，通过服务器来判断缓存是否可用。当同一个接口再次请求时，需要向服务器校验新鲜度。
    - 服务端如果确认缓存资源有效，会返回 304，客户端会从本地缓存数据库获取资源。
    - 如果资源更新了，返回 200，从服务器获取资源。
- 当所设置的强缓存时间过期了，可以使用协商缓存来解决问题。

- 协商缓存主要是通过 Etag 和 Last-Modified 两个字段来实现：
    - Etag 是一个用于映射 web 资源的映射 token，具有唯一性。
    - Last-Modified 则通常是该资源最后更新的日期时间戳。



#### 响应头的 Last-Modify 搭配 请求头的 If-Modify-Since
- Last-modify：表示该资源的最后修改时间，由服务器返回
- if-modified-since：浏览器在请求数据时返回的，值是上次浏览器返回的Last-modified

当浏览器第一次请求一个资源时，服务器返回的 header 中会加上 Last-Modify。
当浏览器再次请求该资源时，request 的请求头中会包含 If-Modify-Since，该值服务端 header 中返回的 Last-Modify。
服务器收到 If-Modify-Since 后，根据资源的最后修改时间判断是否命中缓存。



#### 响应头的 Etag 搭配 请求头的 If-None-Match
- ETag：一个文件的唯一标识符，当资源发生变化时这个ETag就会发生变化。弥补了 last-modified 可能出现文件内容没有变化但 last-modified 的值发生了变化，导致出现重新向服务器请求资源情况。这个值也是由服务器返回的
- if-none-match：是浏览器请求数据时带上的字段，值是上次服务器返回的ETag

web服务器响应请求时，会在 header 中加一个 Etag 用来告诉浏览器当前资源在服务器的唯一标识（生成规则由服务器决定）。
当再次向 web 服务器请求时带上头 If-None-Match（Etag的值）。web服务器收到请求后将 If-None-Match 的与 Etag 两者的值进行比对是否需要变动，有变动的话就将新的资源发送回来。并且 `ETag` 优先级⽐ `Last-Modified` 高。



#### `Last-Modified` 与 `ETag` 的对比
- 性能上，`Last-Modified` 优于 `ETag`，
		1. Last-Modified 记录的是时间点，时间单位是秒，如果某个文件在1秒内改变了多次，那么它们的 Last-Modified 其实并没有体现出来修改。
		2. 而 Etag 需要根据文件的 MD5 算法生成对应的 hash 值。
- 精度上，`ETag` 优于 `Last-Modified`
		1. ETag 按照内容给资源带上标识，能准确感知资源变化（需要服务器通过算法来计算出一个 hash 值）
		2. Last-Modified 只需要记录时间，在某些场景并不能准确感知变化。
- 在优先级上，如果两者都存在，服务器校验优先判断 `If-None-Match` 进行 `ETag` 协商缓存
如果服务器收到的请求没有 Etag 值，则将 If-Modified-Since 和被请求文件的最后修改时间做比对，一致则命中协商缓存，返回 304。不一致则返回新的 Last-modified 和文件并返回 200。



#### 协商缓存流程图
           client         server
GET /a.js   ----------->
                   <----------- 200 OK
GET /a.js   ----------->
                   <----------- 304 Not Modified



#### 缓存位置
当命中强缓存和协商缓存返回 304 时，浏览器会从缓存中获取资源。
浏览器的缓存一共有四种，按照优先级从高到低排列分别是：
    1. Service Worker：借鉴了 WebWorker，其主要功能是：离线缓存(Service Woker Cache)、消息推送和网络代理。
    2. Memory Cache：内存缓存。从效率上来讲，它是最快的；从存活时间来讲，它又是最短的。当渲染进程结束后，内存缓存就消失。
    3. Disk Cache：存储在磁盘中的缓存，从存取效率上讲是比内存缓存慢的，优势在于存储容量和存储时长。
    4. Push Cache：推送缓存，它是浏览器缓存的最后一道防线，它属于 HTTP/2.0 的内容。

浏览器在选择 Disk Cache 与 Memory Cache 的存储上：
	内容使用率高的，文件优先进入磁盘。
	比较大的 JS/CSS 文件直接放入磁盘，反之放入内存中。
```

![img](./image/8fa5e6349642483392f508ffac75c96f.png)

![image-20230227115051965](./image/image-20230227115051965.png)

nodejs 通过 lastModified 设置协商缓存

```js
// nodejs 实现 协商缓存 示例
// 缺陷是如果在本地打开缓存文件，就会造成 `Last-Modified` 被修改，所以在 HTTP/1.1 出现了 `ETag`

const http = require('http')
const fs = require('fs')

const server = http.createServer((req, res) => {
  const reqModified = req.headers['if-modified-since']
  const info = fs.statSync('./src/index.html')
  const lastModified = info.mtime.toUTCString() // GTM

  if (reqModified && reqModified === lastModified) {
    console.log('浏览器走缓存')
    res.statusCode = 304
    res.end()
    return
  }

  res.setHeader('Last-Modified', lastModified)
  const html = fs.readFileSync('./src/index.html', 'utf8')
  res.end(html)
})

server.listen(3000)
```



##### nodejs 通过 Etag 和 lastModified 来实现协商缓存( `ETag` 优先级⽐ `Last-Modified` 高)

```js
const http = require('http')
const fs = require('fs')
const crypto = require('crypto')

const server = http.createServer((req, res) => {
  const buffer = fs.readFileSync('./src/index.html') // 二进制文件流
  const hashTool = crypto.createHash('md5') // 使用 md5 加密算法
  hashTool.update(buffer, 'utf8') // 注入二进制
  const md5 = hashTool.digest('hex') // 生成 md5 加密的唯一标识 hash
  const reqETag = req.headers['if-none-match']
  if (reqETag && reqETag === md5) {
    console.log('ETag 缓存')
    res.statusCode = 304
    res.end()
    return
  }

  const reqModified = req.headers['if-modified-since']
  const info = fs.statSync('./src/index.html')
  const lastModified = info.mtime.toUTCString() // GTM

  if (reqModified && reqModified === lastModified) {
    console.log('modified 缓存')
    res.statusCode = 304
    res.end()
    return
  }

  res.setHeader('Last-Modified', lastModified)
  res.setHeader('ETag', md5)
  const html = fs.readFileSync('./src/index.html', 'utf8')
  res.end(html)
})

server.listen(3000)
```



##### 利用 nginx 设置浏览器协商缓存

```bash
## 利用 nginx 设置浏览器协商缓存
1. nginx 下面的配置如下：
      http {
        server {
          listen 80;

          location /picture/ {
            # alias 是重定义路径， alias是替换，root是拼接
            add_header Cache-Control no-cache;
            alias D:/willy/picture/;
            autoindex on;	# 访问127.0.0.1/picture/，会得到目录的索引界面
          }
        }
      }

2. 清除浏览器缓存后第一次发起请求会得到一个正常的 200 Response，而且响应头里已经有 `Cache-Control: no-cache` 表示使用协商缓存。
3. 再次发情请求后，会发现请求头已经带上 `If-Modified-Since` 和 `If-None-Match` 两项。
4. 服务端(Nginx)收到这两项后，会与资源当前生成的 Etag 和 Last-Modified 做比较，如果两者都一致，说明资源没有更新，服务端会返回 304 空响应；否则说明资源有更新，服务端会将完整的资源内容返回。
		注意：服务器验证 `If-Modified-Since` 的方式只是简单的字符串比较，即使资源的 `Last-Modified 比 If-Modified-Since` 要早，服务端仍认为资源有更新。
5. 浏览器在收到 304 响应后，会从浏览器缓存中取资源，因此速度非常快。
```



### 浏览器控制不走缓存

#### Ctrl + F5（硬性重新加载、强制刷新）

```bash
去除浏览器在请求头加上的If-Modified-Since或If-None-Match字段，并加上Pragma: no-cache和Cache-Control: no-cache字段。

Pragma: no-cache和Cache-Control: no-cache表示不走强制缓存，由于去掉了协商缓存的字段，导致也无法走协商缓存。

注意：ctrl+f5只不过能够管控 <link>、<script>、<img>、<frame> 等 dom 标签，还有样式中 background:url()、@font-face() 等文件外链阻止它们去访问缓存,对于 ajax 请求无能为力。

而 Disable cache 在每次请求之前，直接将清空了相应缓存，从根源阻止了浏览器的缓存相关策略，所以这时ajax请求也不能使用缓存了
```

#### Disable cache

F12，控制台的 Network 下可勾选禁用缓存。

作用：每次请求之前，清空缓存，导致请求无缓存可用，并同样地去除浏览器在请求头加上的 If-Modified-Since 或 If-None-Match 字段，并加上 Pragma: no-cache 和 Cache-Control: no-cache 字段,以便获取最新的资源。

![image-20240613142230916](./image/image-20240613142230916.png)

#### Ctrl + Shift + Delete

删除缓存文件，不在请求头中添加任何缓存相关字段

#### 强缓存假象

通过上面的操作仍然有一些资源在控制台Network下看上去是从缓存中取的。可以发现基本上都是base64格式得图片文件等。

这是因为**这些内容依附在其他文件中从服务器请求到客户端，并在构建dom树的时候在内存中加载并解析。完毕后从内存中拿出来，就出现了强缓存的假相**。

![image-20240613142147142](./image/image-20240613142147142.png)

### PWA

```bash
PWA 全称为 Progressive Web App（渐进式 Web APP），其目的是通过各种 Web 技术实现与原生 App 相近的用户体验。
Web 应用可通过 PWA 去弥补跟原生应用如离线缓存、沉浸式体验等这些差距，达到与原生应用相近的用户体验效果。


跟原生开发的App应用，PWA 解决 Web 应用的问题
    1. 手机应用配置（Web App Manifest）
        - 通过 manifest.json 文件配置，使得可以添加至主屏幕，点击主屏幕图标可以实现启动动画以及隐藏地址栏。
    2. 实现离线加载与缓存（Service Worker + Cache API）
        - 通过 Service Worker + HTTPS + Cache_Api + indexedDB 等实现离线缓存功能，即使用户手机没有网络，依然可以使用一些离线功能。
    3. 实现消息推动与通知（Push + Notification）
        - 实现实时的消息推送与通知
    4. 数据及时更新（Background Sync）
        - 后台同步，数据及时更新
```



## 请求方法

```bash
## 请求方式
- HTTP 的请求：简单请求和非简单请求。
```

### 简单请求

```bash
### 简单请求
简单请求需要满足两个条件：
  1. 请求方法为：`HEAD、GET、POST`。
  2. http的请求头 headers 中不超出以下请求字段：
      - Accept
      - Accept-Language
      - Content-Language
      - Last-Event-ID
      - Content-Type：使用媒体类型值仅限于下列三个值：
          - text/plain
          - multipart/form-data
          - application/x-www-form-urlencoded


### 简单请求跨域，浏览器的不同处理方式
1. 对于简单请求而言，如果请求跨域，则浏览器会放行让请求发出。
2. 浏览器会发出 `cors` 请求，并在 http 请求头中携带 `origin` 字段信息发送（origin 字段说明本次请求的来源(协议 + 域名 + 端口)）。
3. 此时不管服务端返回的是什么，浏览器都会把返回拦截，并检查返回的 `response` 的 `header` 中有没有 `Access-Control-Allow-Origin` 是否为 `true`。
		- 如果 Origin 指定的源不在许可范围内，服务端会返回一个正常的 HTTP 响应。当响应头信息中没有包含 `Access-Control-Allow-Origin` 字段，说明服务端没有开启资源共享，浏览器会认为这次请求失败，终止这次请求并且报错。
		- 如果 Origin 指定的域名在许可范围内，浏览器返回的响应会多出以下几个响应头信息字段。若为 true 则说明资源是共享的，可以拿到。
				- Access-Control-Allow-Origin: * （表示接受任意域名的请求）
				- Access-Control-Allow-Credentials: true（表示是否允许发送Cookie）
				- Access-Control-Expose-Headers: FooBar
				- Content-Type: text/html; charset=utf-8
			注意：因为 Cookie 遵循同源策略，如果要发送Cookie，Access-Control-Allow-Origin 就不能设为星号`*`，必须指定与请求网页一致的域名。
```



### options 请求

```bash
### Option 请求
- OPTIONS 请求即预检请求，可用于检测服务器允许的 http 方法。当发起跨域请求时，由于安全原因，触发一定条件时浏览器会在正式请求之前 '自动' 先发起 OPTIONS 请求，即 'CORS预检请求'，服务器接受该跨域请求，浏览器才能继续发起正式请求。



### 非简单请求
只要不满足简单请求的条件，都认为是复杂请求。
发出非简单`cors`请求，浏览器会做一个 `http` 的查询请求（options 预检请求），options 请求会按照简单请求方式来处理。


1. 做一次 options 请求的原因：
浏览器先询问服务器当前网页所在的域名是否在服务器的许可名单之中(确认是否支持跨域请求)，以及可以使用哪些HTTP动词和头信息字段(确认实际请求的安全性)。只有得到肯定答复，浏览器才会发出正式的XMLHttpRequest请求，否则就报错。
预检请求的目的是为保护客户端的安全，防止不受信任的网站利用用户的浏览器向其它网站发送恶意请求。预检请求头中除了携带 origin 字段还包含两个特殊字段：
	- `Access-Control-Request-Method`：告知服务器实际请求使用的 http 方法。
	- `Access-Control-Request-Headers`：告知服务器实际请求所携带的自定义首部字段。
	
	
2. 什么时候触发预检请求？
    - 发送跨域请求时，请求头中包含了一些费简单请求的头信息，例如自定义头(custom header)等。
    - 发送跨域请求时，使用了 `PUT、DELETE、CONNECT、OPTIONS、TRACE、PATCH` 等请求方法。


3. 优化 options 请求：使用 Access-Control-Max-Age 或 避免触发
当请求一旦触发跨域，跨域请求便会一直发送 2 次请求。OPTIONS预检请求的结果可以被缓存（使用`Access-Control-Max-Age`设定个时限，当在所设定的时限内该请求不会触发 OPTIONS 请求）。
	- `Access-Control-Max-Age` 这个响应头表示预检请求的返回结果（即Access-Control-Allow-Methods 和 Access-Control-Allow-Headers 提供的信息）可以被缓存的最长事件，单位是秒。
	- `Access-Control-Max-Age` 如果值为 `-1`，则表示禁用缓存，每一次请求都需要提供预检请求，即用 OPTIONS 请求进行检测。
```

![image-20230308173922986](./image/image-20230308173922986.png)

![image-20230308173849252](./image/image-20230308173849252.png)

### get和post请求的区别

```bash
GET 和 POST 请求都是基于 TCP 连接，但根据 HTTP 规范， GET 请求用于从指定的资源请求数据，POST 用于向指定的资源提交要被处理的数据。
1. '浏览器页面回退'：GET 请求在浏览器回退是无害的，POST 请求则需要再次提交请求的表单信息。
2. '历史记录'：GET 请求参数可存储保留在浏览器历史记录中，而 POST 无法保存。
3. '数据缓存'：GET 请求会被浏览器主动缓存，而 POST 请求需要手动设置。
4. '编码类型'：GET 请求只能进行 url 编码，而 POST 支持多种编码方式。
5. '数据长度限制'：因为 URL 地址最大长度为 2048 个字符(长度受限)，所以正常情况下 GET 请求在 URL 中传递的参数是有长度限制；而 post 请求的参数信息存放在请求体，所以没有长度限制，也允许二进制数据。
6. '数据类型限制'：GET 请求的参数数据类型只接受 ASCII 字符，而 POST 请求的参数数据类型没有限制。
7. '可见/安全性'：因为 GET 请求的参数通过 URL 传递，而 POST 请求的参数存放在请求体中，导致 GET 相对于 POST 更不安全，所以不建议使用 GET 请求传递敏感信息。

注意：get请求的 params 参数不能传递数组和对象，需要对其进行转码才能进行发送请求。
```



## 请求技术

### XML语法

```bash
1. XML 声明：
    - `<?xml version="1.0" encoding="UTF-8"?>`
    - （第一行的声明，指定了 XML 版本(1.0)以及使用的编码）

2. 自定义标签：
    - XML 中没有默认的标签，所有的标签都是我们自己已定义的（XML只有双标签）
    - XML 中必须要有一个根节点，所有的子节点都放置在根节点下

3. XML 解析：
		- 因为 XML 就是标签，所以我们可以直接用解析 Dom 元素的方法解析 XML


### XML 与 html 的区别
1. xml 是可扩展标记语言，类似 html，但与html不同的是，xml标签没有被预定义，需要自行定义标签。
2. xml 被设计用来传输和存储数据，其焦点是数据内容；
	xml 不是 html 的替代，html 被设计用来显示数据，其焦点是数据外观；
3. xml 具有自我描述性。
```



### AJAX

```bash
### 发送AJAX请求的步骤
1. 创建异步对象，即 `XMLHttpRequest` 对象。
2. 使用 open 方法设置请求参数。`open(method, url, asynchronous, username, password)`。
     1. method：请求的类型；GET 或 POST
     2. url：文件在服务器上的位置
     3. asynchronous：true(异步)或 false(同步)，不写默认为true
3. 使用 res.send() 发送请求，注意：send() 仅用于 POST 请求
4. 注册事件：
		注册 onreadystatechange 事件，状态改变时就会调用。
		如果要在数据完整请求回来的时候才调用，则要手动写一些判断的逻辑。
5. 服务端响应，获取返回的数据。



### onreadystatechange 事件
    - 注册 onreadystatechange 事件后，每当 readyState 属性改变时，就会调用 onreadystatechange 函数
    - readyState：（存有 XMLHttpRequest 的状态）
        - 0: 请求未初始化
        - 1（OPEN）: 请求开始,服务器连接已建立
        - 2 (HEADERS_RECEIVED): 请求信息已接收
        - 3（LOADING）: 请求处理中
        - 4(DONE): 请求已完成，且响应已就绪
    - status：
        - 200: "OK"
        - 404: 未找到页面
    - 在 onreadystatechange 事件中，当 readyState 等于 4，且状态码为 200 时，表示响应已就绪


### 服务器响应的内容
    - responseText：获得字符串形式的响应数据
    - responseXML：获得 XML 形式的响应数据


### AJAX 禁用缓存
AJAX 能提高页面载入速度的主要原因是通过 ajax 减少重复数据的载入，即在载入数据的同时将数据缓存到内存中，一旦数据被加载其中，只要没有刷新页面，这些数据就会一直被缓存在内存中，使得当我们提交的请求 Url 与 历史 Url 一致时，就不需要提交给服务器，虽然如此可以降低服务器的负载以提高用户的体验，但会让我们无法获取最新的数据信息。
为了保证读取的信息都是正确的，就需要禁止 ajax 的缓存功能。
    1. 可在 ajax 发送请求前添加：`xhr.setRequestHeader("If-Modified-Since", "0")`
    2. 或在 ajax 发送请求前添加：`xhr.setRequestHeader("Cache-Control", "no-cache")`


### Ajax 与 Flash 的优劣
AJAX：
		- AJAX优势：可搜索性、开放性、费用、易用性、易于开发
		- AJAX劣势：可能破坏浏览器的后退功能、使用动态页面更新使得用户难以将某个特定的状态保存到收藏夹中
Flash:
    - flash优势：多媒体处理、兼容性、矢量图、客户端资源调度
    - flash劣势：二进制格式、格式私有、flash文件经常很大，用户第一次使用时需要忍耐较长的等待时间、性能问题
```

**完整的AJAX请求**

```js
//【发送get请求】
const xhr1 = new XMLHttpRequest();
xhr1.open('get', '02-ajax.php');
xhr1.send();
xhr1.onreadystatechange = function () {
  if (xhr1.readyState == 4 && xhr1.status == 200) {
    console.log('数据返回成功：' + JSON.stringify(xhr1.responseText));
  }
};


// 异步对象【发送post 请求】
const xhr2 = new XMLHttpRequest();
xhr2.open('post', '02.post.php');
// 如果想要使用post提交数据,必须设置如下请求头
xhr2.setRequestHeader('Content-type', 'application/x-www-form-urlencoded');  
xhr2.send('name=fox&age=18');
xhr2.onreadystatechange = function () {
  if (xhr2.readyState == 4 && xhr2.status == 200) {
    console.log(xhr2.responseText);
  }
};
```

**封装AJAX**

```js
// 封装 Ajax为公共函数：传入回调函数 success 和 fail
function myAjax(url, success, fail) {
  // 兼容IE5、IE6浏览器
  const xhr = window.XMLHttpRequest ? new XMLHttpRequest() : new ActiveXObject('Microsoft.XMLHTTP');
  xhr.open('GET', url, true);
  xhr.send();
  
  // 服务端响应
  xhr.onreadystatechange = () => {
    if (xhr.readyState === 4 && xhr.status === 200) {
      console.log('数据返回成功：' + JSON.parse(xhr.responseText));
      success && success(xhr.responseText);
    } else {
      //  当存在 fail 参数才跳出错误
      fail && fail(new Error('接口请求失败'));
    }
  };
}

// 单次调用 ajax
myAjax('a.json', (res) => {
  console.log(res);
});

// 多次调用 ajax。接口请求顺序：a --> b --> c
myAjax('a.json', (res1) => {
  console.log(res1);
  myAjax('b.json', (res2) => {
    console.log(res2);
    myAjax('c.json', (res3) => {
      console.log(res3);
    });
  });
});
```

### Fetch

```bash
Fetch 基于 Promise 设计，其代码结构比 AJAX 简单，参数类似 JQuery ajax。但 Fetch 是原生 js，不是 ajax 的进一步封装（没有使用 XMLHttpRequest 对象）。

- 语法简洁，更加语义化。
- 脱离 XHR，是 ES 语法规范里的新视线方式。
- Fetch 只对网络请求报错，对 400、500 状态码都当做成功的请求。
- Fetch 默认不会带 cookie，需要添加配置项。


fetch 的响应需要经过两个阶段：
1. 当服务器发送了响应头，fetch 返回 promise 旧使用内建的 Response class 对象来对响应头进行解析。
	- 在这个阶段可以通过检查响应头，来检查 HTTP 状态以确定请求是否成功（当前还没响应体返回）
	- 如果 fetch 无法简历一个 HTTP 请求，如网络问题，或者请求的资源地址不存在，则 promise 会 reject。异常的 HTTP 状态（如 400或500）不会导致出现 reject。
	- 此时 promise 传递的 response 属性中看到 HTTP 状态。
			- status：HTTP状态码，如 200。
			- ok：布尔值，如果 http 状态码为 200到299 的范围，则为 true。
			- headers：类似于 Map 的带有 HTTP header 的对象。

2. 需要使用 Response 基于 promise 的方法，来以不同的格式访问获取 body：
	- response.text() —— 读取 response，并以文本形式返回 response，
	- response.json() —— 将 response 解析为 JSON 格式，
	- response.formData() —— 以 FormData 对象的形式返回 response，
	- response.blob() —— 以 Blob（具有类型的二进制数据）形式返回 response，
	- response.arrayBuffer() —— 以 ArrayBuffer（低级别的二进制数据）形式返回 response
注意：response.body 是 ReadableStream 对象，它允许你逐块读取 body
```

```js
fetch('http://example.com/movies.json')
  .then(function(response) {
  	if (!response.ok) {
      console.log('HTTP-Error: ' + response.status);
    }
  	
    // 迭代所有 header
    for (let [key, value] of response.headers) {
      alert(`${key} = ${value}`);
    }
  
    return response.json();
  })
  .then(function(myJson) {
    console.log(myJson);
  });


// Example POST method implementation:
postData('http://example.com/answer', {answer: 42})
  .then(data => console.log(data)) // JSON from `response.json()` call
  .catch(error => console.error(error))

function postData(url, data) {
  return fetch(url, {
    body: JSON.stringify(data), // must match 'Content-Type' header
    cache: 'no-cache', // *default, no-cache, reload, force-cache, only-if-cached
    credentials: 'same-origin', // include, same-origin, *omit
    headers: {
      'user-agent': 'Mozilla/4.0 MDN Example',
      'content-type': 'application/json'
    },
    method: 'POST', // *GET, POST, PUT, DELETE, etc.
    mode: 'cors', // no-cors, cors, *same-origin
    redirect: 'follow', // manual, *follow, error
    referrer: 'no-referrer', // *client, no-referrer
  })
  .then(response => response.json()) // parses response to JSON
}
```

#### FromData

```bash
FormData 对象用于捕获 HTML 表单，并使用 fetch 或其他网络方法提交。

可以从 HTML 表单创建 new FormData(form)，也可以创建一个完全没有表单的对象。

可以使用以下方法修改 FormData 中的字段
    formData.append(name, value) —— 添加具有给定 name 和 value 的表单字段，
    formData.append(name, blob, fileName) —— 添加一个字段，就像它是 `<input type="file">`，第三个参数 fileName 设置文件名（而不是表单字段名），因为它是用户文件系统中文件的名称，
    formData.delete(name) —— 移除带有给定 name 的字段，
    formData.get(name) —— 获取带有给定 name 的字段值，
    formData.has(name) —— 如果存在带有给定 name 的字段，则返回 true，否则返回 false。
从技术上来讲，一个表单可以包含多个具有相同 name 的字段，因此，多次调用 append 将会添加多个具有相同名称的字段。

还有一个 set 方法，语法与 append 相同。不同之处在于 .set 移除所有具有给定 name 的字段，然后附加一个新字段。因此，它确保了只有一个具有这种 name 的字段，其他的和 append 一样：
    formData.set(name, value)，
    formData.set(name, blob, fileName)。



注意：
		set 方法会移除具有相同名称（name）的字段，而 append 不会。
		要发送文件，需要使用三个参数的语法，最后一个参数是文件名，一般是通过 `<input type="file">` 从用户文件系统中获取的。

其他方法是：
		formData.delete(name)
		formData.get(name)
		formData.has(name)
```

```html
<body style="margin:0">
  <canvas id="canvasElem" width="100" height="80" style="border:1px solid"></canvas>

  <input type="button" value="Submit" onclick="submit()">

  <script>
    canvasElem.onmousemove = function(e) {
      let ctx = canvasElem.getContext('2d');
      ctx.lineTo(e.clientX, e.clientY);
      ctx.stroke();
    };

    async function submit() {
      let imageBlob = await new Promise(resolve => canvasElem.toBlob(resolve, 'image/png'));

      let formData = new FormData();
      formData.append("firstName", "John");
      formData.append("image", imageBlob, "image.png");

      // 列出 key/value 对
      for(let [name, value] of formData) {
        alert(`${name} = ${value}`); // key1 = value1，然后是 key2 = value2
      }

      let response = await fetch('/article/formdata/post/image-form', {
        method: 'POST',
        body: formData
      });
      let result = await response.json();
      alert(result.message);
    }

  </script>
</body>
```



#### fetch 确认下载进度

```bash
fetch API 本身并不直接提供下载进度的功能，因为它是一个基于 Promise 的 API，主要用于处理网络请求，并返回一个 Promise 对象来解析响应。
可以使用响应头中的 Content-Length 和响应体的流式读取（Streams API）来实现
```

```js
function fetchWithProgress(url, onProgress) {
  return fetch(url)
    .then((response) => {
      if (!response) throw new Error('Network response is null')

      if (!response.ok) throw new Error('Network response was not ok')

      // 获取 Content-Length（如果存在）
      const contentLength = Number(response.headers.get('content-length'))
      let receivedLength = 0

      // 创建一个 reader 来读取响应体
      const reader = response.body!.getReader()

      // 递归函数，用于读取流并更新进度
      function streamReader() {
        return reader.read().then(({ done, value }) => {
          if (done) {
            // 读取完成，通知最终进度（100%）
            onProgress({ loaded: contentLength, total: contentLength })
            return
          }

          // 更新已接收的字节数
          receivedLength += value.length

          // 估算进度并通知监听器
          const progress = (receivedLength / contentLength) * 100
          onProgress({ loaded: receivedLength, total: contentLength, progress })

          // 继续读取流
          return streamReader()
        })
      }

      // 开始读取流
      return streamReader()
    })
    .then(() => {
      // 如果需要，可以在这里处理响应体的数据
    })
    .catch((err) => {
      console.error('There has been a problem with your fetch operation:', err)
    })
}

// 使用示例
fetchWithProgress('your-file-url', ({ loaded, total, progress }) => {
  console.log(
    `Progress: ${progress.toFixed(2)}%, loaded: ${loaded}, total: ${total}`,
  )
})

```



### fetch、ajax、axios 的区别

```bash
1. AJAX
    - AJAX 的核心是 XMLHttpRequest 对象，全称为异步的js与xml（Async JavaScript And XML）。
    - AJAX 的优点是可实现页面局部刷新，进行异步网络请求。
    - 拥有打开AJAX请求、设置http请求头、发送ajax请求的方法；还有响应请求 onreadystatechange 的回调事件、以及响应返回的状态。
    - AJAX 基于原生的 XHR 开发，如果多个请求之间如果有先后关系，会出现回调地狱问题。


2. Fetch
    - Fetch 基于 Promise 设计，其代码结构比 AJAX 简单，参数类似 JQuery ajax。但是 Fetch 不是 ajax 的进一步封装（没有使用 XMLHttpRequest 对象），而是原生 js。
    - 语法简洁，更加语义化。
    - 脱离 XHR，是 ES 语法规范里的新实现方式。
    - Fetch 只对网络请求报错，对 400、500 状态码都当做成功的请求。
    - Fetch 默认不会带 cookie，需要添加配置项。
    

3. axios
		- axios 提供了并发的封装，也没有 fetch 的各种问题，而且包体积小，所以现在大多选用 axios 作为请求的方式。
```



### 取消已发送的网络请求

- 使用 `XMLHttpRequest` 发送请求可使用 `XMLHttpRequest.abort()`
- 使用 `fetch` 发送请求可以使用 `AbortController`，不仅可以取消 Fetch 请求发送，同样也可以取消事件的监听
- Axios 中通过 `CancelToken` 取消请求发送

- 对于浏览器环境，Axios 底层使用 `XMLHttpRequest` 对象来发起 HTTP 请求。它使用基于 XHR 的 `xhr.abort()` 方法取消请求
- 对于 Node.js 环境，Axios 底层使用 `HTTP/HTTPS` 模块对象来发起 HTTP 请求。使用 `request.abort()`

**xhr**

```js
const xhr = new XMLHttpRequest()
xhr.open('GET', 'https://jsonplaceholder.typicode.com/todos/1', true)
xhr.send()

// 取消发送请求
xhr.abort()
```

**Fetch**

```js
const controller = new AbortController()
const signal = controller.signal

// 调用 abort 时触发
signal.addEventListener('abort', () => {
  alert('abort!')
})

fetch('https://jsonplaceholder.typicode.com/todos/1', {
  signal
})
  .then((response) => response.json())
  .then((json) => console.log(json))

controller.abort()

// 事件触发，signal.aborted 变为 true
alert(signal.aborted) // true
```

**axios**

```js
const CancelToken = axios.CancelToken
const source = CancelToken.source()

axios.get('https://jsonplaceholder.typicode.com/todos/1', {
  cancelToken: source.token
})

// 取消请求（消息参数是可选的）
source.cancel('用户已取消操作')



// 也可以通过调用 `CancelToken` 的构造函数来创建 `CancelToken`：
const CancelToken = axios.CancelToken
let cancel
axios.get('https://jsonplaceholder.typicode.com/todos/1', {
  cancelToken: new CancelToken((c) => {
    cancel = c
  })
})
cancel() // 取消请求
```

### 浏览器如何判断一个http请求结束

```bash
HTTP响应的结束由浏览器通过多个因素确定：

1. HTTP响应状态码：
浏览器可以通过查看HTTP响应的状态码以确定请求是否成功。但状态码本身并不直接指示请求是否“结束”，它只是表示请求的处理状态。


2. Content-Length 响应头：
HTTP响应头中的Content-Length字段表示响应体的内容长度（以字节为单位）。
如果响应头中包含Content-Length字段，浏览器会根据这个长度来接收数据，并在接收到相应数量的字节后认为响应体已经结束。


3. `Transfer-Encoding: chunked` 响应头：
如果响应头中包含 `Transfer-Encoding: chunked`，则表示响应体将被分成多个块发送（注意：Content-Length 此时字段就不会出现）。
在这种情况下，响应体会被分割成多个块，每个块前面都有一个表示该块长度的十六进制数字，后跟实际的块数据，最后是一个大小为0的块，表示响应体结束。浏览器会逐个接收这些块，直到遇到一个长度为0的块时认为响应体已经结束。


4. 浏览器内部处理：
浏览器内部有一个网络栈（networking stack），它负责处理HTTP请求和响应。当网络栈接收到完整的HTTP响应（包括状态行、响应头和响应体）时，它会认为请求已经结束，并将响应数据传递给渲染引擎或其他相关组件进行处理。


5. TCP连接关闭：
浏览器和服务器之间的通信是基于TCP协议的。TCP协议本身提供了数据传输的可靠性保证，包括数据包的顺序、完整性和错误处理。因此，即使在网络条件不稳定的情况下，浏览器也能通过TCP协议确保HTTP请求的正确结束。
HTTP/1.1默认使用长连接（Persistent Connection）。这意味着浏览器和服务器之间的TCP连接在发送完一个HTTP响应后不会立即关闭，而是可以被多个请求和响应复用。但是，浏览器仍然会根据每个响应的状态来判断该请求是否已经结束。
在某些情况下，服务器可能会在响应头中发送Connection: close字段，表示该连接在发送完当前响应后应该被关闭。在这种情况下，浏览器会在接收完响应后关闭连接。
```



### WebSocket

```bash
- WebSocket 是 HTML5 提供的一种浏览器与服务器进行全双工通讯的网络技术，属于应用层协议。它基于TCP传输协议，并复用HTTP的握手通道。
- WebSocket 支持持久连续，Http1.0 和 HTTP1.1 协议不支持持久性连接，HTTP1.1 中的 keep-alive 将多个 http 请求合并为 1 个。
- 优点：WebSocket 建立 TCP 连接后，服务器可以主动给客户端传递数据，能够更好的节省服务器资源和带宽，实现更实时的数据通讯。
- 缺点：WebSocket为了保持客户端、服务端的实时双向通信，需要确保客户端、服务端之间的TCP通道保持连接没有断开。然而，对于长时间没有数据往来的连接，如果依旧长时间保持着，可能会浪费包括的连接资源。


- 轮询请求的缺点
		- 在以前，很多网站为了实现数据推送，所用的技术都是ajax轮询。轮询是在特定的时间间隔，由浏览器主动发起请求，将服务器的数据拉回来。轮询需要不断的向服务器发送请求，会占用很多带宽和服务器资源。

- 对WebSocket封装并且与浏览器向下兼容的 socket.io
		- Node的单线程、非阻塞I/O、事件驱动机制非常适合 Socket服务器：`npm install socket.io`


- WebSocket的优点：
HTTP 的生命周期通过Request 来界定，也就是Request 一个Response，那么在Http1.0 协议中，这次Http 请求就结束了。
在Http1.1 中进行了改进，添加了一个connection方法： 即在一个Http 连接中，可以发送多个Request，接收多个Response。
但是在Http 中一个Request 只能对应有一个Response，而且这个Response 是被动的，不能主动发起。
WebSocket 是基于Http 协议的，也可理解为 Http 协议来完成一部分握手，在握手阶段 与Http 是相同的。
一个websocket 握手协议的实现，主要是基于 upgrade、connection 这两个属性。


- 安全的 Websocket
始终对 WebSocket 使用安全、加密的协议 `wss://`。
`ws://` 指的是不安全的 WebSocket 版本（`WebSocket` 的 `http:`），出于显而易见的原因，应避免使用。



#### websocket请求数据渲染，导致卡顿的优化
- 原因：websocket发送数据或者接收数据是不会卡死的，只有当接收消息时频繁更改页面数据才会造成卡顿。
- 优化：不要一收到数据就进行渲染，可以利用定时器每秒渲染或者使用 DocumentFragment
     1. 降低发送频率
     2. 优化处理过程
     3. 先获取数据，定时处理

```

```js
// 创建 WebSocket 对象
const Socket = new WebSocket(url, [protocol] ); 

// WebSocket 属性
Socket.readyState // 只读属性readyState表示连接状态
// 0 - 连接尚未建立
// 1 - 连接已建立，可以进行通信
// 2 - 连接正在进行关闭
// 3 - 连接已经关闭或者连接不能打开

// WebSocket 事件
Socket.onopen // 连接建立时触发
Socket.onmessage // 客户端接收服务端数据时触发
Socket.onerror // 通信发生错误时触发
Socket.onclose // 连接关闭时触发

// WebSocket 方法
Socket.send(JSON.stringify()) // 使用连接发送数据	注意：因为数据需要JSON对象格式，所以需要转换
Socket.close() // 关闭连接
```

**前端使用 websocket**

```js
const url = 'wss://myServer.com'
const connection = new WebSocket(url)

connection.onopen = () => {
  connection.send('hey')
  //...
}

connection.onerror = (error) => {
  console.log(`WebSocket error: ${error}`)
}

connection.onmessage = (e) => {
  console.log(e.data)
}
```

**在 Node.js 中实现服务器**

- `$ pnpm i ws`

```js
const WebSocket = require('ws')

const wss = new WebSocket.Server({ port: 8080 })

wss.on('connection', (ws) => {
  ws.on('message', (message) => {
    console.log(`Received message => ${message}`)
  })
  ws.send('ho!')
})
```



#### Sec-WebSocket-Key/Accept的作用

```bash
Sec-WebSocket-Key/Sec-WebSocket-Accept在主要作用在于提供基础的防护，减少恶意连接、意外连接。

作用大致归纳如下：
    1. 避免服务端收到非法的websocket连接（比如http客户端不小心请求连接websocket服务，此时服务端可以直接拒绝连接）
    2. 确保服务端理解websocket连接。因为ws握手阶段采用的是http协议，因此可能ws连接是被一个http服务器处理并返回的，此时客户端可以通过 Sec-WebSocket-Key 来确保服务端认识ws协议。
    用浏览器里发起ajax请求，设置header时，Sec-WebSocket-Key 以及其他相关的header是被禁止的。这样可以避免客户端发送ajax请求时，意外请求协议升级（websocket upgrade）
    3. 可以防止反向代理（不理解ws协议）返回错误的数据。比如反向代理前后收到两次ws连接的升级请求，反向代理把第一次请求的返回给cache住，然后第二次请求到来时直接把cache住的请求给返回（无意义的返回）。
    4. Sec-WebSocket-Key 主要目的并不是确保数据的安全性，因为 Sec-WebSocket-Key、Sec-WebSocket-Accept 的转换计算公式是公开的，而且非常简单，最主要的作用是预防一些常见的意外情况（非故意的）。
    
强调：Sec-WebSocket-Key/Sec-WebSocket-Accept 的换算，只能带来基本的保障，但连接是否安全、数据是否安全、客户端/服务端是否合法的 ws客户端、ws服务端，其实并没有实际性的保证。
```



### WEB应用从服务器主动推送数据到客户端的方式

```bash
1. html5 的 websocket
2. websocket 通过 Flash
3. XHR 长时间连接
4. 不可见的 iframe
5. <script> 标签的长时间连接(可跨域)
6. ajax 轮询调用请求



### Ajax 轮询
Ajax 轮询是定时通过 Ajax 查询服务端，客户端按规定定时向服务端发送 ajax 请求，服务器接到请求后马上返回响应信息并关闭连接。
优点： 逻辑简单容易实现。
缺点：
    * 需要不断向服务器发送消息询问，请求中有大半是无用，浪费带宽和服务器资源。
    * 通过模拟服务器发起的通信，不是实时通信，不顾及应用的状态改变并且盲目检查更新，导致服务器资源浪费，且会加重网络负载，拖累服务器。
    * 前端长时间处于轮询占用CPU，并且由于JS是单线程，轮询间隔无法保证。
实例：适于小型应用。


### WebSocket 通过 Flash
Flash Socket：在页面中内嵌入一个使用了Socket类的 `Flash` 程序，`JavaScript`通过调用此`Flash`程序提供的Socket接口与服务器端的Socket接口进行通信，JavaScript在收到服务器端传送的信息后控制页面的显示。
 * 优点：实现真正的即时通信，而不是伪即时。
 * 缺点：客户端必须安装Flash插件；非HTTP协议，无法自动穿越防火墙。
 * 实例：网络互动游戏。


### XHR 长时间连接（长轮询）
客户端打开一个到服务器端的 `AJAX` 请求然后等待响应；服务器端需要一些特定的功能来允许请求被挂起，只要一有事件发生，服务器端就会在挂起的请求中送回响应并关闭该请求。
客户端 JavaScript 响应处理函数会在处理完服务器返回的信息后，再次发出请求，重新建立连接；如此循环。
优点： 
 		 * 对于前端来说实现简单，与普通的网络请求没有太大区别。
 		 * 在无消息的情况下不会频繁的请求。
缺点： 
 		 * 需要服务器端有特殊的功能来临时挂起连接，服务器hold连接会消耗资源。
 		 * 客户端发起的连接较多时，服务器端会长期保持多个连接，具有一定的风险。
实例：WebQQ、Hi网页版、Facebook IM。


### 不可见的iframe（长连接）
在页面中嵌入一个隐藏的`iframe`，将这个隐藏的`iframe`的`src`属性设置为对一个长连接的请求或者采用XRH请求，服务器端就能源源不断地往客户端输入数据。
 * 优点：消息即时到达，不发无用的请求；管理起来也相对方便。
 * 缺点：服务器维护一个长连接会增加开销。
 * 实例：Gmail聊天


### `<script>` 标签
把 script 标签附加到页面上以让脚本执行。服务器会挂起连接直到有事件发生，接着把脚本内容发送回浏览器，然后重新打开另一个 script 标签来获取下一个事件，从而实现长轮询的模型。
	 * 缺点：前后端实现都很麻烦
	 
	 
### html5 websocket
`WebSocket`是HTML5开始提供的一种在单个 `TCP` 连接上进行全双工通讯的协议。
在WebSocket API中，浏览器和服务器只需要做一个握手的动作，然后，浏览器和服务器之间就形成了一条快速通道。两者之间就直接可以数据互相传送。
 * 优点： 实现简单、可靠。
 * 缺点： 部分低版本浏览器可能不支持。
```



## HTTP状态码

### 状态码概述

```bash
### 常见状态码
- 1xx - 信息响应 - 传达传输协议级别的信息
- 2xx - 成功的响应 - 表示客户端的请求已成功接受
- 3xx - 重定向 - 表示客户端必须采取一些额外的操作才能完成其请求
- 4xx - 客户端错误 - 此类错误状态码指向客户端
- 5xx - 服务端错误 - 服务器对这些错误状态代码负责


### 1xx：信息响应，临时响应并需要请求者继续执行操作
100   （Continue - 继续） 到目前为止一切正常，请求者应当继续提出请求。 服务器返回此代码表示已收到请求的第一部分，正在等待其余部分。  
101   （Switching Protocols - 切换协议） 请求者已要求服务器切换协议，服务器已确认并准备切换。
102		（Processing - 正在处理） 正在处理请求，尚无响应。


### 2xx：成功响应
200     （OK - 成功） 成功处理请求。
201     （Created - 正创建） 请求成功并且服务器创建了新资源。 
202     接受请求但没创建资源。
203     返回另一资源的请求。
204     （No Content - 无内容） 服务器成功处理请求，但没有返回任何内容（响应头后没有body数据）。
205     服务器成功处理了请求，但没有返回任何内容。
206     （Partial Content - 部分内容）处理部分请求，当从客户端发送 `Range` 范围标头以只请求资源的一部分时，将使用此响应码。


### 3xx：重定向消息
300   （多种选择）  针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。 
301   （Moved Permanently - 永久移动）  请求资源已永久移动到新URL。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。 
302   （Moved Temporarily - 临时移动）  请求资源临时移动到新URL。服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。 
303   （查看其他位置） 请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。 
304   （Not Modified - 未修改） 自从上次请求后，请求的网页未修改过。服务器返回此响应时，不会返回网页内容。当协商缓存命中时返回此状态码。
305   （使用代理） 请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用代理。 
307   （Temporary Redirect - 临时重定向）  与302状态码相似，用于post请求，它不允许更改http方法
308		 (Permanent Redirect - 永久重定向)	与301状态码相似，用于post请求，它不允许更改http方法


### 4xx：客户端错误响应
400   （Bad Request - 请求错误）服务器无法理解和处理请求，一般为参数错误或请求地址错误。
401   （Unauthorized - 用户未授权）对于需要登录的网页，服务器可能返回此响应，需要用户验证。
403   （Forbidden - 资源访问权限不足）请求者对资源的访问权限不足。
404   （Not Found - 未找到请求资源）找不到请求资源
405   （Method Not Allowed - 方法不允许）禁用请求中指定的方法。服务器知道请求方法，但目标资源不支持该方法。例如，API 可能不允许调用 `DELETE` 来删除资源。
406   无法使用请求的内容特性响应请求的网页。 
407   此状态代码与 401类似，但指定请求者应当授权使用代理。 
408   服务器等候请求时发生超时。 
409   （Conflict - 请求冲突）在请求时发生冲突。当客户端试图执行一个会导致一个或多个资源处于不一致状态的操作时。 
410   （Gone - 所请求资源已移除）由于有意移除，因此请求不再可用
411   服务器不接受不含有效内容长度标头字段的请求。 
412   服务器未满足请求者在请求中设置的其中一个前提条件。 
413   服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。 
414   请求的 URI（通常为网址）过长，服务器无法处理。 
415   请求的格式不受请求页面的支持。 
416   （Requested Range Not Satisfiable - 请求范围不满足）如果页面无法提供请求的范围，则服务器会返回此状态代码。客户端已使用 `Range` 标头请求文件的一部分，但服务器无法提供该部分。当响应中存在 `Accept-Ranges` 字段且不为 `none` 时，表示该服务器支持请求范围请求 
417   服务器未满足”期望”请求标头字段的要求。


### 5xx：服务端错误响应
500   （Internal Server Error - 服务器内部错误）  通用未处理的服务器错误
501   （尚未实施） 服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码。
502   （Bad Gateway - 网关错误） 服务器作为网关或代理，从上游服务器收到无效响应
503   （Service Unavailable - 服务不可用） 服务器暂时无法处理请求（由于超载或停机维护）
504   （Gateway Timeout - 网关超时）  服务器作为网关或代理，但是未及时从上游服务器获得请求。 
505   （HTTP 版本不受支持） 服务器不支持请求中所用的 HTTP 协议版本


### 参考：
- [完整的 HTTP 状态代码列表](https://httpstatuses.com/)
- [HTTP 状态码](http://www.restapitutorial.com/httpstatuscodes.html)
- [Mozilla HTTP 响应状态码](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status)

```



### 连接服务器超时

> - 服务器连接超时就是在程序默认的等待时间内没有得到服务器的响应，可能造成网络连接超时的原因
>   1. 网络断开，不过经常显示无法连接
>   2. 网络阻塞，导致不能在程序默认等待时间内得到回复数据包
>   3. 网络不稳定，网络无法完整传送服务器信息
>   4. 系统问题，系统资源过低，无法为程序提供足够的资源处理服务器信息
>   5. 设备不稳定，如网线松动、接口没插好等等
>   6. 网络注册时系统繁忙，无法回应
>   7. 网速过慢，如使用BT多线程下载，在线收看视频等大量占用带宽的软件，若使用共享带宽还要防范他人恶意占用带宽
>   8. 计算机感染了恶意软件，计算机病毒，计算机木马等

### URL重定向 301/302

```bash
## HTTP URL 重定向 301/302
URL 重定向是一种将网络访问者从一个 URL 地址映射到另一个 URL 地址的 WEB 服务器技术（被映射的URL地址可以跨域）。
当用户访问其浏览器中的某个 URL 时，服务器会发回一条消息，告诉浏览器改为访问其他 URL


### HTTP 重定向的目的
1. 有时以前的域名太长且难以记住，或者某些侵权活动迫使您从一个域转移到另一个域
2. 转发多个域：需要永久 HTTP 重定向将互联网用户和搜索引擎引导到同一位置，同时拥有多个域名。
3. 断开链接的识别：可以使用 Google Search Console 识别 404 未找到的页面。覆盖率报告将为您提供有关所有现场入站链接的详细信息，以便在重定向的帮助下修复。
4. 修复损坏的 URL：识别损坏的链接后，可以将用户访问流量重定向到首页，或将每个损坏的 URL 重定向到具有相同（相似）内容的新页面。
5. 页面的新位置：若以前的网站访问量高且在 SERP 中排名靠前的页面，重定向可将此 URL 映射到新位置。对于这种情况，必须确保用于重定向的旧页面没有消失。
6. 删除页面的需要：为需要删除的所有页面创建 HTTP 重定向，并确保不要因 404 not found 错误而对访问者感到恐惧和压力。重定向将向 Google 或其他搜索引擎发出信号，表明旧链接的链接值应分配给重定向的 URL。


### 常见 URL 重定向类型
  - 301（永久重定向 - Moved Permanently）:旧地址的资源已经被永久删除，搜索引擎在抓取新内容的同时也将旧的网站替换为重定向后的地址，并且告诉浏览器（和搜索引擎）他们将来应该使用新的 URL。
  - 302（临时重定向 - Moved Temporarily）：旧地址的资源还在，这个重定向只是临时从旧地址跳转到新地址，搜索引擎会抓取新的内容且保存旧地址，浏览器和搜索引擎应继续请求原始 URL。


### 301 永久重定向与 302 临时重定向的区别
1、 301重定向可促进搜索引擎优化效果
从搜索引擎优化角度出发，301重定向是网址重定向最为可行的一种办法。当网站的域名发生变更后，搜索引擎只对新网址进行索引，同时又会把旧地址下原有的外部链接如数转移到新地址下，从而不会让网站的排名因为网址变更而收到丝毫影响。同样，在使用301永久性重定向命令让多个域名指向网站主域时，亦不会对网站的排名产生任何负面影响。

2、 302重定向可影响搜索引擎优化效果
迄今为止，能够对302重定向具备优异处理能力的只有Google。也就是说，在网站使用302重定向命令将其它域名指向主域时，只有Google会把其它域名的链接成绩计入主域，而其它搜索引擎只会把链接成绩向多个域名分摊，从而削弱主站的链接总量。既然作为网站排名关键因素之一的外链数量受到影响，网站排名也会降低。
```

![img](./image/http_Redirect.png)

#### 301 与 302 的区别

```bash
## 301 与 302 的区别
### 1. 缓存
对于 301 请求，浏览器会默认给一个很长的缓存。而 302 是不缓存的，只有在 Cache-Control 或 Expires 中进行指定的情况下，这个相应才是可缓存的。


### 2. 搜索引擎
- 301：旧地址A的资源不可访问(永久移除)，重定向到网址B，搜索引擎会抓取网址B的内容，同时将网址保存为B网址。
- 302：旧地址A的资源仍可访问，这个重定向只是临时从旧地址A跳转到B地址，这时搜索引擎会抓取B网址内容，但是会将网址保存为A的。



### 302 导致网址劫持
搜索引擎在大部分情况下，当收到 302 重定向时，有时搜索引擎（尤其是Google）并不能总是抓取目标网址。
比如，有时 A 网址很短，但是它做了一个 302 重定向到 B 网址，而 B 网址是一个很长且杂乱的 URL 网址，甚至还可能包含一些问号之类的参数。此时很显然 A 网址对用户体验感更加友好，这时 Google 很有可能会仍然显示网址 A。
搜索引擎排名算法在遇到 302 重定向时，并不能准确判定哪一个网址更适当，这就造成了网址 URL 劫持的可能性。
即如果一个不道德的人在他自己的网址A做一个302重定向到你的网址B，出于某种原因，Google 搜索结果所显示的仍然是网址A，但是所用的网页内容却是网址B上的内容，这种情况就叫做网址URL劫持。

```



#### 浏览器清除重定向小技巧

- 如果存在 301 重定向无法清除，请打开开发工具勾选 **disable cache** 选项

![image-20220821170941388](./image/image-20220821170941388.png)



## 域名系统 - DNS

```bash
## 域名系统 - DNS
将人类可读的域名映射为机器可读的 IP 地址的系统称为 DNS（域名系统）。



### DNS 解析
由于我们输入的是域名，而数据包是通过 IP 地址传给对方的。因此我们需要得到域名对应的 IP 地址。这个过程需要依赖一个服务系统，这个系统将域名和 IP 一一映射，我们将这个系统就叫做 DNS（域名系统）。得到具体 IP 的过程就是 DNS 解析。
浏览器提供了 DNS 数据缓存功能。即如果一个域名已经解析过，那会把解析的结果缓存下来，下次处理直接走缓存，不需要经过 DNS 解析。
另外，如果不指定端口的话，默认采用对应的 IP 的 80 端口。



### DNS 记录
DNS 由多条不同类型的记录组成，每条记录都有自己的用途。以下是最常用的分类：
  - A 记录 — 地址记录。用于将域名映射到 IPv4 地址。同样，AAAA 记录用于将域名映射到 IPv6 地址。
  - CNAME 记录 — 规范的名称记录。创建指向另一个域或子域的别名，但绝不是 IP 地址。
  - ANAME 记录 — 允许您将域的根指向主机名或域名。
  - TXT 记录 — 允许添加有限的文本注释，通常用于所有权验证、验证或安全目的。
  - MX 记录 — 指定负责接受域的传入和传出电子邮件的邮件服务器。应该指向邮件服务器名称，而不是 IP 地址。
```



## 内容分发网络 - CDN

````bash
## 内容分发网络 CDN（Content Delivery Network）
CDN 的目的是通过在现有的 Internet 中增加一层新的网络架构，将网站的内容发布到最接近用户的网络“边缘”，使用户可以就近取得所需的内容，提高用户访问网站的响应速度。
CDN 比镜像更智能，可理解为：'CDN = 更智能的镜像 + 缓存 + 流量导流'。


### CDN 解决了什么问题？
一般网络请求场景下有下面四个问题：
    1. 带宽限制。
        作为一个服务器，由于受到带宽限制，所能承受的网络并发请求量和连接数是有限的。容易成为服务能力的瓶颈。
    2. 延时和拥塞。
        从客户端发起请求到服务端返回数据，中间会经过很长且复杂的网络环境，如：IDC、骨干网、城域网、接入网等，任何一个环境出现小小的问题都让这个请求发生延迟或拥塞。
    3. 网络运营商跨越问题。
        有时网络请求可能从联通的网络到电信，这个可能会导致网络延迟。
    4. 客户端的网络限流。
        有时客户端的网络状况会有问题，受到终端运行商的共享带宽限制。
 
CDN 可以明显提高 Internet 网络中信息流动的效率。从技术上全面解决了网络带宽小、用户访问量大、网点分布不均等问题，提高用户访问网站的响应速度。	
  

### CDN 流程图
CDN 工作流程是：
    1. 当用户访问已经加入 CDN 服务的网站时，首先通过 DNS 重定向技术确定最接近用户的最佳 CDN 节点，同时将用户的请求指向该节点。
    2. 当用户的请求到达指定节点时，CDN的服务器(节点上的高速缓存)负责将用户请求的内容提供给用户。

具体流程：
    1. 用户在自己的浏览器输入要访问的网站的域名；
    2. 浏览器向本地 DNS 请求对该域名的破解；
    3. 本地 DNS 将请求发到网站的主 DNS；
    4. 主 DNS 根据一系列的策略确定当时最适当的 CDN 节点，并将解析的结果(IP地址)发给用户；
    5. 用户向给定的 CDN 节点请求相应网站的内容。


### CDN 相关技术
CDN 的声线需要依赖多种网络技术的支持，其中主要包括负载均衡技术、动态内容分发与复制技术、缓存技术等。

1. 负载均衡技术
负载均衡技术不仅应用于CDN中，如服务器的负载均衡、网络流量的负载均衡。
网络中的负载均衡就是将网络的流量尽可能均匀分配到几个能完成相同任务的服务器或网络节点上，由此来避免部分网络节点过载。这样既可以提高网络流量，又提高网络的整体性能。
在CDN中，负载均衡又分为服务器负载均衡和服务器全局负载均衡。
服务器负载均衡是指能够在性能不同的服务器之间进行任务分配，既能保证性能差的服务器不成为系统的瓶颈，又能保证性能高的服务器的资源得到充分利用。
而服务器全局负载均衡允许Web网络托管商、门户站点和企业根据地理位置分配内容和服务。通过使用多站点内容和服务来提高容错性和可用性，防止因本地网或区域网络中断、断电或自然灾害而导致的故障。
在CDN的方案中服务器全局负载均衡将发挥重要作用，其性能高低将直接影响整个CDN的性能。


2. 动态分发与复制技术
网站访问响应速度取决于许多因素，如网络的带宽是否有瓶颈、传输途中的路由是否有阻塞和延迟、网站服务器的处理能力及访问距离等。
多数情况下，网站响应速度和访问者与网站服务器之间的距离有密切关系。如果访问者和网站之间的距离过远，它们之间的通信一样需要经过重重的路由转发和处理，网络延误不可避免。
一个有效的方法就是利用内容分发与复制技术，将占网站主体的大部分静态网页、图像和流媒体数据分发复制到各地的加速节点上。


3，缓存技术
一般可通过Web缓存服务来改善用户请求的响应时间，如代理缓存服务、透明代理缓存服务、使用重定向服务的透明代理缓存服务等。
通过Web缓存服务，用户访问网页时可以将广域网的流量降至最低。
	对于公司内联网用户来说，这意味着将内容在本地缓存，而无须通过专用的广域网来检索网页。
	对于Internet用户来说，这意味着将内容存储在他们的ISP的缓存器中，而无须通过Internet来检索网页。
这样无疑会提高用户的访问速度。CDN的核心作用正是提高网络的访问速度。



### CDN 工作原理
CDN 网络是在用户和服务器之间增加 Cache 层，主要通过接管 DNS 实现，将用户的请求引导到 Cache 上获得源服务器的数据，从而降低网络的访问时间。

传统网络的访问流程：
    1. 用户输入访问的域名，操作系统向 LocalDns 查询域名的 IP 地址；
    2. LocalDns 向 Root DNS 查询域名的授权服务器(这里假设 LocalDns 缓存过期)；
    3. ROOT DNS 将域名授权 dns 记录回应给 LocalDns；
    4. LocalDns 得到域名的授权 dns 记录后，继续向域名授权 dns 查询域名的 ip 地址；
    5. 域名授权 dns 查询域名记录后，回应给 LocalDns；
    6. LocalDns 将得到的域名 ip 地址回应给用户端；
    7. 用户得到域名 ip 地址后，访问站点服务器；
    8. 站点服务器应答请求，将内容返回给客户端。

使用 CDN 缓存后的网络访问流程：
    1. 用户输入访问的域名，操作系统向 LocalDns 查询域名的 IP 地址；
    2. LocalDns 向 Root DNS 查询域名的授权服务器(这里假设 LocalDns 缓存过期)；
    3. ROOT DNS 将域名授权 dns 记录回应给 LocalDns；
    4. LocalDns 得到域名的授权 dns 记录后，继续向域名授权 dns 查询域名的 ip 地址；
    5. 域名授权 dns 查询域名记录后(一般是CNAME)，回应给 LocalDns；
    6. LocalDns 得到域名记录后，向智能调度 DNS 查询域名的 IP 地址；
    7. 智能调度 DNS 根据一定的算法和策略(比如静态拓扑、容量等)，将最适合的 CDN 节点 IP 地址回应给 LocalDns；
    8. LocalDns 将得到的域名 IP 地址回应给用户端；
    9. 用户得到域名 IP 地址后，访问站点服务器。
````

> ![image-20230309110016109](./image/image-20230309110016109.png)
> 
> #### 使用 CDN 缓存后的网络结构
> 
> ![image-20230309155713872](./image/image-20230309155713872.png)
> 
> #### 传统的网络结构
> 
> ![image-20230309155756692](./image/image-20230309155756692.png)



## 接口规范 - RESTful架构

#### RESTful接口设计

```bash
## 接口规范 - RESTful 架构
### 什么是 REST
REST（Representational State Transfer：表述性状态转移），REST 指一组架构约束条件和原则。如果一个架构符合 REST 的约束条件和原则就可称它未 RESTful 架构。
RESTful 理念是使用 Web 现有特征和能力更好地使用现有 Web 的现有特征和能力，更好地使用现有 Web 标准中的一些准则和约束。虽然 REST 本身受 Web 技术的影响很深，但是理论上 REST 架构风格并不是绑定在 HTTP 上，只不过目前 HTTP 是唯一与 REST 相关的实例。
```



#### RESTful设计原则

````bash
### Restful 接口规范 
1. 使用HTTP方法来表示资源的操作：使用HTTP方法（GET、POST、PUT、PATCH、DELETE等）来表示对资源的不同操作，如获取资源、创建资源、更新资源、删除资源等。
2. 使用URI来标识资源：使用URI（统一资源标识符）来标识资源，例如：/users/{id} 表示获取指定ID的用户信息。
3. 使用HTTP状态码来表示请求结果：根据不同的操作结果，返回相应的HTTP状态码，如200表示成功、400表示请求错误、404表示未找到资源、500表示服务器错误等。
4. 使用JSON格式来传递数据：使用JSON格式来传递数据，它是一种轻量级的数据交换格式，易于阅读、编写和解析。
5. 使用版本号来管理API：在API的URI中使用版本号来管理API的不同版本，如/v1/users/{id}。
6. 使用安全机制来保护API：使用安全机制（如OAuth、JWT等）来保护API，防止未授权的访问和攻击。
7. 提供文档和示例：提供API文档和示例，方便开发者了解API的使用方式和参数，并且可以提高API的可用性和易用性。

````

#### 资源定位与资源标识符

```bash
### 资源（REST）与 标识符（URI）
REST 全程是表述性装填转移，其表述的是资源。而要让一个资源可以被识别，需要有个唯一标识，在 Web 中这个标识就是 URI（Uniform Resource Identifier）。
URI既可以看成是资源的地址，也可以看成是资源的名称。如果某些信息没有使用URI来表示，那它就不能算是一个资源， 只能算是资源的一些信息而已。URI的设计应该遵循可寻址性原则，具有自描述性，需要在形式上给人以直觉上的关联。

- 使用 `_` 或 `-` 来让URI可读性更好
- 使用 `/` 来表示资源的层级关系
- 使用 `?` 用来过滤资源
- `,` 或 `;` 可以用来表示同级资源的关系

```



#### 统一资源接口

```bash
### 统一资源接口
RESTful 架构应该遵循统一接口原则，统一接口包含了一组受限的预定义的操作，不论什么样的资源，都是通过使用相同的接口进行资源的访问。接口应该使用标准的HTTP方法如GET，PUT和POST，并遵循这些方法的语义。
如果按照HTTP方法的语义来暴露资源，那么接口将会拥有安全性和幂等性的特性，例如GET和HEAD请求都是安全的， 无论请求多少次，都不会改变服务器状态。而GET、HEAD、PUT和DELETE请求都是幂等的，无论对资源操作多少次， 结果总是一样的，后面的请求并不会产生比第一次更多的影响。

即统一资源接口可分为：
- 状态码设计与规范
- 服务器响应规则与格式
- 前后端接口协议指定

  1. GET 请求
      - 安全且幂等
      - 获取表示
      - 变更时获取表示（缓存）
          - 200（OK） - 表示已在响应中发出
          - 204（无内容） - 资源有空表示
          - 301（Moved Permanently） - 资源的URI已被更新
          - 303（See Other） - 其他（如，负载均衡）
          - 304（not modified）- 资源未更改（缓存）
          - 400 （bad request）- 指代坏请求（如，参数错误）
          - 404 （not found）- 资源不存在
          - 406 （not acceptable）- 服务端不支持所需表示
          - 500 （internal server error）- 通用错误响应
          - 503 （Service Unavailable）- 服务端当前无法处理请求
  
  2. POST 请求
      - 不安全且不幂等
      - 使用服务端管理的（自动产生）的实例号创建资源
      - 创建子资源
      - 部分更新资源
      - 如果没有被修改，则不会更新资源（乐观锁）
          - 200（OK）- 如果现有资源已被更改
          - 201（created）- 如果新资源被创建
          - 202（accepted）- 已接受处理请求但尚未完成（异步处理）
          - 301（Moved Permanently）- 资源的URI被更新
          - 303（See Other）- 其他（如，负载均衡）
          - 400（bad request）- 指代坏请求
          - 404 （not found）- 资源不存在
          - 406 （not acceptable）- 服务端不支持所需表示
          - 409 （conflict）- 通用冲突
          - 412 （Precondition Failed）- 前置条件失败（如执行条件更新时的冲突）
          - 415 （unsupported media type）- 接受到的表示不受支持
          - 500 （internal server error）- 通用错误响应
          - 503 （Service Unavailable）- 服务当前无法处理请求

  3. PUT 请求
      - 不安全但幂等
      - 用客户端管理的实例号创建一个资源
      - 通过替换的方式更新资源
      - 如果未被修改，则更新资源（乐观锁）
            - 200 （OK）- 如果已存在资源被更改
            - 201 （created）- 如果新资源被创建
            - 301（Moved Permanently）- 资源的URI已更改
            - 303 （See Other）- 其他（如，负载均衡）
            - 400 （bad request）- 指代坏请求
            - 404 （not found）- 资源不存在
            - 406 （not acceptable）- 服务端不支持所需表示
            - 409 （conflict）- 通用冲突
            - 412 （Precondition Failed）- 前置条件失败（如执行条件更新时的冲突）
            - 415 （unsupported media type）- 接受到的表示不受支持
            - 500 （internal server error）- 通用错误响应
            - 503 （Service Unavailable）- 服务当前无法处理请求

  4. DELETE 请求
      - 不安全但幂等
      - 删除资源
          - 200 （OK）- 资源已被删除
          - 301 （Moved Permanently）- 资源的URI已更改
          - 303 （See Other）- 其他，如负载均衡
          - 400 （bad request）- 指代坏请求
          - 404 （not found）- 资源不存在
          - 409 （conflict）- 通用冲突
          - 500 （internal server error）- 通用错误响应
          - 503 （Service Unavailable）- 服务端当前无法处理请求

- POST和PUT用于创建资源时有什么区别？
POST 和 PUT 在创建资源的区别在于所创建的资源的名称（URI）是否由客户端决定。

- 客户端不一定都支持这些HTTP方法吧?
在一些比较古老的基于浏览器的客户端只能支持 GET 和 POST 两种方法。但通常在兼容时都会通过隐藏参数 _method=DELETE 等来传递真实的请求方法，并且可设置 X-HTTP-Method-Override头来规避这个问题。

- 统一接口是否意味着不能扩展带特殊语义的方法?
统一接口并不阻止你扩展方法，只要方法对资源的操作有着具体的、可识别的语义即可，并能够保持整个接口的统一性。


- 统一资源接口对URI有什么指导意义?
统一资源接口要求使用标准的HTTP方法对资源进行操作，所以URI只应该来表示资源的名称，而不应该包括资源的操作。


通俗来说，URI不应该使用动作来描述。例如，下面是一些不符合统一接口要求的URI:
    GET /getUser/1
    POST /createUser
    PUT /updateUser/1
    DELETE /deleteUser/1

- 如果GET请求增加计数器，这是否违反安全性?
安全性不代表请求不产生副作用，例如像很多API开发平台，都对请求流量做限制。像github，就会限制没有认证的请求每小时只能请求60次。
但客户端不是为了追求副作用而发出这些GET或HEAD请求的，产生副作用是服务端"自作主张"的。
另外，服务端在设计时，也不应该让副作用太大，因为客户端认为这些请求是不会产生副作用的。

- 直接忽视缓存可取吗?
即使你按各个动词的原本意图来使用它们，你仍可以轻易禁止缓存机制。 最简单的做法就是在你的HTTP响应里增加这样一个报头： Cache-control: no-cache。 但是，同时你也对失去了高效的缓存与再验证的支持(使用Etag等机制)。
对于客户端来说，在为一个REST式服务实现程序客户端时，也应该充分利用现有的缓存机制，以免每次都重新获取表示。

- 响应代码的处理有必要吗?
HTTP的响应代码可用于应付不同场合，正确使用这些状态代码意味着客户端与服务器可以在一个具备较丰富语义的层次上进行沟通。
例如 201（"Created"）响应代码表明已经创建一个新的资源，其 URI 在 Location 响应报头里。
假如你不利用 HTTP 状态代码丰富的应用语义，那么你将错失提高重用性、增强互操作性和提升松耦合性的机会。
如果这些 RESTful 应用必须通过响应实体才能给出错误信息，那么 SOAP 就是这样的了，它就能够满足了。
```

#### 资源的表述

```bash
### 资源的表述
资源的表述包括数据和描述数据的元数据，例如，HTTP头"Content-Type" 就是这样一个元数据属性。
客户端可以通过HTTP内容协商来知道服务端提供哪种表述形式。客户端可以通过Accept头请求一种特定格式的表述，服务端则通过Content-Type告诉客户端资源的表述形式。

1. 在URI里边带上版本号
2. 使用URI后缀来区分表述格式
3. 如何处理不支持的表述格式
```

#### 资源的链接

```bash
### 资源的链接

```

#### 状态的转移

```bash
### 状态的转移

```



## 登录鉴权

```bash
## 登录鉴权
1. 用户认证（Authentication）
		- 验证当前用户的身份。
				- 用户名密码登录
				- 邮箱发送登录连接
				- 手机/邮箱验证码登录


2. 用户授权（Authorization）
    - 用户授予第三方应用访问该用户某些资源的权限。如在安装应用时，APP 会询问是否允许授予权限（访问相册、地理位置等权限）
    - 实现授权的方式有：`cookie、session、token、OAuth`


3. 凭证（Credentials）
		- 实现认证和授权的前提时需要一种媒介（证书）来标记访问者的身份。
		- 一般应用会存在两种模式：游客模式和登录模式。游客模式可正常浏览，但如果需要操作某些功能，则需要登录或注册账号。当用户登录成功后，服务器会给该用户使用的浏览器颁发一个令牌（token），这个令牌用来表明你的身份，每次浏览器发送请求时会带上这个令牌，就可以使用游客模式下无法使用的功能。
		
```

### Cookie

```bash
## Cookie
- HTTP 是无状态的协议（对于事务处理没有记忆能力，每次客户端和服务端会话完成时，服务端不会保存任何会话信息）：每个请求都是完全独立的，服务端无法确认当前访问者的身份信息，无法分辨上一次的请求发送者和这一次的发送者是不是同一个人。所以服务器与浏览器为了进行会话跟踪（知道是谁在访问我），就必须主动的去维护一个状态，这个状态用于告知服务端前后两个请求是否来自同一浏览器。而这个状态需要通过 cookie 或者 session 去实现。

- cookie 临时存储：cookie 默认是临时存储的，当浏览器关闭进程的时候自动销毁，要想长时间保存一个 cookie，就需要设置 cookie 的过期时间。
- cookie 存储在客户端：当 Web 服务器创建 cookie 后，只要在其有效期内，用户访问同一个 Web 服务器时，浏览器首先检查本地的 Cookie，并将其原样发给 Web 服务器。cookie 是保持 web 浏览状态的手段。
- cookie 不可跨域：每个 cookie 都会绑定单一的域名，无法在别的域名下获取使用，一级域名和二级域名之间是允许共享使用的（依靠设置相同的 domain）。


### Cookie 的特点
1. cookie保存在浏览器本地，只要不过期关闭浏览器也会存在。
2. 正常情况下cookie不加密，用户可轻松看到
3. 用户可以删除或者禁用cookie
4. cookie可以被篡改
5. cookie可用于攻击
6. cookie存储量很小，大小一般是4k
7. 发送请求自动带上登录信息



### cookie 的工作过程
cookie 是存放在浏览器中的，在每一个浏览器浏览器安装目录下，都存在一个文件夹，存放着不同域下对应的cookie。
当浏览器通过 http 请求某一个域时，此时浏览器会先检查相应域是否有 cookie，有则自动添加在请求头中的 cookie 字段中。
注意：浏览器自动帮我们携带，此时如果有很多无关紧要的数据都存放在 cookie 中，都会随着请求发送给服务端，这样就无形中增加了网络开销。
但如身份认证信息这些数据在每一次请求都需要携带发给服务端，此时使用 cookie 就可以大大减少重复添加身份认证信息到请求中的操作，就会比较适合，至于其他信息都不适合。
    1. 首先，假设当前域名下还是没有 cookie 的
    2. 接下来，浏览器发送了一个请求给服务器(这个请求是还没带上 cookie 的)
    3. 服务器设置 cookie 并发送给浏览器(当然也可以不设置)
    4. 浏览器将 cookie 保存下来
    5. 接下来，以后每一次请求都会带上这些 cookie 发送给服务器


### cookie 的特征
1. 不同的浏览器存放的 cookie 位置不一样，也是不能通用的。
2. cookie 的存储是以域名形式进行区分的，在同一个浏览器下不同的域名下存储的 cookie 是独立的。
3. cookie 也可以设置过期事件，默认是会话结束时，当时间到期自动销毁。
4. 一个浏览器能创建的 cookie 数量最多为 300 个，并且每个域下的 cookie 不能超过 4KB，每个Web站点能设置的 cookie 总数不能超过 20 个。
5. 可设置 cookie 生效的域(当前设置cookie 所在域的子域)，即我们能够操作的 cookie 是当前域以及当前域下的所有子域。
6. cookie 必须在 HTML 文件的内容输出之前设置，如果用户在浏览器上设置了禁止 cookie，则 cookie 不能建立。
7. cookie 设置的属性是需要在每一个属性后面需要跟一个分号和空格。
		"key=name; expires=Thu, 25 Feb 2016 04:18:00 GMT; domain=ppsc.sankuai.com; path=/; secure; HttpOnly"


### cookie 的设置
1. 在客户端设置
    document.cookie = '名字=值'
    document.cookie = 'username=willy; domain=baike.baidu.com' // 并且设置了生效域
注意：客户端可以设置cookie的下列选项：expires、domain、path、secure（只有在https协议的网页中，客户端设置secure类型的cookie才能成功），但无法设置 HttpOnly 选项。


2. 在服务端设置
   http响应头中 `Set-Cookie` 字段是专门设置 cookie 的：
   		`Set-Cookie: value[; expires=date][; domain=domain][; path=path][; secure]`
   一个 Set-Cookie 字段只能设置一个 cookie，当想要设置多个 cookie 则需要添加多个 Set-Cookie 字段。
   服务端可以设置 cookie 的所有选项：expires、domain、path、secure、HttpOnly。通过 Set-Cookie 指定这些可选项只会在浏览器端使用，而不会被发送至服务端。


### 使用 cookie 注意问题
- 因为存储在客户端，容易被客户端篡改，使用前需要验证合法性。
- 不要存储敏感数据，比如用户密码，帐户余额等。
- 使用 httpOnly 可在一定程度上提高安全性。
- 尽量减少 cookie 的体积，能存储的数据量不能超过 4kb。
-  需要设置正确的 domain 和 path，减少数据传输。
- cookie 无法跨域。
- 一个浏览器针对一个网站最多存储 20 个 cookie，浏览器一般只允许存放 300 个 cookie。
- 移动端对 cookie 的支持不是很好，而 session 需要基于 cookie 实现，所以移动端常用的是 token。
```

#### cookie 属性

```bash
### name=value
- 键值对，设置 `Cookie` 的名称及相对应的值都必须是字符串类型。
- 如果值为 Unicode 字符，需要为字符编码。如果值为二进制数据则需要使用 `BASE64` 编码。


### expires 属性
- expires 属性表示 cookie 的过期时间，超出这个时间点后该 cookie 会自动失效，使用GMT表示。
  	常用 `Date.toUTCString()` 和 `Date.toGMTString()` 来获取时间。
  	console.log(new Date().toUTCString()) // 'Thu, 02 Mar 2023 06:53:51 GMT'
  	console.log(new Date().toGMTString())	// 'Thu, 02 Mar 2023 06:53:51 GMT'
- 如果在新增 cookie 时没有增加 expires 属性，则表示会话阶段，在浏览器关闭时 cookie 会被删除。


### max-age 属性
- expires 是在 http1.0 中的属性，在 http1.1 中新增了 max-age。
- max-age 表示从当前创建开始，到 cookie 过期的时间，单位秒，默认为 -1。
- max-age 可以为三个值，一个负值，0，正值。
  	1. 当 max-age 为负数时，表示 cookie 为会话 cookie，关闭浏览器即失效，浏览器也不会以任何形式保存该 cookie。
  	2. 当 max-age 为 0 时，表示删除该 cookie。
  	3. 当 max-age 为正数时，则该 cookie 在 maxAge 秒后失效，则 expires = max-age + 当前时间。


### cookie 的域(domain)
- domain 指定 cookie 将要被发送至哪个或那些域中。
- 默认情况下，domain 会被设置为创建该 cookie 的页面所在的域名，所以当给相同域名发送请求时该 cookie 会被发送至服务器。
- 浏览器会把 domain 的值与请求的域名做一个尾部比较(即从字符串的尾部开始比较)，并将 domain 能匹配到的域名的 cookie 发送至服务器。
- 如果设置为 /abc，则只有 /abc 下的路由可以访问到该 cookie，如：/abc/read。

  1. 客户端设置
      `document.cookie = "username=willy; path=/; domain=qq.com"`
     上述是将 domain 设置为 qq.com，表示访问域名尾部是 qq.com 的网站时浏览器会将该 cookie 带上。
          path 值为 "/" 表示访问 qq.com 域名下的根目录下的都将能带上该 cookie。

  2. 服务端设置
      `Set-Cookie: username=willy; path=/; domain=qq.com`
      注意：一定时候同域名之间的访问，不能将 domain 的值设置成非主域的域名。



### cookie 的路径(path)
因为安全方面考虑，默认情况下，只有与创建 cookie 的页面在同一个目录或子目录下的网页才可以访问。但 path 属性可以为 cookie 指定路径，domain 和 path 加起来构成 URL，表示当浏览器在访问该 URL 下的网站或者 URL 带有这个前缀的网站都将会带上该 cookie。
  1. 客户端设置
     `document.cooke='username=willy; path=/'`
     让 cookie 在根目录下，这样不管是哪个子页面创建的 cookie，该域名下的所有页面都可以访问到。

  2. 服务端设置
     `Set-Cookie: name=willy; path=/blog`
     如上设置，path 选项值会与任何以 /blog 开发的选项匹配(如：/blog，/blogrool 等)
     需要注意，只有在 domain 选项核实完毕之后才会对 path 属性进行比较。
     path 属性的默认值是发送 Set-Cookie 消息头所对应的 URL 中的 path 部分。

  3. domain 和 path 总结：
     domain 是域名，path 是路径，两者结合构成 URL，domain 和 path 一起来限制 cookie 能被哪些 URL 访问。
     所以 domain 和 path 两个选项共同决定了 cookie 何时被浏览器自动添加到请求头中发送出去。
     如果没有设置这两个选项，则会使用默认值。domain 的默认值为设置该 cookie 的网页所在的域名，path 默认值为设置该 cookie 的网页所在的目录。
     如 `document.cooke='name=willy; domain=baidu.com; path=/'`，当浏览器访问域名为 `api.baidu.com` 或 `baidu.com` 时携带 cookie，当 url 为任何值均携带 cookie。
     注意：xhr 请求默认不会携带 cookie。


### secure
- secure 是保证网络请求安全的，是否仅被使用安全协议传输。默认为false。
- 如果设置 cookie 的 secure 为 true，则在网络上传输数据之前先将数据加密，发送的请求必须使用安全协议传输（https、SSL 等安全协议）。
- 当 secure 值为 true 时，cookie 在 HTTP 中是无效，在 HTTPS 中才有效。


### httpOnly
- 在设置 cookie 时默认 httpOnly 为空，如果给某个 cookie 设置了 httpOnly 属性，则无法通过 JS 脚本操作到该 cookie 的信息（删改查），但还是能通过 Application 中手动修改 cookie，所以只是在一定程度上可以防止 XSS 攻击，不是绝对的安全。
- 不是绝对安全的原因：如果在某一个用户登录过的网站，其 cookie 没有设置 httpOnly，则当用户受到 xss 攻击(跨站脚本攻击)时，其会注入一段 JS 脚本，如果这个脚本读取的是用户的 cookie，并且将该 cookie 发送给攻击者，则用户信息泄露，攻击者可以拿到该用户登录信息模拟用户登录，造成用户不安全。
```



#### JS 操作 cookie

```bash
### JS 操作 cookie
1. 创建 cookie
   - 默认情况，cookie在浏览器关闭时删除
     	`document.cookie="username=willy"`
   - 添加过期时间(以UTC或GMT为准)
     	`document.cookie="username=willy; expires=Thu, 18 Dec 2043 12:00:00 GMT"`	
   - 添加浏览器 cookie 的路径。默认情况，cookie 属于当前页面
     	`document.cookie="username=willy; expires=Thu, 18 Dec 2043 12:00:00 GMT; path=/"`
   - 设置多个 cookie
     	如 `document.cookie="name=willy; age=20; sex:man;` 只能设置成功一个`name=willy;`，其他都是无效的。
     	需要分开去设置 cookie。


2. 读取 cookie
   通过 document.cookie 能获取当前网站下非定义 httpOnly 属性的全部 cookie。
   获取到的值为 key=value 形式组成的字符串，并且在每一个 value 与下一个 key 之间使用分号和空格隔开。
   	`const getCookie = document.cookie`	// 假设获取结果：`username=willy; job=coding`


3. 修改/删除 cookie
   修改：直接进行赋新值，不过必须保证domain/url属性不变，如果改变则直接新增一个。
   删除：直接赋新值，不过必须保证domain/url属性不变，并且将expires的时间设置为过去的时间。
   注意：
   在 cookie 中只有 key、domain、path 都相同时，才能进行覆盖。
   在设置 domain 的 value 设置多个点，则任何子域名都可以访问；如果不设置点，则只有该 domain 才能访问。

```

#### node 操作 cookie

```bash
## node 操作 cookie （服务端）
1. 安装
$ pnpm install cookie-parser --save


2. 引入
const cookieParser = require("cookie-parser")


3. 设置中间件
app.use(cookieParser())


4. 设置 cookie
res.cookie("name", 'willy', { maxAge: 1000*60*60, httpOnly: true })
// res.cookie(名称,值,{配置信息})


5. 获取 cookie
req.cookies.name

```

```js
const express = require("express")
const cookieParser = require("cookie-parser")

const app = express()

// 设置中间件
app.use(cookieParser())

app.get("/", (req, res) => {
  res.send("首页")
})

// 设置cookie
app.get("/set", (req, res) => {
  // 如果不进行任何设置,有效期默认为1个会话，浏览器关闭即失效
  // res.cookie('isLogin','true')
  res.cookie("userName", '张三', { maxAge: 1000 * 60 * 60, httpOnly: true })
  res.send("设置cookie成功")
})

// 获取cookie
app.get("/get", (req, res) => {
  res.send("获取cookie成功，cookie为: " + req.cookies.userName)
})

app.listen(8080)

```



#### cookie、sessionStorage、localStorage

```bash
## cookie、sessionStorage、localStorage 的区别
相同点：都存储在客户端，在所有同源窗口中都是共享的，并且不会失效，不管窗口或浏览器关闭与否都会始终生效。

不同点：
  1. 存放的数据大小：
      - cookie 数据大小不能超过 4KB；
      - sessionStorage和localStorage 存储的数据大小可以达到 5MB+。
      
  2. 数据的生命周期
      - cookie：若不设置过期时间，则视为会话，关闭浏览器后丢失；
      					若设置时间，则在设置的过期时间之前一直有效，即使窗口或浏览器关闭。
      - session：是一个会话，当页面不同，即使同一页面打开两次也被视为同一次会话。
      - sessionStorage：数据仅在当前浏览器窗口关闭前有效。
      - localStorage：永久存储，浏览器关闭后如果不主动删除数据都不会丢失掉。
      
  3. 与服务器通信
      - cookie 的数据会携带在 http 头中自动传递到服务器；但如果使用 cookie 保存过多数据会带来性能问题。
      - sessionStorage和localStorage 数据只能保存在本地。
      
	4. 易用性
			- cookie 需要自己封装，源生的 cookie 接口不友好。
			- sessionStorage和localStorage 源生接口可接受，也可再次封装对 Object和Array有更好的支持。
			
	5. 应用场景
			从安全性来说，因为每次 http 请求都会携带 cookie 信息，这样会浪费带宽，所以 cookie 应该尽可能地少用。
			此外，cookie 还需要指定作用域，不可以跨域调用，限制很多。
			但是用户识别用户登录来说，cookie 还是比 storage 好用，其他情况可以使用 sessionStorage。
			localStorage 可以用来在页面传递参数。
			sessionStorage 可以用来保存一些临时的数据，防止用户刷新页面后丢失了一些参数。
```

![image-20211027104432156](./image/image-20211027104432156.png)



#### sessionStorage 同一网站下共享问题

```bash
## sessionStorage 同一网站下共享问题
以下情况是以同源为前提的。并不是所有的 sessionStorage 都能共享。

1. 第一种情况：
浏览器中打开 A 页面，再通过 A 页面打开新的标签页 B 页面，此时 A、B 两个页面的 sessionStorage 是共享的。
这里的共享是指 B 页面会把 A 页面中的 sessionStorage 拷贝一份，作为 B 页面的初始缓存值，此时改变 B 页面的 session，A 页面并不受影响。即不同 Tab 页之间 session 读写操作独立，互不影响。

2. 第二种情况：
浏览器中打开 A 页面，然后手动新开一个标签页，在新的标签页中打开 B 页面，此时 A、B 两个页面的 sessionStorage 是不共享的。即 B 页面不会继承 A 页面 session 作为初始值。
新开一个标签页总是会初始化一个 session，即使是同一个网站。

```



### Session 状态管理

```bash
## Session 状态管理
- Session 是记录客户状态的机制。当客户端浏览器访问服务端时，服务器把客户端信息以某种形式记录在服务器上，客户端浏览器再次访问时只需要从该 Session 中查找该客户的状态即可。
- 与 Cookie 不同的是 Cookie 保存在客户端浏览器中，而 Session 保存在服务器上。
- 使用 Session 的原因：由于 Cookie 是存在用户端，而且它自身存储的大小有限、对用户可见、可随意修改，所以十分不安全。


### Session 认证流程：
- 用户第一次请求服务器时，服务器根据用户提交的相关信息，创建对应的 Session
- 请求返回时将此 Session 的唯一标识信息 SessionID 返回给浏览器
- 浏览器接收到服务器返回的 SessionID 信息后，会将此信息存入到 Cookie 中，同时 Cookie 记录此 SessionID 属于哪个域名
- 当用户第二次访问服务器的时候，请求会自动判断此域名下是否存在 Cookie 信息，如果存在自动将 Cookie 信息也发送给服务端，服务端会从 Cookie 中获取 SessionID，再根据 SessionID 查找对应的 Session 信息，如果没有找到说明用户没有登录或者登录失效，如果找到 Session 证明用户已经登录可执行后面操作。

根据以上流程可知，SessionID 是连接 Cookie 和 Session 的一道桥梁，大部分系统也是根据此原理来验证用户登录状态。

```

![image-20220620212335597](./image/dacfa03c50bd2e7d2225a7cd3e61291d5da00f63.png)

![session](./image/29cfe2cc7bd13bc659227e62c3e89063.png)

#### Cookie 和 Session 的区别

```bash
### Cookie 和 Session 的区别
- **安全性**： Session 比 Cookie 安全，Session 是存储在服务器端的，Cookie 是存储在客户端的。
- **存取值的类型不同**：Cookie 只支持存字符串数据，想要设置其他类型的数据，需要将其转换成字符串，Session 可以存任意数据类型。
- **有效期不同**： Cookie 可设置为长时间保持，比如我们经常使用的默认登录功能，Session 一般失效时间较短，客户端关闭（默认情况下）或者 Session 超时都会失效。
- **存储大小不同**： 单个 Cookie 保存的数据不能超过 4K，Session 可存储数据远高于 Cookie，但是当访问量过多，会占用过多的服务器资源。

```



#### express-session

##### 参数

```js
const option = {
  cookie: {
    // Cookie Options
    // 默认为{ path: '/', httpOnly: true, secure: false, maxAge: null }
    /** maxAge: 设置给定过期时间的毫秒数（date）
  * expires: 设定一个utc过期时间，默认不设置，http>=1.1的时代请使用maxAge代替之（string）
  * path: cookie的路径（默认为/）（string）
  * domain: 设置域名，默认为当前域（String）
  * sameSite: 是否为同一站点的cookie（默认为false）（可以设置为['lax', 'none', 'none']或 true）
  * secure: 是否以https的形式发送cookie（false以http的形式。true以https的形式）true 是默认选项。 但是，它需要启用 https 的网站。 如果通过 HTTP 访问您的站点，则不会设置 cookie。 如果使用的是 secure: true，则需要在 express 中设置“trust proxy”。
  * httpOnly: 是否只以http(s)的形式发送cookie，对客户端js不可用（默认为true，也就是客户端不能以document.cookie查看cookie）
  * signed: 是否对cookie包含签名（默认为true）
  * overwrite: 是否可以覆盖先前的同名cookie（默认为true）*/
  },

  // 默认使用uid-safe这个库自动生成id
  genid: req => genuuid(),  

  // 设置会话的名字，默认为connect.sid
  name: 'value',  

  // 设置安全 cookies 时信任反向代理（通过在请求头中设置“X-Forwarded-Proto”）。默认未定义（boolean）
  proxy: undefined,

  // 是否强制保存会话，即使未被修改也要保存。默认为true
  resave: true, 

  // 强制在每个响应上设置会话标识符 cookie。 到期重置为原来的maxAge，重置到期倒计时。默认值为false。
  rolling: false,

  // 强制将“未初始化”的会话保存到存储中。 当会话是新的但未被修改时，它是未初始化的。 选择 false 对于实现登录会话、减少服务器存储使用或遵守在设置 cookie 之前需要许可的法律很有用。 选择 false 还有助于解决客户端在没有会话的情况下发出多个并行请求的竞争条件。默认值为 true。
  saveUninitialized: true,

  // 用于生成会话签名的密钥,必须项  
  secret: 'secret',

  // 会话存储实例，默认为new MemoryStore 实例。
  store: new MemoryStore(),

  // 设置是否保存会话，默认为keep。如果选择不保存可以设置'destory'
  unset: 'keep'
}
```

##### 方法

```bash
- .regenerate(callback)
要重新生成会话，只需调用该方法。 完成后，将在 req.session 处初始化一个新的 SID 和 Session 实例，并调用回调。

- .destroy(callback)
销毁会话并取消设置 req.session 属性。 完成后，将调用回调。

- .reload(callback)
从存储重新加载会话数据并重新填充 req.session 对象。 完成后，将调用回调。

- .save(callback)
将会话保存回 store，用内存中的内容替换 store 上的内容。
如果会话数据已更改，则在 HTTP 响应结束时自动调用此方法。
在某些情况下调用此方法很有用，例如重定向、long-lived 请求或在 WebSockets 中。

- .touch()
更新 .maxAge 属性。 通常不需要调用，因为会话中间件会为您执行此操作。
```

##### 存储 Session 的 Store

```bash
store.all(callback)
此可选方法用于将存储中的所有会话作为数组获取。 callback中第一个为error，第二个是sessions。

store.destroy(sid, callback)
这个必需的方法用于在给定会话 ID (sid) 的情况下从存储中销毁/删除会话。 callback的对象为error。

store.clear([callback])
此方法用于从存储中删除所有会话.callback的对象为error。

store.length(callback)
此方法用于获取商店中所有会话的数量。 callback中第一个为error，第二个是len。

store.get(sid, callback)
这个方法第一个参数为会话 ID (sid) 。 callback中第一个为error，第二个是session。
找不到不会错误，而是在session返回null 或 undefined。

store.set(sid, session, callback)
这个方法用于新建或修改session 保存在store中。 callback的对象为error。

store.touch(sid, session, callback)
这个方法用给定会话 ID (sid) 和会话 (session)来“touch”对应的session。callback的对象为error。
这主要用于当存储将自动删除空闲会话并且此方法用于向存储发出信号给定会话处于活动状态时，可能会重置空闲计时器。
```



##### 示例

```js
const express = require('express')
const session = require('express-session')
const MongoStore = require('connect-mongo')

const app = express()

// 配置中间件
// session会自带一个httpOnly
app.use(
  session({
    name: 'session-id',
    secret: 'this is session', // 服务器生成 session 的签名
    resave: true, // 每次是否都刷新到期时间
    saveUninitialized: true, // 强制将为初始化的 session 存储(该session_id是没有用的)
    cookie: {
      maxAge: 1000 * 60 * 10, // 过期时间
      secure: false, // 为 true 时候表示只有 https 协议才能访问cookie
    },
    // 自动在mongodb中创建一个数据库存储session，并且过期时间也会同步刷新
    store: MongoStore.create({
      mongoUrl: 'mongodb://127.0.0.1:27017/ds2_session',
      ttl: 1000 * 60 * 10, // 过期时间
    }),
  }),
)

// 授权中间件，在这个之后的路由，除了错误处理，都是需要授权的。
app.use((req, res, next) => {
  // 排除login相关的路由和接口（因为login就不需要重定向到login了）
  if (req.url.includes('login')) {
    next()
    return
  }
  if (req.session.user) {
    // 重新设置以下sesssion
    req.session.mydate = Date.now() // 加这个设置才能访问刷新过期时间
    next()
  } else {
    // 是接口, 就返回错误码
    // 不是接口，就重定向（因为ajax请求是不能重定向的，只能前端接收错误码做处理）
    req.url.includes('api')
      ? res.status(401).json({ ok: 0 })
      : res.redirect('/login')
  }
})

// 设置session
app.use('/login', (req, res) => {
  req.session.userinfo = '张三'
  res.send('登陆成功！')
})

// 注销session
app.use('/loginOut', (req, res) => {
  req.session.destroy((err) => {
    res.send('退出登录！' + err)
  })
})

// 获取session
app.use('/', (req, res) => {
  if (req.session.userinfo) {
    res.send('hello ' + req.session.userinfo + ', welcome')
  } else {
    res.send('未登陆')
  }
})

app.listen(8080)
```



### Token 令牌认证

```bash
### Acesss Token
- 访问资源接口（API）时所需要的资源凭证
- 简单 token 的组成：uid(用户唯一的身份标识)、time(当前时间的时间戳)、sign（签名，token 的前几位以哈希算法压缩成的一定长度的十六进制字符串）
- 特点：
    - 服务端无状态化、可扩展性好
    - 支持移动端设备
    - 安全
    - 支持跨程序调用


- token 的身份验证流程：
    1. 客户端使用用户名跟密码请求登录
    2. 服务端收到请求，去验证用户名与密码
    3. 验证成功后，服务端会签发一个 token 并把这个 token 发送给客户端
    4. 客户端收到 token 后会把它存储起来，比如放在 cookie 里或者 localStorage 里
    5. 客户端每次向服务端请求资源时需要携带服务端签发的 token
    6. 服务端收到请求后去验证客户端请求中携带的 token ，如果验证成功，就向客户端返回请求的数据

- 请求中 token 的携带：
    - 每一次请求都需要携带 token，需要把 token 放到 HTTP 的 Header 里
    - 基于 token 的用户认证是一种服务端无状态的认证方式，服务端不用存放 token 数据。用解析 token 的计算时间换取 session 的存储空间，从而减轻服务器的压力，减少频繁的查询数据库
    - token 完全由应用管理，所以它可以避开同源策略
```

![image-20221107232241864](./image/8ac75ad617c60df2eadc8ee51e25309f9bff4bd2.png)

#### Token 和 Session 的区别

```bash
Session 是一种记录服务器和客户端会话状态的机制，使服务端有状态化，可以记录会话信息。而 Token 是令牌，访问资源接口（API）时所需要的资源凭证。Token 使服务端无状态化，不会存储会话信息。

作为身份认证 Token 安全性比 Session 好，因为每一个请求都有签名还能防止监听以及重放攻击，而 Session 就必须依赖链路层来保障通讯安全。可以通过增加 Session 来在服务器端保存一些状态，来实现 Token 有状态。

Session 认证只是简单地把 User 信息存储到 Session 里，因为 SessionID 的不可预测性，暂且认为是安全的。而 Token ，如果指的是 OAuth Token 或类似的机制提供的是 认证 和 授权 ，认证是针对用户，授权是针对 App 。其目的是让某 App 有权利访问某用户的信息。这里的 Token 是唯一的，不可以转移到其它 App上，也不可以转到其它用户上。Session 只提供一种简单的认证，即只要有此 SessionID ，就可以认为有此 User 的全部权利。是需要严格保密的，这个数据应该只保存在站方，不应该共享给其它网站或者第三方 App。

简单来说：如果你的用户数据可能需要和第三方共享，或者允许第三方调用 API 接口，用 Token 。如果永远只是自己的网站或 App，则可以无要求。
```



#### 无感知刷新 Token

```bash
refresh token 是专用于刷新 access token 的 token。如果没有 refresh token，也可以刷新 access token，但每次刷新都要用户输入登录用户名与密码，会很麻烦。而 refresh token，可以减少这个麻烦，客户端直接用 refresh token 去更新 access token，无需用户进行额外的操作。

Access Token 的有效期比较短，当 Acesss Token 由于过期而失效时，使用 Refresh Token 就可以获取到新的 Token，如果 Refresh Token 也失效，则用户就只能重新登录。

Refresh Token 及过期时间是存储在服务器的数据库中，只有在申请新的 Acesss Token 时才会验证，不会对业务接口响应时间造成影响，也不需要向 Session 一样一直保持在内存中以应对大量的请求。
```

![image-20221107232317906](./image/3eae487e7388066531659df5637a0b6af29007b9.png)



### JWT 认证

```bash
- JWT（JSON Web Token）是一种用于在网络应用间传递信息的开放标准（RFC 7519），它通过对JSON对象进行数字签名来实现信息的安全传输。
- JWT 的声明一般被用来在身份提供者和服务提供者间传递被认证的（用户身份信息），以便于从资源服务器获取资源。比如用在用户登录上。
- JWT通常用于身份验证和授权机制，可以在不需要再次验证用户身份的情况下传递用户信息。
- 在前端中，通常会使用现成的JWT库来进行JWT的生成、解析和验证，以此简化 JWT 的使用和处理过程。常见的JWT库有jsonwebtoken和jsrsasign等。
- [JWT官网](https://jwt.io/)


### JWT 的组成
- JWT 由三部分组成：头部（Header）、载荷（Payload）和签名（Signature）。
    1. 头部（Header）：包含关于生成该 JWT 的信息以及所使用的算法类型。
    2. 载荷（Payload）：包含要传递的数据，如身份信息和其他附属数据。JWT 官方规定以下 7 个字段可供使用：
        1. iss (Issuer)：签发者。
        2. sub (Subject)：主题。
        3. aud (Audience)：接收者。
        4. exp (Expiration time)：过期时间。
        5. nbf (Not Before)：生效时间。
        6. iat (Issued At)：签发时间。
        7. jti (JWT ID)：编号。
    3. 签名（Signature）：使用密钥对头部和载荷进行签名，以验证其完整性。


### 前端使用JWT通常需要进行以下步骤：
1. 客户端发送用户名和密码给服务器进行验证。
2. 服务器验证通过后，生成JWT并将其返回给客户端（将包含用户信息的数据作为JWT的Payload，将其与JWT Header分别进行Base64编码拼接后签名，形成一个JWT Token，形成的JWT Token就是如同 lll.zzz.xxx 的字符串 服务端将JWT Token字符串作为登录成功的结果返回给客户端）
3. 客户端将JWT保存在本地（通常使用localStorage或sessionStorage保存），退出登录时删除保存的JWT。
4. 客户端在每次请求时将JWT添加到请求头中（通常放在 http 头的 "Authorization" 属性中，需要解决XSS和XSRF问题）。
5. 服务器在接收到请求时，需要验证JWT的有效性和签名是否正确（比如检查签名是否正确、是否过期、token的接收方是否是自己等）。
6. 验证通过后（后端解析出JWT Token中包含的用户信息，进行其他逻辑操作，如根据用户信息得到用户权限），服务器返回请求所需的数据给客户端。
```

![jwt](./image/900b3e81f832b2f08c2e8aabb540536a.png)

#### JWT结构

```bash
JWT 信息和 JWT 数据需要使用 base64 编码，所以内容是公开的。

JWT 信息部分必须包含：`{ "typ": "JWT", "alg": "ES256"}`

JWT 数据部分，提供有关 JWT 的发送者、目标用户及有效时间等信息
	- aud：推送服务器的地址。（如：`"aud": "https://xxx.push-server.com"`）
	- exp：签名过期时间，单位秒，必须不大于 24 小时。（如：`"exp": "1469632224"`）
	- sub：必须是 URL 或者 邮箱地址。用于推送服务器联系发送人。（如：`"sub": "mailto:xxx@contact.com"`）

JWT 签名部分，是取 JWT 信息部分和 JWT 数据部分的字符串拼接结果，中间用`·`连接，生成未签名的令牌，然后进行签名生成的。
签名是基于应用服务器生成的 VAPID 私钥进行加密的，nodejs 可以使用 jws 库来签名：

Authorization 对 JWT 签名的格式要求：`Authorization: '<JWT Info>.<JWT Data>.<Signature>'`
```

![image-20240228211726290](./image/image-20240228211726290.png)

```js
const jws = require('jws');
const asn1 = require('asn1.js');

const header = {
  typ: 'JWT',
  alg: 'ES256'
};

const jwtPayload = {
  aud: audience,
  exp: expiration,
  sub: subject
};

const jwt = jws.sign({
  header: header,
  payload: jwtPayload,
  privateKey: toPEM(privateKey)
});

function toPEM(key) {
  return asn1
    .define("ECPrivateKey", function() {
      this.seq().obj(
        this.key("version").int(),
        this.key("privateKey").octstr(),
        this.key("parameters")
          .explicit(0)
          .objid()
          .optional(),
        this.key("publicKey")
          .explicit(1)
          .bitstr()
          .optional()
      );
    })
    .encode(
      {
        version: 1,
        privateKey: key,
        parameters: [1, 2, 840, 10045, 3, 1, 7] // prime256v1
      },
      "pem",
      {
        label: "EC PRIVATE KEY"
      }
    );
}


```



#### JWT 和 Token 的区别

```bash
### Token 和 JWT 的区别
相同：
	- 都是访问资源的令牌
	- 都可以记录用户的信息
	- 都是使服务端无状态化
	- 都是只有验证成功后，客户端才能访问服务端上受保护的资源

区别：
	- Token：服务端验证客户端发送过来的 Token 时，还需要查询数据库获取用户信息，然后验证 Token 是否有效。
	- JWT： 将 Token 和 Payload 加密后存储于客户端，服务端只需要使用密钥解密进行校验（校验也是 JWT 自己实现的）即可，不需要查询或者减少查询数据库，因为 JWT 自包含了用户信息和加密的数据。

```



#### JWT 和 Session 的区别

```bash
### JWT 和 Session 的区别
Session 认证的问题
  - 每个用户的登录信息(登录状态/权限)都需要保存到服务器的session中，随着用户的增多，服务器开销会明显增大。
  - 由于session是存在与服务器的物理内存中，所以在分布式系统中，这种方式将会失效。虽然可以将 session 统一保存到Redis中，但是这样会增加系统的复杂性，对于不需要 redis 的应用也会白白多引入一个缓存中间件。
  - 对于非浏览器的客户端、手机移动端等不适用，因为session依赖于cookie，而移动端经常没有cookie。
  - 因为session认证本质基于cookie，所以如果cookie被截获，用户很容易收到跨站请求伪造攻击。并且如果浏览器禁用cookie，这种方式也会失效。
  - 前后端分离系统中更加不适用，前端发送的请求通常需要经过多个中间件后服务端才能接受到，因而会导致 cookie 中关于session的信息会被转发多次。
  - 由于 Session 是基于Cookie，而cookie无法跨域，所以 session的认证也无法跨域，对单点登录不适用。

JWT认证的优势
  - 简洁：JWT Token 数据量小，传输速度也很快。
  - 因为 JWT Token 是以 JSON 加密形式保存在客户端，所以 JWT 是跨语言的，原则上任何web形式都支持。
  - 无需服务端保存会话信息：JWT 中包含完整的认证和授权信息，不依赖于cookie和session，所以没有传统session认证的弊端，特别适用于分布式微服务。
  - 单点登录友好：使用Session进行身份认证的话，由于cookie无法跨域，难以实现单点登录。但是，使用token进行认证的话， token可以被保存在客户端的任意位置的内存中，不一定是cookie，所以不依赖cookie，不会存在这些问题。
  - 适合移动端应用：使用Session进行身份认证，需要保存一份信息在服务器端，而且这种方式会依赖到Cookie（需要 Cookie 保存 SessionId），所以不适合移动端。
> 因为这些优势，目前无论单体应用还是分布式应用，都更加推荐用JWT token的方式进行用户认证。


#### JWT 相较于传统的基于会话的认证机制的优势
1. 无需服务器存储状态：
传统的基于会话的认证机制需要服务器在 session 中存储用户的状态信息(包括用户的登录状态、权限)，随着用户的增多，服务开销会明显增大。
而使用 JWT，服务器无需存储任何会话状态信息，所有的认证和授权信息都包含在 JWT 中，使得系统可以更容易地进行水平扩展。

2. 跨域支持：由于 JWT 包含完整的认证和授权信息，因此可以轻松地在多个域之间进行传递和使用，实现跨域授权。

3. 适应微服务架构：在微服务架构中，很多服务是独立部署并且可以横向扩展的，这就需要保证认证和授权的无状态性。使用 JWT 可以满足这种需求，每次请求携带 JWT 即可实现认证和授权。

4. 自包含：JWT 包含了认证和授权信息，以及其他自定义的声明，这些信息都被编码在 JWT 中，在服务端解码后使用。JWT 的自包含性减少了对服务端资源的依赖，并提供了统一的安全机制。

5. 扩展性：JWT 可以被扩展和定制，可以按照需求添加自定义的声明和数据，灵活性更高。

```



#### oAuth 认证

```bash
### oAuth 认证
[oAuth 认证](https://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html)
```

[oAuth 认证](https://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html)



## 跨域

> ```bash
> ## 跨域
> - 广义的跨域是指一个域下的文档或脚本试图去请求另一个域下的资源。
> - 狭义的是由浏览器同源策略限制的一类请求场景。
> - 广义的跨域
>     1. 资源跳转：A链接、重定向、表单提交
>     2. 资源嵌入：<link>、<script>、<frame> 等 dom 标签，还有样式中 background:url()、@font-face() 等文件外链
>     3. 脚本请求：js 发起的 ajax 请求获取数据、dom 和 js 对象的跨域操作等。
> 
> 
> ## 同源策略
> - 同源是指域名，协议，端口完全相同。
> - 同源策略/SOP（Same origin policy）浏览器的一种安全策略，该策略是浏览器用于隔离潜在恶意文件的设立安全机制（降低浏览器收到XSS、CSFR等攻击恶意窃取数据），确保一个应用中的资源只能被本应用的资源访问。
> - 同源策略的限制行为：
> 		1. Cookie、localStorage 和 IndexedDB 无法读取。
> 		2. DOM 和 JS 对象无法获得。
> 		3. AJAX 请求不能发送。
> 
> 
> 
> ## 跨域解决方案
> 1. JSONP: 利用加载 JS 文件不需要遵循同源策略的原理，使用sript标签的src属性传递数据
> 2. CORS 跨域资源共享，在服务器端设置返回允许跨域访问的响应头 Access-Control-Allow-Origin
> 3. WebSocket：利用 WebSocket 协议不需要遵循同源策略的原理
> 4. document.domain + iframe：两个域都创建相同的域名来达到跨域访问资源的目的（需要主域名相同），父子域都设立同一域名
> 5. location.hash + iframe：iframe跨域+hash携带参数
> 6. window.name + iframe：iframe跨域+同一窗口共享window.name
> 7. postMessage 跨域：窗口/页面通信
> 8. Nginx 反向代理跨域
> 9. nodejs 中间件代理跨域：开发环境下使用 webpack 的 proxy
> ```

### 常见的跨域场景

> ```bash
> ## 常见的跨域场景
> URL                                      说明                    是否允许通信
> http://www.demo.com/a.js
> http://www.demo.com/b.js         同一域名，不同文件或路径           允许
> http://www.demo.com/lab/c.js
> 
> http://www.demo.com:8000/a.js
> http://www.demo.com/b.js         同一域名，不同端口                不允许
>  
> http://www.demo.com/a.js
> https://www.demo.com/b.js        同一域名，不同协议                不允许
>  
> http://www.demo.com/a.js
> http://127.0.0.1/b.js           域名和域名对应相同ip              不允许
>  
> http://www.demo.com/a.js
> http://x.demo.com/b.js           主域相同，子域不同                不允许
> http://demo.com/c.js
>  
> http://www.demo1.com/a.js
> http://www.demo2.com/b.js        不同域名                         不允许
> ```
>
> ![image-20210917092605140](./image/image-20210917092605140.png)

### 1. Nginx代理跨域

> ```bash
> ## 1. nginx 配置解决 iconfont 跨域
> 浏览器访问 js、css、img 等常规静态资源被同源策略许可，但 iconfont 字体文件(eot | otf | ttf | woff | svg)例外，此时可在 nginx 的静态资源服务器中加入以下配置。
> location / {
> 	add_header Access-Control-Allow-Origin *;
> }
> ```
>
> ```bash
> ## 2. nginx 反向代理接口跨域
> 跨域原理：同源策略是浏览器的安全策略，不是HTTP协议的一部分，服务器端调用 HTTP 接口只是使用 HTTP 协议，不会执行 JS 脚本，不需要同源策略，也就不存在跨域问题。
> 实现思路：通过 nginx 配置一个代理服务器做跳板机，反向代理demo2接口，并且顺便修改cookie中demo信息，方便当前域 cookie 写入，实现跨域登录。
> nginx 具体配置
> 
> 
> ### proxy 服务器配置参考
> server {
>     listen	81;
>     server_name	www.demo1.com;
> 
>     location / {
>       proxy_pass	http://www.demo2.com:8080; # 反向代理
>       proxy_cookie_demo www.demo2.com www.demo1.com; # 修改cookie里域名
>       index index.html index.htm;
> 
>       # 当用 webpack-dev-server 等中间件代理接口访问nginx时，此时无浏览器参与，故没有同源限制，下面的跨域配置可不启用
>       add_header Access-Control-Allow-Origin http://www.demo1.com;	# 当前端只跨域不带cookie时，可为 *
>       add_header Access-Control-Allow-Credentials true;
>     }
> }
> 
> 
> ### 前端代码示例
> const xhr = new XMLHttpRequest()
> xhr.withCredentials = true	// 前端开关：浏览器是否读取cookie
> xhr.open('get', 'http://www.demo1.com:81/?user=admin', true)	// 访问nginx中的代理服务器
> xhr.send()
> 
> 
> ### nodejs 代理示例
> const http = require('http')
> const server = http.createServer()
> const qs = require('querystring')
> server.on('request', (req, res) => {
> 	const params = qs.parse(req.url.substring(2))
> 	// 向前台写 cookie
> 	res.writeHead(200, {
> 		'Set-Cookie': 'l=a123456;Path=/;Domain=www.demo2.com;HttpOnly', // HttpOnly: 脚本无法读取
> 	})
> 	res.write(JSON.stringify(params))
> 	res.end()
> })
> server.listen('8080')
> console.log('Server is running at port 8080...')
> ```

### 2. WebSocket 协议跨域

> ```bash
> ## WebSocket 协议跨域
> - WebSocket protocol 是 HTML5 一种新的协议。它实现了浏览器与服务器全双工通信，同时允许跨域通讯，是 server push 技术的一种很好的实现。
> - 原生 WebSocket API 使用繁琐，但可使用 Socket.io，它很好地封装了 WebSocket 接口，提供了更简单、灵活的接口，也对不支持 WebSocket 的浏览器提供了向下兼容。
> 
> 
> ### 实现
> #### 1) 前端代码：
>     <div>user input: <input type="text" /></div>
>     <script src="./socket.io.js"></script>
>     <script>
>       const socket = io('http://www.demo2.com:8080')
>       // 连接成功处理
>       socket.on('connect', () => {
>         // 监听服务端消息
>         socket.on('message', (msg) => {
>           console.log('data from server: -->', msg)
>         })
> 
>         // 监听服务端关闭
>         socket.on('disconnect', () => {
>           console.log('Server socket has closed.')
>         })
>       })
>       document.getElementsByTagName('input')[0].onblur = function () {
>         socket.send(this.value)
>       }
>     </script>
> 
> #### 2) NodeJS socket 后端代码：
>     const http = require('http')
>     const server = http.createServer((req, res) => {
>       res.writeHead(200, {
>         'Content-type': 'text/html'
>       })
>       res.end()
>     })
>     server.listen('8080')
>     console.log('Server is running at port 8080...')
>     // 监听 socket 连接
>     server.listen(server).on('connection', (client) => {
>       // 接收信息
>       client.on('message', (msg) => {
>         client.send('hello:' + msg)
>         console.log('data from client: --->', msg)
>       })
>       // 断开处理
>       client.on('disconnect', () => {
>         console.log('Client socket has closed.')
>       })
>     })
> ```

### 3. postMessage（跨窗口/页面通信）

> ```bash
> ## postMessage 跨域
> - postMessage 可以解决以下问题：
>     1. 页面和其打开的新窗口的数据传递
>     2. 多窗口之间的消息传递
>     3. 页面与嵌套的 iframe 消息传递
>     4. 上面三个场景的跨域数据传递
> - 用法：postMessage(data, origin) 方法接收两个参数
> 		- data：html5规范支持任意基本类型或可复制的对象，但部分浏览器只支持字符串，所以传参时最好用 JSON.stringify() 序列化。
> 		- origin：协议+主机+端口号，也可设置为 `"*"`，表示可传递给任意窗口，如果要指定和当前窗口同源的话设置为 `"/"`。
> 
> 
> ### 案例
> #### 1) a.html：(http://www.demo1.com/a.html)
>     <iframe id="iframe" src="http://www.demo2.com/b.html" style="display:none;"></iframe>
>     <script>       
>       const iframe = document.getElementById('iframe')
>       iframe.onload = () => {
>         const data = { name: 'willy' }
>         // 向domain2传送跨域数据
>         iframe.contentWindow.postMessage(JSON.stringify(data), 'http://www.demo2.com')
>       }
> 
>       // 接受domain2返回数据
>       window.addEventListener('message', (e) => {
>         console.log('data from demo2 ---> ', e.data)
>       }, false)
>     </script>
> 
> 
> #### 2) b.html：(http://www.demo2.com/b.html)
>     <script>
>       // 接收domain1的数据
>       window.addEventListener('message', (e) => {
>         console.log('data from demo1 ---> ', e.data)
>         const data = JSON.parse(e.data)
>         if (data) {
>           data.number = 16
>           // 处理后再发回domain1
>           window.parent.postMessage(JSON.stringify(data), 'http://www.demo1.com')
>         }
>       }, false)
>     </script>
> ```

### 4. CORS跨域共享（设置响应头 `Access-Control-Allow-Origin` ）

```bash
## CORS 跨域共享 (Cross-Origin Resource Sharing)
- 普通跨域请求：在服务端设置 `Access-Control-Allow-Origin` 即可，在前端无需设置，若要带 cookie 请求，前后端都需要设置。
- CORS 是主流的跨域解决方案，目前所有浏览器都支持该功能（IE8+: IE8/9需要使用`XDomainRequest`对象来支持CORS）。
- 需要注意：
    - 由于同源策略的限制，所读取的 cookie 为跨域请求接口所在域的 cookie，而非当前页。
    - 如果想要实现当前 cookie的写入，可参考 nginx反向代理设置`proxy_cookie_domain` 和 NodeJS中间件代理中 `cookieDomainRewrite` 参数的设置。
- 前端设置：原生ajax设置是否带cookie：`xhr.withCredentials = true`


### 前端配置的案例
#### 1) 前端设置的原生ajax（如果请求需要用cookie才需要设置）
    const xhr = new XMLHttpRequest() 	// IE8/9需用window.XDomainRequest兼容
    xhr.withCredentials = true	// 前端设置是否带 cookie
    xhr.open('post', 'http://www.demo2.com:8080/login', true)
    xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded')
    xhr.send('user=admin')
    xhr.onreadystatechange = () => {
      if (xhr.readyState == 4 && xhr.status == 200) {
        console.log(xhr.responseText);
      }
    }

#### 2) vue框架
在vue-resource封装的ajax组件中加入以下代码：
		Vue.http.options.credentials = true


### 后端配置的案例
若后端设置成功，前端浏览器控制台则不会出现跨域报错信息，反之，说明没设成功。
#### 1) PHP后台：
    // 若有端口需写全（协议+域名+端口）
    response.setHeader("Access-Control-Allow-Origin", "http://www.domain1.com"); 
    response.setHeader("Access-Control-Allow-Credentials", "true")

#### 2) Nodejs后台:
const http = require('http');
const server = http.createServer();
const qs = require('querystring');

server.on('request', (req, res) => {
  let postData = ''
  // 数据块接收中
  req.addListener('data', (chunk) => {
  	postData += chunk
  })

  // 数据接收完毕
  req.addListener('end', () => {
    postData = qs.parse(postData)

    // 跨域后台设置
    res.writeHead(200, {
      'Access-Control-Allow-Credentials': 'true',     // 后端允许发送Cookie
      'Access-Control-Allow-Origin': 'http://www.demo1.com',    // 允许访问的域（协议+域名+端口）
      'Set-Cookie': 'l=a123456;Path=/;Domain=www.demo2.com;HttpOnly'   // HttpOnly:脚本无法读取cookie
    })
    res.write(JSON.stringify(postData))
    res.end()
	})
})
server.listen('8080')
console.log('Server is running at port 8080...')
```



### 5. JSONP（利用script标签的可跨域性）

> ```bash
> ## jSONP (JSON with Padding)
> 1. JSONP 原理：
> 本质是利用 script 标签具有可跨域的特性，由服务端返回一个预先定义好的 JS 函数的调用，并且将服务器数据将以该函数参数的形式传递返回。
> JSON 只支持 get，因为 script 标签只能使用 get 请求； JSONP 需要后端配合返回指定格式的数据。
> 
> 2. JSONP 应用场景
> 通常为了减轻web 服务器的负载，把 js、css、image等静态资源分离到另一台独立域名的服务器上，在 html 页面中再通过相应的标签从不同域名下加载静态资源，从而被浏览器允许，基于此原理，我们可通过动态创建 script，再请求一个带参网址实现跨域通信。
> 
> 
> ### 案例
> #### 1) 前端html
>     <script>
>       const script = document.createElement('script')
>       script.type = 'text/javascript'
> 
>       // 传参并制定回调执行函数为 onBack
>       sciprt.src = 'http://www.demo.com:3000/login?user=admin&callback=onBack'
>       document.head.appendChild(script)
> 
>       // 回调执行函数
>       function onBack(res) {
>         console.log("后端返回的数据", res)
>       }
>     </script>
> 
> 
> #### 2) 后端 nodejs
>     const querystring = require('querystring')
>     const http = require('http')
>     const server = http.createServer()
> 
>     server.on('request', (req, res) => {
>       const params = qs.parse(req.url.split('?')[1])
>       const fn = params.callback
> 
>       // jsonp 返回设置
>       res.writeHead(200, { 'Content-Type': 'text/javascript' })
>       res.write(fn + '(' + JSON.stringify(params) + ')')
>       res.end()
>     })
>     server.listen('3000')
>     console.log('Server is running at port 3000...')
> ```

### 6. Nodejs中间件代理跨域

> ```bash
> ## Nodejs中间件代理跨域
> node 中间件实现跨域代理，原理大致与 nginx 相同，都是通过开启一个代理服务器来实现数据的转发，也可通过设置 `cookieDomainRewrite` 参数修改响应头中 cookie 的域名，实现当前域的 cookie 写入，方便接口登录认证。
> ```
>
> ````bash
> ## 1. 非Vue框架的跨域（2次跨域）：利用node + express + http-proxy-middleware搭建一个proxy服务器。
> 1) 前端代码示例
>      const xhr = new XMLHttpRequest()
>      // 前端开关：浏览器是否读写cookie
>      xhr.withCredentials = true
>      // 访问http-proxy-middleware代理服务器
>      xhr.open('get', 'http://www.demo1.com:3000/login?user=admin', true)
>      xhr.send()
> 
> 
> 2) 中间件服务器示例
>     const express = require('express')
>     const proxy = require('http-proxy-middleware')
>     const app = express()
>     app.use('/', proxy({
>       // 代理跨域目标接口
>       target: 'http://www.demo2.com:8080',
>       changeOrigin: true,
> 
>       // 修改响应头信息，实现跨域并允许带cookie
>       onProxyRes: (proxyRes, req, res) => {
>         res.header('Access-Control-Allow-Origin', 'http://www.domain1.com')
>         res.header('Access-Control-Allow-Credentials', 'true')
>       },
> 
>       // 修改响应信息中的cookie域名
>       cookieDomainRewrite: 'www.demo1.com'  // 可以为false，表示不修改
>     }))
>     app.listen(3000)
>     console.log('Proxy server is listen at port 3000...')
> 
> 
> 3) Nodejs后台
>     const http = require('http');
>     const server = http.createServer();
>     const qs = require('querystring');
>     server.on('request', (req, res) => {
>         const params = qs.parse(req.url.substring(2));
>         // 向前台写cookie
>         res.writeHead(200, {
>           'Set-Cookie': 'l=a123456;Path=/;Domain=www.demo2.com;HttpOnly'   // HttpOnly:脚本无法读取
>         })
>         res.write(JSON.stringify(params))
>         res.end()
>     })
>     server.listen('8080')
>     console.log('Server is running at port 8080...')
> ````
>
> ```bash
> ## 2.  vue框架的跨域（1次跨域）
> 利用node + webpack + webpack-dev-server代理接口跨域。
> 在开发环境下，由于vue渲染服务和接口代理服务都是webpack-dev-server同一个，所以页面与代理接口之间不再跨域，无须设置headers跨域信息了。
> 
> 
> ### vue项目的 webpack.config.js 部分配置
> module.exports = {
>     entry: {},
>     module: {},
>     ...
>     devServer: {
>       historyApiFallback: true,
>       proxy: [{
>         context: '/login',
>         target: 'http://www.demo2.com:8080',  // 代理跨域目标接口
>         changeOrigin: true,
>         secure: false,  // 当代理某些https服务报错时用
>         cookieDomainRewrite: 'www.demo1.com'  // 可以为false，表示不修改
>       }],
>       noInfo: true
>     }
> }
> ```

### 7. document.domain + iframe （需要主域名相同）

> ```bash
> ## document.domain + iframe 跨域（此方案需要两个都设置为域名，且主域名需要相同）
> - 此方案仅限于基础域名相同，子域名不同的跨域应用场景
> - 实现原理：两个页面都通过 js 强制设置 document.domain 为基础主域，就实现了同域。
> 
> 
> ### 使用 document.domain 的注意点
> - 如 `http:news.baidu.com` 这个地址如果要修改域名，只能修改为 `news.baidu.com`（满足第一条限制） 和 `baidu.com`（满足第二条限制），而不能设置为 `map.baidu.com` 或者 `.com` 等。
> - 如 `a.taobao.com` 页面通过 `document.domain='taobao.com'` 之后，不能直接访问 `taobao.com` 页面的资源：
> 		因为此时如果可以直接访问父级的资源，那么任何域名的子级域名地址（如`a.taobao.com`）都可以对父级（`taobao.com`）发起 xss 攻击。
> 		只有父子级都设置 `document.domain='taobao.com'` 才能达到跨域访问资源的目的。
> 
> 
> ### 实现的demo
> 1. 父窗口：http://www.demo.com/a.html
>     <iframe id="iframe" src="http://child.demo.com/b.html"></iframe>
>     <script>
>       document.domain = 'demo.com';
>       const user = 'admin';
>     </script>
> 
> 2. 子窗口：http://child.demo.com/b.html
>     <script>
>       document.domain = 'demo.com';
>       // 获取父窗口中的变量
>       alert('get js data from parent ->' + window.parent.user)
>     </script>
> ```

### 8. location.hash + iframe （需要创建第三个页面协同通信）

> ```bash
> ## location.hash + iframe 跨域
> 1. 实现原理：
> 	页面A想与页面B相互通信，通过中间页C来实现。
> 	三个页面，不同域之间利用 iframe 的 location.hash 传值，相同域之间直接 JS 访问通信。
> 2. 具体实现：
> 		A域：a.html -> B域：b.html -> A域：c.html
> 		a与b页面不同域只能通过hash值单向通信，b与c页面不同域也只能单向通信，但是 c与a 同域，所以 c 可通过 parent.parent 访问 a 页面所有对象。
> 
> 
> ### 实现 demo
> #### 1) a.html：http://www.demo1.com/a.html
>     <iframe id="iframe" src="http://www.demo2.com/b.html" style="display: none;"></iframe>
>     <script>
>       const iframe = document.getElementById('iframe')
>       // 向 b.html 传 hash 值
>       setTimeout(() => {
>         iframe.src = iframe.src + '#user=admin'
>       }, 1000)
>       // 开始给同域 c.html 的回调方法
>       function onCallback (res) {
>         alert('data from c.html --->', res)
>       }
>     </script>
> 
> #### 2) b.html：http://www.demo2.com/b.html
>     <iframe id="iframe" src="http://www.demo1.com/c.html" style="display: none;"></iframe>
>     <script>
>       const iframe = document.getElementById('iframe')
>       // 监听 a.html 传来的 hash 值，再传给 c.html
>       window.onhashchange = function () {
>         iframe.src = iframe.scr + location.hash
>       }
>     </script>
> 
> #### 3) c.html：http://www.demo1.com/c.html
>     <script>
>       const iframe = document.getElementById('iframe')
>       // 监听 b.html 传来的 hash 值
>       window.onhashchange = function () {
>         // 再通过操作同域 a.html 的js回调，将结果传回
>         window.parent.parent.onCallback('hello: ' + location.hash.replace('#user=', ''))
>       }
>     </script>
> ```
>

### 9. window.name + iframe（利用在同一个浏览器窗口内载入的域名共享一个 window.name）

> ```bash
> ## window.name + iframe
> - 利用在一个浏览器窗口内，载入所有的域名都是共享一个window.name
> - window.name 属性的独特之处：name值在不同的页面(甚至不同域名)加载后依旧存在，并且支持非常长的 name 值（2MB）。
> - 该跨域主要是通过 iframe 的 src 属性由外域转向本地域，跨域数据即由 iframe 的 window.name 从外域传递到本地域。这个巧妙地绕过浏览器的跨域访问限制，但同时它又是安全操作。
> 
> 
> ### 案例
> #### 1) a.html：http://www.demo1.com/a.html
>     const proxy = function (url, callback) {
>       let state = 0
>       const iframe = document.createElement('iframe')
>       iframe.src = url // 加载跨域页面
> 
>       // onload事件会触发2次
>       iframe.onload = function () {
>         if (state === 0) {
>           // 第1次加载跨域页成功后，切换到同域代理页面，并留存数据与 window.name
>           iframe.contentWindow!.location = 'http://www.demo1.com/proxy.html'
>           state = 1
>         } else if (state === 1) {
>           // 第2次onload（同域proxy页）成功后，读取同域 window.name 中数据
>           callback(iframe.contentWindow?.name)
> 
>           // 获取数据以后销毁这个iframe，释放内存；这也保证安全（不配其他域 frame js 访问）
>           iframe.contentWindow?.document.write('')
>           iframe.contentWindow?.close()
>           document.body.removeChild(iframe)
>         }
>       }
>     }
>     // 请求跨域 b 页面数据
>     proxy('http://www.demo2.com/b.html', function (data) {
>       console.log(data)
>     })
> 
> 
> #### 2) proxy.html：http://www.demo1.com/proxy.html
> 中间代理页，与a.html同域，内容为空
> 
> 
> #### 3) b.html：http://www.demo2.com/b.html
>     <script>
>       window.name = 'This is demo2 data!'
>     </script>
> ```

