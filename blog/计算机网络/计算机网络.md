---
Author: willysliang
CreateTime: 2022-08-21 16:07
Modifier: willysliang
ModifiedTime: 2023-01-13 14:17:23
Description: 计算机网络
---

## 计算机网络

## 网络分层

> 目前存在的两种网络分层模型：**OSI模型**和**TCP/IP模型**。OSI模型一共分为七层，TCP/IP模型和OSI模型类似，但是只分为四层。

### OSI模型

> OSI的全程是Open Systems Interconncection，即开放系统互联，它由ISO(International Organization for Standardization)制定。OSI是网络通信的一种通用框架，它分为七层，并且定义了在每一层上数据的处理方法。
>
> | 层数 |         层名          | 常见知识点                                                   |        设备         |
> | :--- | :-------------------: | :----------------------------------------------------------- | :-----------------: |
> | 7    |  应用层(Application)  | HTTP、SMTP、SNMP、FTP、Telnet、SIP、SSH、NFS、RTSP、XMPP、Whois、ENRP |                     |
> | 6    | 表示层(Presentation)  | XDR、ASN.1、SMB、AFP、NCP                                    |                     |
> | 5    |    会话层(Session)    | ASAP、TLS、SSH、ISO 8327 / CCITT X.225、RPC、NetBIOS、ASP、Winsock、BSD sockets |                     |
> | 4    |   传输层(Transport)   | TCP、UDP、RTP、SCTP、SPX、ATP、IL                            |                     |
> | 3    |    网络层(Network)    | IP、ICMP、IGMP、IPX、BGP、OSPF、RIP、IGRP、EIGRP、ARP、RARP、 X.25 |       路由器        |
> | 2    | 数据链路层(Data Link) | 以太网、令牌环、HDLC、帧中继、ISDN、ATM、IEEE 802.11、FDDI、PPP |       交换机        |
> | 1    |   物理层(Physical)    | 线路、无线电、光纤、信鸽                                     | 网卡、集线器（Hub） |

### TCP/IP模型

> ```bash
> ## TCP/IP 模型
> TCP/IP 模型分为四层：
>    * 应用层（Application）
>    * 传输层（Host-to-Host Transport）
>    * 互联网层(Internet)
>    * 网络接口层(Network Interface)
> 
> 发送放应用程序的数据总是从最上层开始，层层向下，最终经由物理层发送出去；
> 相应的，在接收方的物理层接收到数据后，层层向上，最终经由应用层分发到具体的应用程序进程中。
> 在数据层层向下的过程中，每一层都会对数据进行一些封装处理（如打包或编码）；
> 而在数据层层向上的过程中，每一层都会对数据进行一些逆处理（如解包或解码）。
> 这些对数据的处理和逆处理的过程就是为了实现该层的服务。
> ```
>

### 网络模型

> ```bash
> # 应用层
> 是最靠近应用程序的OSI层。由用户使用相应的接口实现自己的服务。
> 协议有：HTTP FTP SMTP等
> 
> 
> # 表示层
> 数据的表示、安全、压缩。可确保一个系统的应用层所发送的信息被另一个系统的应用层读取。格式有: JPEG、ASCII、加密格式等。
> 
> 在表示层，数据按照网络能理解的方案进行格式化。管理数据的加密与解密。
> 
> 
> # 会话层
> 建立、管理、终止会话，对应主机进程，指本地主机与远程主机正在进行的会话。负责在网络的两节点之间建立、维持和终止通信。
> 
> 会话层的功能包括：建立通信链接，保持会话过程通信连接的畅通，同步两个节点之间的对话，决定通信是否被终端以及通信中断时从何处重新发送。
> 
> 有人会把会话层称为网络通信得到“交通警察“。当通过拨号向你的ISP（因特网服务提供商）请求连接到因特网时，ISP服务器上的会话层向你与你的PC客户机上的会话层进行协商连接。若你的电话线偶然脱落时，会话层将会检测到连接中断并重新发起连接。会话层通过决定节点通信的优先级和通信时间的长短来设置通信期限。
> 
> 
> 
> # 传输层
> 定义传输数据的协议端口号，以及流控和差错校验。
> 
> 协议有：TCP UDP等，数据包一旦离开网卡即进入网络传输层。定义了一些传输数据的协议和端口号，如：TCP（传输控制协议，传输效率低，可靠性强，用于传输可靠性要求高，数据量大的数据），UDP（用户数据报协议，用于传输可靠性要求不高，数据量小的数据）。主要是讲从下层接收的数据进行分段和传输，到达目的地后再进行重组。常常把这一层数据叫做段。
> 
> OSI模型中最终要的一层。传输协议同时进行浏览控制或是基于接收方可接收数据的快慢程度规定适当的发送速率。除此之外，传输层按照网络能处理的最大尺寸将较长的数据包进行强制分割。例如，以太网无法接收大于1500字节的数据包。发送方节点的传输层将数据分割成较小的数据片，同时对每一数据片安排一个序列号，以便数据到达接收方节点的传输层时，能以正确的顺序重组。该过程称作排序。
> 
> 
> # 网络层
> 进行逻辑地址寻址，实现不同网络之间的路径选择等。协议有：ICMP IGMP IP ARP RARP等。
> 
> 在位于不同地理位置的网络中的两个主机系统之间提供连接和路径选择。Internet的发展使得从世界各站点访问信息的用户量大大增加，网络层正式管理这种连接的层。
> 
> OSI模型的第三层，其主要功能是将网络地址翻译成对应的物理地址，并决定如何将数据从发送方路由到接收方。
> 
> 网络层通过综合考虑发送优先权、网络拥塞程度、服务质量以及可选路由的花费来决定从一个网络中节点A到另一个网络节点B的最佳路径。由于网络层处理，并智能指导数据传送，路由器连接网络各段，所以路由器属于网络层。在网络中，”路由“是基于编址方案、使用模式以及可达性来指导数据的发送。
> 
> 网络层用于本地LAN网段之上的计算机系统建立通信，它之所以可以这样做，是因为它有自已的路由地址结构，这种结构与第二层机器地址是分开的、独立的。这种协议称为路由或可路由协议。路由协议包括IP、Novell公司的IPX以及AppleTalk协议。
> 
> 
> 
> # 数据链路层
> 建立逻辑连接、进行硬件地址寻址、差错校验等功能。将比特组合成字节进而组合成帧，用MAC地址访问介质，错误发现但不能纠正。
> 
> 主要功能是如何在不可靠的物理线路上进行数据的可靠传递。为了保证传输，从网络层接收的数据被分割成特定的可被物理层传输的帧。帧是用来移动数据的结构包，它不仅包括原始数据，还包括发送方和接收方的物理地址以及检错和控制信息。其中的地址确定了帧将发往何处，而纠错和控制信息则确保帧无差错到达。如果在传送数据时，接收点检测到所传数据中有差错，就要通知发送方重发这一帧。
> 
> 数据链路层在物理层提供比特流服务的基础上，建立相邻节点之间的数据链路，通过差错控制提供数据帧在信道上无差错的传输，并进行各电路上的动作系列。作用主要是物理地址寻址、数据的成帧、流量控制、数据的检错、重发等。
> 
> 
> 
> # 物理层
> 建立、维护、断开物理连接。
> 主要定义物理设备标准，如网线的接口类型，光纤的接口类型，各种传输介质的传输速率等。主要作用是传输比特流（就是有1、0转化为电力强弱来进行传输，到达目的地后在转化为1、0）
> ```
>
> ![image-20220818194218705](./image/image-20220818194218705.png)

### TCP与UDP

> ```bash
> ## TCP 与 UDP
> - UDP：无连接（不需要三次握手）、单播、多播的功能、容易丢包从而导致数据不可靠性、不具备拥塞控制、传输效率高。适用于视频会议、电话、直播等（因为不需要建立连接、不会数据拥塞、保证内容的实时性）
> - TCP：面向连接、数据传输可靠（会判断是否丢包）、拥塞控制。适用于文件传输（因为数据传输可靠）
> 
> 
> 
> ### TCP 滑动窗口
> 在 TCP 链接中，对于发送端和接收端而言，TCP 需要把发送的数据放到发送缓存区, 将接收的数据放到接收缓存区。而经常会存在发送端发送过多，而接收端无法消化的情况，所以就需要流量控制，就是在通过接收缓存区的大小，控制发送端的发送。如果对方的接收缓存区满了，就不能再继续发送了。而这种流量控制的过程就需要在发送端维护一个发送窗口，在接收端维持一个接收窗口。 
> TCP 滑动窗口分为两种: 发送窗口和接收窗口。
> 
> ```

## 常见的网络端口及对应服务

> |              服务               | 端口                                             |
> | :-----------------------------: | ------------------------------------------------ |
> |       FTP（文件传输协议）       | 20 用于数据传输，21 用于已建立的连接             |
> |      SSH （安全外壳协议）       | 22                                               |
> |       Telnet（远程登录）        | 23                                               |
> |    SMTP（简单邮箱传输协议）     | 25                                               |
> |           DNS（域名）           | 53                                               |
> |              DHCP               | 67/UDP 用于 DHCP 服务器，68/UDP 用于 DHCP 客户端 |
> |     HTTP（超文本传输协议）      | 80                                               |
> |       POP3（邮箱协议 3 ）       | 110                                              |
> |              HTTPS              | 443                                              |
> | socks（防火墙安全会话转换协议） | 1080                                             |
> |     MySQL（数据库默认端口）     | 3306                                             |

## HTTP网络请求协议

> #### http协议的特点
>
> - 简单快速：每个资源（比如图片、页面）都通过 url 来定位，想访问什么资源，直接输入url即可。
> - 灵活：http协议的头部有一个`数据类型`，通过http协议，就可以完成不同数据类型的传输。
> - **无连接**：连接一次，就会断开，不会继续保持连接。
> - **无状态**：客户端和服务器端是两种身份。第一次请求结束后就断开；第二次请求时，**服务器端并没有记住之前的状态**(记住状态的一般是session/cookies等)
> - **一次完整的HTPP请求**需要请求头、请求体、响应头、响应体
>
> #### http报文组成
>
> ![image-20210918094312634](./image/image-20210918094312634.png)

### 请求头

> 请求体：指提交给服务器的数据。如果是往服务器提交数据，需要在请求头中设置`Content-Type: application/x-www-form-urlencoded`(在ajax中需要手动设置)
>
> ![image-20210918094409349](./image/image-20210918094409349.png)
>
> ```bash
> User-Agent：浏览器的具体类型　　如：User-Agent：Mozilla/5.0 (Windows NT 6.1; rv:17.0) Gecko/20100101 Firefox/17.0
> 
> Accept：浏览器支持哪些数据类型　　如：Accept: text/html,application/xhtml+xml,application/xml;q=0.9;
> 
> Accept-Charset：浏览器采用的是哪种编码　　如：Accept-Charset: ISO-8859-1
> 
> Accept-Encoding：浏览器支持解码的数据压缩格式　　如：Accept-Encoding: gzip, deflate
> 
> Accept-Language：浏览器的语言环境　　如：Accept-Language zh-cn,zh;q=0.8,en-us;q=0.5,en;q=0.3
> 
> Host：请求的主机名，允许多个域名同处一个IP地址，即虚拟主机。Host:www.baidu.com
> 
> Connection：表示是否需要持久连接。
> 属性值可以是Keep-Alive/close，HTTP1.1默认是持久连接，它可以利用持久连接的优点，当页面包含多个元素时（例如Applet，图片），显著地减少下载所需要的时间。
> 要实现这一点，Servlet需要在应答中发送一个Content-Length头，最简单的实现方法是：先把内容写入ByteArrayOutputStream，然后在正式写出内容之前计算它的大小。如：Connection: Keep-Alive
> 
> Content-Length：表示请求消息正文的长度。对于POST请求来说Content-Length必须出现。
> 
> Content-Type：WEB服务器告诉浏览器自己响应的对象的类型和字符集。例如：Content-Type: text/html; charset='gb2312'
> 
> Content-Encoding：WEB服务器表明自己使用了什么压缩方法（gzip，deflate）压缩响应中的对象。
> 例如：Content-Encoding：gzip
> 
> Content-Language：WEB服务器告诉浏览器自己响应的对象的语言。
> 
> Cookie：最常用的请求头，浏览器每次都会将cookie发送到服务器上，允许服务器在客户端存储少量数据。
> 
> Referer：包含一个URL，用户从该URL代表的页面出发访问当前请求的页面。服务器能知道你是从哪个页面过来的。
> Referer: http://www.baidu.com/
> ```

### 响应报文

> 响应报文是服务器返回给客户端的，组成部分有响应行(设置响应状态)、响应头(设置Cookie、缓存等)、响应主体(响应返回的js或html页面)
>
> ![img](./image/20180228_1510.jpg)
>
> **常见的响应头**
>
> ```bash
> Cache-Control：响应输出到客户端后，服务端通过该报文头属告诉客户端如何控制响应内容的缓存。
> 如Cache-Control: max-age=3600 则是让客户端对响应内容缓存3600秒，也即在3600秒内如果客户再次访问该资源，则直接从客户端的缓存中返回内容给客户，不要再从服务端获取（这个功能是靠客户端实现的，服务端只是通过这个属性提示客户端从缓存中取，是否执行则还是决定于客户端，如果是自己宣称支持HTTP的客户端，则就应该这样实现）
> 
> ETag: "737060cd8c284d8af7ad3082f209582d"
> 一个代表响应服务端资源（如页面）版本的报文头属性，如果某个服务端资源发生变化了，这个ETag就会相应发生变化。它是Cache-Control的有益补充，可以让客户端“更智能”地处理什么时候要从服务端取资源，什么时候可以直接从缓存中返回响应。
> 
> Location: http://www.google.com.hk
> 我们在Asp.net中让页面Redirect到一个某个A页面中，其实是让客户端再发一个请求到A页面，这个需要Redirect到的A页面的URL，其实就是通过响应报文头的Location属性告知客户端的，如下的报文头属性，将使客户端redirect到iteye的首页中：
> 
> Set-Cookie: UserID=JohnDoe; Max-Age=3600; Version=1
> 服务端可以设置客户端的Cookie，其原理就是通过这个响应报文头属性实现的。
> ```

### MIME类型

```bash
## 设置资源类型（MIME类型）
媒体类型（通常称为 Multipurpose Internet Mail Extensions 或 **MIME** 类型）是一种标准，用来表示文档、文件或字节流的性质和格式。
HTTP 服务可以设置响应头 `Content-Type` 来表明响应体的 MIME 类型，浏览器会根据该类型决定如何处理资源。


### mime 的类型结构
mime 的类型结构：`type/subtype`，由类型与子类型两个字符串中间用 `/` 分隔而组成。不允许空格存在。
    - *type* 表示可以被分多个子类的独立类别。
    - *subtype* 表示细分后的每个类型。
注意：MIME 类型对大小写不敏感，但是传统写法都是小写。

```

#### 独立类型

```bash
## 独立类型
对于 text 文件类型若没有特定的 subtype，就使用 `text/plain`。
对于二进制文件没有特定或已知的 subtype，就使用 `application/octet-stream`，浏览器再遇到该类型的响应时，会对响应体内容进行独立存储，也就是我们常见的 '下载' 效果。

```

独立类型表明了对文件的分类，可以是如下之一：

| 类型          | 描述                                                         | 典型示例                                                     |
| :------------ | :----------------------------------------------------------- | :----------------------------------------------------------- |
| `text`        | 表明文件是普通文本，理论上是人类可读                         | `text/plain`, `text/html`, `text/css, text/javascript`       |
| `image`       | 表明是某种图像。不包括视频，但是动态图（比如动态 gif）也使用 image 类型 | `image/gif`, `image/png`, `image/jpeg`, `image/bmp`, `image/webp`, `image/x-icon`, `image/vnd.microsoft.icon` |
| `audio`       | 表明是某种音频文件                                           | `audio/*`,<br/>`audio/midi`, <br/>`audio/mpeg`, <br/>`audio/webm`,<br/>`audio/ogg`,<br/>`audio/wav`, |
| `video`       | 表明是某种视频文件                                           | `video/webm`, `video/ogg`                                    |
| `application` | 表明是某种二进制数据                                         | `application/*`,<br/>`application/json`,<br/>`application/javascript`,<br/>`application/ecmascript`,<br/>`application/octet-stream`,<br/>`application/octet-stream`,<br/>`application/pkcs12`, <br/>`application/vnd.mspowerpoint`, <br/>`application/xhtml+xml`, <br/>`application/xml`, <br/>`application/pdf` |

#### Multipart 类型

```bash
## Multipart 类型
**Multipart** 类型表示细分领域的文件类型的种类，经常对应不同的 MIME 类型。这是*复合*文件的一种表现方式。
`multipart/form-data` 可用于联系 HTML Forms 和 `POST`方法，
此外 `multipart/byteranges`使用状态码`206` `Partial Content`来发送整个文件的子集，而 HTTP 对不能处理的复合文件使用特殊的方式：将信息直接传送给浏览器（这时可能会建立一个“另存为”窗口，但是却不知道如何去显示内联文件）


### 例子
multipart/form-data
multipart/byteranges
```



## HTTP 协议版本

> ```bash
> ## http 协议版本
> http 协议是应用层协议，都是建立在传输层之上的。传输层上不只有 TCP 协议，还有 UDP 协议。
> http1.0 ~ http2.0 都是基于 TCP 协议的，因此都会有 TCP 带来的硬伤和局限性；
> 而 http3.0 则是建立在 UDP 基础之上的，所以其余 http2.0 之间有质的不同。
> ```

### `HTTP/1.0`

> ```bash
> ## HTTP/1.0
> 浏览器与服务器只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个 TCP 连接（TCP连接新建的成本很高，因为需要客户端和服务器三次握手），服务器完成请求处理后立即断开 TCP 连接，服务器不跟踪每个客户也不记录过去的请求。
> 
> ### http1.0 特点：
>   - 仅支持短暂保持短暂的 TCP 连接。
>   - 不追踪 IP。
>   - 可以使用 expires 进行强缓存
>   - 可以使用 last-modified 进行协商缓存
> ```

### `HTTP/1.1`

> ```bash
> ## HTTP/1.1
> 1. 管道化（Pipelining）
> 提出管道化方案解决连接延迟，服务端可设置 Keep-Alive 来让连接延迟关闭时间，但因为浏览器自身的 Max-Connection 最大连接限制，同一个域名下的请求连接限制（同域下谷歌浏览器是一次限制最多6个连接），只能通过多开域名来实现，这也是静态资源选择放到 CDN 上或其他域名下来提高资源加载速度。管道化方案需要前后端支持，但绝大部分 HTTP 代理器对管道化的支持并不友好。
> 
> 2. 管道化只支持 GET/HEAD
> 管道化只支持 GET/HEAD 方式传送数据，不支持 POST 等其它方式传输。
> 
> 3. 头部信息冗余
> HTTP 是误装填的，客户端/服务端只能通过 HEAD 的数据维护获取状态信息，这会造成每次连接请求时都会携带大量冗余的头部信息，头部信息包括 Cookie 信息等。
> 
> 4. 超文本协议
> HTTP/1.x 是超文本协议传输，在发送请求时会找出数据的开头和结尾帧的位置，并去除多余空格，选择最优方式传输。
> 如果使用 HTTPS，还会对数据进行加密处理，一定程度上会造成传输速度上的损耗。
> 
> 5. 队头阻塞
> 管道化通过延迟连接关闭的方案，虽然可同时发起对服务端的多个请求，但服务端的 response 依旧遵循 FIFO（先进先出）规则依次返回。在高并发延迟的场景下阻塞会更明显。
> 如客户端发送 1、2、3、4 四个请求，如果 1 没有返回给客户端，那么 2、3、4 也不会返回，这就是所谓的队头阻塞。
> 
> 
> ### http1.1 特点
> 1. 支持长连接（connection），支持文件断点续传
> 2. 纯文本报头
> 3. 增加了更多的请求头和响应头
> 4. 连接过多，会容易队首阻塞，串行传输
> 5. 可使用 etag、cache-control 进行 http缓存
> ```

### `HTTP/2.0`

> ```bash
> ## HTTP/2.0
> 1. 持久化连接 - 多路复用
> 采用多路复用，而非有序并阻塞，一个域只要一个 TCP 连接即可实现并发请求，降低延时，提高了带宽的利用率。
> HTTP的持久连接可以有效减少TCP建立连接和断开连接的次数，这样的好处是减少了服务器额外的负担，并提升整体HTTP的请求时间。
> 
> 2. 报头压缩
> 客户端/服务端进行渐进更新维护，才用 HPACK 压缩，节省了报文头占用流量，降低开销。
> 	- 相同的头部信息不会通过请求发送，沿用之前请求携带的头部信息。
> 	- 新增/修改的头部信息会被加入到 HEAD 中，两端渐进更新。
> 
> 
> 3. 请求优先级
> 每个流都有自己的优先级别，客户端可指定优先级，并可以做流量控制。
> 
> 
> 4. 服务端主动推送
> HTTP/2 让服务器可以响应主动 '推送' 资源到客户端缓存中。
> 例如我们加载 index.html，我们可能还需要 `index.js、index.css` 等文件。传统的请求只有当拿到 index.html，解析 html 中对 `index.js、index.css` 的引用才会再请求资源加载。
> 但是通过服务端数据，可以提前将资源推送给客户端缓存中，这样客户端需要使用时，直接调用缓存的资源即可，不用再发送请求。
> 
> 
> 5. 二进制协议
> 采用二进制协议，而不是像 `HTTP/1.X` 采用超文本协议的文本格式。客户(服务)端发送(接收)数据时，会将数据打散乱序发送，接收数据时，接收端再通过 `streamID` 标识来将数据合并。
> 二进制协议解析起来更高效，'线上'更紧凑，更重要的是错误更少。
> 
> 5.1 二进制分帧层
> 在二进制分帧层上，HTTP2.0会将所有传输的信息分割为更小的消息和帧，并对它们采用二进制格式的编码压缩，其中 HTTP1.x 的头部信息会被封装到 Headers 帧，而我们的 request body 则封装到 Data 帧里面。
>     - 维护一份相同的静态字典，包含常见的头部名称，以及常见的头部名称和值的组合。
>     - 维护一份相同的动态字典，可以动态的添加内容。
>     - 通过静态Huffman编码对传输的首部字段进行编码。
> 
> 
> ### 注意
> HTTP2 相对于 HTTP1.1 并不全是优点：因为 HTTP2 将多个HTTP 流放在同一个 TCP 连接中，遵循同一个流量状态控制。只要第一个 HTTP 流遇到阻塞，则后面的 HTTP 流就没办法发出去，这就是'行头阻塞'。
> 
> 
> ### http2.0 特点
> 1. 多路复用，并行请求
> 2. 二进制报头，分帧层（headers帧层和data帧层）
> 3. 对报头使用二进制格式编码化压缩，降低开销
> 4. 服务器主动推送，减少请求延时
> 5. 默认使用加密，增加伪头字段
> ```
>
> #### 多路复用
>
> ![image-20220818194817607](./image/image-20220818194817607.png)
>
> #### 二进制分帧层
>
> ![image-20220818194753613](./image/image-20220818194753613.png)

### `HTTP/3.0`

> ```bash
> ## HTTP/3.0
> HTTP/3.0 采用 `QUIC` 协议，基于 UDP 协议，避免了 TCP 协议的一些缺点，采用 TLS1.3 将 HTTPS 所需的 RTT 降至最少为 0。
> 
> 
> ### HTTP/3.0 在结合 HTTPS 下跟 HTTP/2.0 的对比
> - HTTP/2.0下：
> 		'HTTPS通信时间总和 = TCP连接时间 + TLS连接时间 + HTTP交互时间 = 1.5RTT + 1.5RTT + 1RTT = 4RTT'
> - HTTP/3.0下：
> 		- 首次链接时，QUIC 采用 TLS1.3，需要 1RTT，一次 HTTP 数据请求，共 2RTT。
> 		- 重连时直接使用 Session ID，不需要再次进行 TLS 验证，所以只需要 1RTT。
> 
> 
> ### TCP 协议的不足
> 1. TCP 可能会间歇性地挂起数据传输
> 如果一个序列号比较低的数据段还没有接收到，即使其他序列号较高的段已经接收到，TCP 的接收机滑动窗口也不会继续处理。这将导致 TCP 流瞬间挂起，在更糟糕的情况下，即使所有的段中有一个没有收到，也会导致关闭连接。这个问题被称为 TCP 流的行头阻塞（HoL）。
> 
> 2. TCP 不支持流级复用
> 虽然 TCP 确实允许在应用层之间建立多个逻辑连接，但它不允许在一个 TCP 流中复用数据包。使用 `HTTP/2.0` 时，浏览器只能与服务器打开一个 TCP 连接，并使用同一个连接来请求多个对象，如 `CSS、JavaScript` 等文件，在接收这些对象的同时，TCP 会将所有对象序列化在同一个流中。因此它不知道 TCP 段的对象级分区。
> 
> 3. TCP 会产生冗余通信
> TCP 连接握手会有冗余的消息交换序列，即使是与已知主机建立的连接也是如此。
> 
> 
> ### QUIC 协议的优势
> 1. 选择 UDP 作为底层传输层协议
> 在 TCP 之上建立新的传输机制，将继承 TCP 的上述所有缺点。因此 UDP 是一个明智的选择。此外，QUIC 是在用户层构建的，所以不需要每次协议升级时进行内核修改。
> 
> 2. 流复用和流控制
> QUIC 引入了连接上的多路流复用概念。QUIC 通过设计实现单独的、针对每个流的流控制，解决了整个连接的行头阻塞问题。
> 
> 3. 灵活的拥塞控制机制
> TCP 的拥塞控制是刚性的。该协议每次检测到拥塞时，都会将拥塞窗口大小减少一半。
> 相比之下，QUIC 的拥塞控制设计得更加灵活，可以更有效地利用可用的网络带宽，从而获得更好的吞吐量。
> 
> 4. 更好的错误处理能力
> QUIC 使用增强的丢失恢复机制和转发纠错功能，以更好地处理错误数据包，该功能对于那些只能通过缓慢的无线网络访问互联网的用户来说是福音，因为这些网络用户在传输过程中经常出现高错误率。
> 
> 5. 更快的握手
> QUIC 使用相同的 TLS 模块进行安全连接。但与 TCP 不同的是，QUIC 的握手机制经过优化，避免了每次两个已知对等者之间的建立通信时的冗余协议交换。
> 
> 
> ### http3.0 特点
> 1. 连接迁移
> 2. 无队头阻塞
> 3. 自定义的拥塞控制
> 4. 前向安全和前向纠错
> ```
>
> **TCP与QUIC的对比**
>
> ![image-20230113134619773](./image/image-20230113134619773.png)
>
> **TCP间歇性挂起数据传输示例图**
>
> ![image-20230113132620254](./image/image-20230113132620254.png)
>
> **TCP产生冗余通信示意图**
>
> ![TCP产生冗余通信示例图](./image/TCP_generates_redundant_communication_example_diagram.webp)

### `https`

> ```bash
> ## https
> 1. http: 是一个客户端和服务端请求和应答的标准（TCP），用于从 WWW 服务器传输超文本到本地浏览器的超文本传输协议。
> 2. https：是以安全为目标的 HTTP 通道，即 HTTP 下加入 SSL 层进行加密。其作用是建立一个信息安全通道，以来确保数据的传输，确保网站的真实性。
> 
> 
> ### https 协议的工作原理 
> 客户端在使用 https 方式与 web 服务器通信时有以下几个步骤：
>     1. 客户使用 https url 访问服务器，则要求 web 服务器建立 ssl 链接。
>     2. web 服务器接收到客户端的请求之后，会将网站的证书(证书中包含了公钥)，返回(传输)给客户端。
>     3. 客户端和 web 服务器端开始协商 ssl 链接的安全等级，也就是加密等级。
>     4. 客户端浏览器通过双方协商一致的安全等级，建立会话密钥，然后通过网站的公钥来加密会话密钥，并传输给网站。
>     5. web 服务器通过自己的私钥解密出会话密钥。
>     6. 服务器通过会话密钥加密与客户端之间的通信。
> 
> 
> ### http 和 https 的区别及优缺点
> 1. http 是超文本传输协议，信息是明文传输，https 协议要比 http 协议安全，https 是具有安全性的 ssl 加密传输协议，可防止数据传输过程中不被窃取、改变，确保了数据的完整性。
> 2. http 协议的默认端口为 80，https 的默认端口为 443。
> 3. http 的连接是无状态的。https 握手阶段比较耗时，会使页面加载时间延长 50%，增加 10%~20% 的耗电。
> 4. https 缓存不如 http 高效，会增加数据开销。
> 5. https 协议需要 ca 证书，费用较高，功能越强大的证书费用越高。
> 6. ssl 证书需要绑定 IP，不能在同一个 IP 上绑定多个域名，IPV4 资源支持不了这种消耗。
> 7. https 是现行架构下最安全的解决方案，虽然不是绝对安全，但是它大幅增加了中间人攻击的成本。
> 
> 
> ### Https
> 1. 本质的区别是：Https是密文传输数据，Http是明文传输数据。
> 2. Https在 Http 的基础上解决了以下 3 个问题：
> 		- HTTP通信使用明文(不加密)，内容可能会被窃听。
> 		- HTTP不验证通信方的身份，因此有可能遭遇伪装。
> 		- HTTP无法证明报文的完整性，所以有可能已遭篡改。
> ```

### `HTTP2 + HTTPS`的反优化策略

> ```bash
> ## `HTTP2 + HTTPS` 下产生的反优化策略
> 1. 减少请求数
> HTTP/1.1 因为存在'队头阻塞'，所以通常采用合并资源、捆绑文件(雪碧图等)等方式来减少请求数。
> 但在 HTTP/2.0 中我们更需要注重网站的缓存调优，传输轻量、细粒度的资源，方便独立缓存和并行传输。
> 
> 2. 多域名存储
> HTTP/1.1 因为浏览器有最大连接数限制，所以我们会将资源分发到不同的域名下存放以此来增大最大连接数。
> 但在 HTTP/2.0 中一个域只有一个连接，所以我们不需要去分多个域名存储，多域名存储甚至会造成额外的 TLS 消耗。
> ```

### 为什么 https 是安全的？

> ```bash
> ## 为什么 Https 是安全的？
> 1. Https 出现的原因
> 在 Https 出现之前，所有的请求都是以明文方式发送的，如果有人在传输中偷听或抓包的话，则你的所有通信内容都会泄露。
> 比较安全的方式是将通信内容加密后再发送给对方。加密方法有两种：对称加密和非对称加密。
> 
> 
> 2. 对称加密
> 对称加密指的是加密和解密用同一个密钥。
> 但是在通信之前，客户端和服务端不会有这样同一把密钥的。需要其中一方将密钥发送给对方。
> 在整个传输过程中没有任何验证操作，所以黑客也可以截取到这把密钥从而破译出加密的内容。
> 所以纯对称加密是不安全的。
> 
> 
> 3. 非对称加密
> 非对称加密是指加密和解密用不同的密钥。可以使用私钥加密，公钥解密；也可以公钥加密，私钥解密。
> 但是会有这种情况。服务端拥有私钥和公钥，将公钥发送给客户端。既然客户端可以拥有公钥，黑客也可以拥有公钥，那么服务端发送给客户端的所有内容黑客也可以解读的。
> 客户端用公钥加密发送给服务端不受影响，因为黑客没有服务器的私钥，所以纯非对称加密是不安全的。
> 
> 
> 4. Https 传输密钥的过程
> Https 采用对称加密来加密通信内容，所用的密钥称为 A。
> 用非对称加密来加密密钥 A 再发送给对方。
> 
> 
> 5. 为什么 Https 是可靠的？
> Https 是可靠的，因为它解决了三个问题：
> 	1. 加密通信，即使别人获取到信息也无法复原成原来的信息。
> 	2. 防止中间人攻击。黑客没法冒充服务端。因为在 2 步，服务端给客户端一个 CA 证书。
> 			- 如果客户端验证了这个证书，说明这个证书和公钥是由服务端发来的且真实可靠的。
> 			- 如果客户端验证不了这个证书，就说明这个证书不可靠，有可能是假的。
> 	3. CA 证书的公信力。CA 证书需要由公司或个人发出申请，再通过邮箱验证等方法验证域名存在。避免了黑客冒充网站获取证书的可能。
> 在技术层面上，CA 机构的公钥是写在操作系统或者浏览器里的。只有CA机构的私钥加密的内容才能完成解密。确保了证书的确是CA机构发行的。
> ```
>
> ![image-20230328152834836](./image/image-20230328152834836.png)
>
> ![image-20230328151112478](./image/image-20230328151112478.png)

## HTTP 缓存

> ```bash
> ## HTTP 缓存
> - 描述：http 缓存是在第一次获取资源后，根据返回的HTTP 响应头信息来告诉如何缓存资源。
> - 作用：HTTP缓存主要是为了防止用户重复请求相同资源而产生的解决方案。
> - 类别：HTTP缓存分为强制缓存和协商缓存。
> 
> - 强缓存是直接从浏览器缓存中获取资源，返回的状态码是200（若是设置缓存有效时间，超出有效时间则会发送请求到服务器来获取资源）
> - 协商缓存是由服务器来确定缓存志愿是否可用，存在缓存时返回状态码为304且不带响应体的报文，新资源则返回状态码为200且响应体为请求数据的报文。
> 
> 
> ### 缓存的优点
> - 减少了不必要的数据传输
> - 减轻了对服务器的压力，提升系统的性能
> - 加快了用户加载网页的速度
> - 提升了用户体验
> 
> 
> ### 缓存的缺点
> - 无法保证缓存数据与数据库中的数据保持同步
> - 可能会出现缓存失效
> 
> 
> ### 强缓存和协商缓存的区别
> 1. 强制缓存发生在浏览器端，协商缓存发生在服务器端。
> 2. 强制缓存在浏览器强制刷新的情况下不会生效，而协商缓存则不受影响。
> 3. 强制缓存返回的报文状态码为 200，协商缓存返回的报文状态码为 304。
> ```
>
> ![http缓存流程图](./image/http_caching_process.jpg)
>
> ![20210204170209785](./image/20210204170209785.png)

### 强缓存

> ```bash
> ### 强制缓存
> - 再次请求时无需向服务器发送请求，直接从浏览器缓存中获取资源，其请求返回的状态码是200。
> - 服务器通过设置 http 中响应头的 Expires 和 cache-control 字段告诉浏览器换存的有效期。
> - 缺点：这种方法会有一个固定时间，所带来的问题是如果服务器数据进行了更新，但是还没有到强缓存的过期时间，则数据无法更新。
> - 当 `Expires` 和 `Cache-Control` 同时存在时，优先考虑 `Cache-Control` 字段。当缓存资源失效(即没有命中强缓存)，接下来就进入协商缓存。
> 
> 
> ## 1. Response Headers 的 Cache-Control 字段
> - `Cache-Control`：具有强大的缓存控制能力，值为相对时间，如果与Expires同时设置的话，其优先级高于Expires。
>     - `max-age`：缓存有效时长，表示客户端在这个有效期内如果又请求该资源，就直接读取缓存。
>     - `no-cache`：禁止强缓存，但可以使用协商缓存。
>     - `no-store`：直接禁止浏览器缓存数据，每次用户请求该资源，都会向服务器发送一个请求。
>     - `public`：可以被所有的用户缓存，包括终端用户和 CDN 等中间代理服务器。但当用户重新刷新页面时就会重新发送请求获取资源。
>     - `private`：只让客户端可缓存该资源，不允许 CDN 等中继缓存服务器（代理服务器）对其缓存。
>     - `immutable`：表示即使用户重新刷新页面，也不会重新发送请求，还是直接读取缓存。
> 
> 注意：no-cache 与 no-store 的区别
>     -	no-cache 表示不缓存过期资源，缓存会向服务器进行有效处理确认之后，再处理资源。
>     - no-store 表示真正的不进行缓存。
> 
> 
> ## 2. Response Headers 的 Expires 字段
> - `Expires`：这个响应头具有严格的格式要求，其值固定格式为绝对时间。
> - 注意： Expires 是属于 HTTP 1.0，现在默认浏览器均默认使用 HTTP 1.1
> - 范例：`Expires: Mon, 25 Oct 2021 20:11:12 GMT`
> 
> 
> 
> ### 强制缓存流程图
>                client         server
> GET /a.ab389z.js ------->
>                       <------- 200 OK
> (再也不会发请求)
> ```
>
> ![image-20230227113939923](./image/image-20230227113939923.png)
>
> ![image-20230227113748135](./image/image-20230227113748135.png)
>
> ````js
> // nodejs 后端实现强缓存
> 
> const http = require('http')
> const fs = require('fs')
> const server = http.createServer((req, res) => {
>   const time = new Date()
>   time.setTime(time.getTime() + 100 * 1000) // 时间戳计算后 10s
>   const expires = time.toUTCString() // GMT（格林尼治标准时间）时间格式
>   res.setHeader('Expires', expires)
> 
>   // 优先级高于 Expires
>   res.setHeader('Cache-Control', 'max-age=30')
>   const html = fs.readFileSync('./src/index.html', 'utf8')
>   res.end(html)
> })
> server.listen(3000)
> ````

### 协商缓存

> ```bash
> ### 协商缓存
> - 协商缓存就是通过服务器来判断缓存是否可用。当同一个接口再次请求时，需要向服务器校验新鲜度。如果资源更新了，返回 200，从浏览器获取资源。
> - 当所设置的强缓存时间过期了，我们就可以使用协商缓存来解决问题。协商缓存需要请求，如果缓存有效会返回 304。协商缓存需要客户端和服务端共同实现。
> - 协商缓存主要是通过 Etag 和 Last-Modified 两个字段来实现：
>     - Etag 是一个用于映射 web 资源的映射 token，具有唯一性。
>     - Last-Modified 则通常是该资源最后更新的日期时间戳。
> 
> 
> ## 响应头的 Last-Modify 搭配 请求头的 If-Modify-Since
> Last-modify 表示该资源的最后修改时间。
> 当浏览器第一次请求一个资源时，服务器返回的 header 中会加上 Last-Modify。
> 当浏览器再次请求该资源时，request 的请求头中会包含 If-Modify-Since，该值服务端 header 中返回的 Last-Modify。
> 服务器收到 If-Modify-Since 后，根据资源的最后修改时间判断是否命中缓存。
> 
> 
> ## 响应头的 Etag 搭配 请求头的 If-None-Match
> web服务器响应请求时，会在 header 中加一个 Etag 用来告诉浏览器当前资源在服务器的唯一标识（生成规则由服务器决定）。
> 当再次向 web 服务器请求时带上头 If-None-Match（Etag的值）。web服务器收到请求后将 If-None-Match 的与 Etag 两者的值进行比对是否需要变动，有变动的话就将新的资源发送回来。并且 `ETag` 优先级⽐ `Last-Modified` 高。
> 
> 
> 
> ### `Last-Modified` 与 `ETag` 的对比
> - 性能上，`Last-Modified` 优于 `ETag`，
> 		1. Last-Modified 记录的是时间点，时间单位是秒，如果某个文件在1秒内改变了多次，那么它们的 Last-Modified 其实并没有体现出来修改。
> 		2. 而 Etag 需要根据文件的 MD5 算法生成对应的 hash 值。
> - 精度上，`ETag` 优于 `Last-Modified`
> 		1. ETag 按照内容给资源带上标识，能准确感知资源变化（需要服务器通过算法来计算出一个 hash 值）
> 		2. Last-Modified 只需要记录时间，在某些场景并不能准确感知变化。
> - 在优先级上，如果两者都存在，服务器校验优先判断 `If-None-Match` 进行 `ETag` 协商缓存
> 如果服务器收到的请求没有 Etag 值，则将 If-Modified-Since 和被请求文件的最后修改时间做比对，一致则命中协商缓存，返回 304。不一致则返回新的 Last-modified 和文件并返回 200。
> 
> 
> 
> ### 协商缓存流程图
>            client         server
> GET /a.js   ----------->
>                    <----------- 200 OK
> GET /a.js   ----------->
>                    <----------- 304 Not Modified
> 
> 
> 
> ### 缓存位置
> 当命中强缓存和协商缓存返回 304 时，浏览器会从缓存中获取资源。
> 浏览器的缓存一共有四种，按照优先级从高到低排列分别是：
>     1. Service Worker：借鉴了 WebWorker，其主要功能是：离线缓存(Service Woker Cache)、消息推送和网络代理。
>     2. Memory Cache：内存缓存。从效率上来讲，它是最快的；从存活时间来讲，它又是最短的。当渲染进程结束后，内存缓存就消失。
>     3. Disk Cache：存储在磁盘中的缓存，从存取效率上讲是比内存缓存慢的，优势在于存储容量和存储时长。
>     4. Push Cache：推送缓存，它是浏览器缓存的最后一道防线，它属于 HTTP/2.0 的内容。
> 
> 浏览器在选择 Disk Cache 与 Memory Cache 的存储上：
> 	内容使用率高的，文件优先进入磁盘。
> 	比较大的 JS/CSS 文件直接放入磁盘，反之放入内存中。
> ```
>
> ![image-20230227115931891](./image/image-20230227115931891.png)
>
> ![image-20230227115051965](./image/image-20230227115051965.png)
>
> #### nodejs 通过 lastModified 设置协商缓存
>
> ```js
> // nodejs 实现 协商缓存 示例
> // 缺陷是如果在本地打开缓存文件，就会造成 `Last-Modified` 被修改，所以在 HTTP/1.1 出现了 `ETag`
> 
> const http = require('http')
> const fs = require('fs')
> 
> const server = http.createServer((req, res) => {
>   const reqModified = req.headers['if-modified-since']
>   const info = fs.statSync('./src/index.html')
>   const lastModified = info.mtime.toUTCString() // GTM
> 
>   if (reqModified && reqModified === lastModified) {
>     console.log('浏览器走缓存')
>     res.statusCode = 304
>     res.end()
>     return
>   }
> 
>   res.setHeader('Last-Modified', lastModified)
>   const html = fs.readFileSync('./src/index.html', 'utf8')
>   res.end(html)
> })
> 
> server.listen(3000)
> ```
>
> #### nodejs 通过 Etag 和 lastModified 来实现协商缓存( `ETag` 优先级⽐ `Last-Modified` 高)
>
> ```js
> const http = require('http')
> const fs = require('fs')
> const crypto = require('crypto')
> 
> const server = http.createServer((req, res) => {
>   const buffer = fs.readFileSync('./src/index.html') // 二进制文件流
>   const hashTool = crypto.createHash('md5') // 使用 md5 加密算法
>   hashTool.update(buffer, 'utf8') // 注入二进制
>   const md5 = hashTool.digest('hex') // 生成 md5 加密的唯一标识 hash
>   const reqETag = req.headers['if-none-match']
>   if (reqETag && reqETag === md5) {
>     console.log('ETag 缓存')
>     res.statusCode = 304
>     res.end()
>     return
>   }
> 
>   const reqModified = req.headers['if-modified-since']
>   const info = fs.statSync('./src/index.html')
>   const lastModified = info.mtime.toUTCString() // GTM
> 
>   if (reqModified && reqModified === lastModified) {
>     console.log('modified 缓存')
>     res.statusCode = 304
>     res.end()
>     return
>   }
> 
>   res.setHeader('Last-Modified', lastModified)
>   res.setHeader('ETag', md5)
>   const html = fs.readFileSync('./src/index.html', 'utf8')
>   res.end(html)
> })
> 
> server.listen(3000)
> ```
>

### 利用 nginx 设置浏览器协商缓存

> ```bash
> ## 利用 nginx 设置浏览器协商缓存
> 1. nginx 下面的配置如下：
>       http {
>         server {
>           listen 80;
> 
>           location /picture/ {
>             # alias 是重定义路径， alias是替换，root是拼接
>             add_header Cache-Control no-cache;
>             alias D:/willy/picture/;
>             autoindex on;	# 访问127.0.0.1/picture/，会得到目录的索引界面
>           }
>         }
>       }
> 
> 2. 清除浏览器缓存后第一次发起请求会得到一个正常的 200 Response，而且响应头里已经有 `Cache-Control: no-cache` 表示使用协商缓存。
> 3. 再次发情请求后，会发现请求头已经带上 `If-Modified-Since` 和 `If-None-Match` 两项。
> 4. 服务端(Nginx)收到这两项后，会与资源当前生成的 Etag 和 Last-Modified 做比较，如果两者都一致，说明资源没有更新，服务端会返回 304 空响应；否则说明资源有更新，服务端会将完整的资源内容返回。
> 		注意：服务器验证 `If-Modified-Since` 的方式只是简单的字符串比较，即使资源的 `Last-Modified 比 If-Modified-Since` 要早，服务端仍认为资源有更新。
> 5. 浏览器在收到 304 响应后，会从浏览器缓存中取资源，因此速度非常快。
> ```



## 请求方法

```bash
## 请求方式

```



### options请求

```bash
## Option 请求
- HTTP 的请求：简单请求和非简单请求。
- OPTIONS 请求即预检请求，可用于检测服务器允许的 http 方法。当发起跨域请求时，由于安全原因，触发一定条件时浏览器会在正式请求之前 '自动' 先发起 OPTIONS 请求，即 'CORS预检请求'，服务器接受该跨域请求，浏览器才能继续发起正式请求。


### 简单请求
简单请求需要满足两个条件：
  1. 请求方法为：`HEAD、GET、POST`。
  2. http的请求头 headers 中不超出以下请求字段：
      - Accept
      - Accept-Language
      - Content-Language
      - Last-Event-ID
      - Content-Type：使用媒体类型值仅限于下列三个值：
          - text/plain
          - multipart/form-data
          - application/x-www-form-urlencoded


### 简单请求跨域，浏览器的不同处理方式
1. 对于简单请求而言，如果请求跨域，则浏览器会放行让请求发出。
2. 浏览器会发出 `cors` 请求，并在 http 请求头中携带 `origin`字段信息发送（origin 字段说明本次请求的来源(协议 + 域名 + 端口)）。
3. 此时不管服务端返回的是什么，浏览器都会把返回拦截，并检查返回的 `response` 的 `header` 中有没有 `Access-Control-Allow-Origin` 是否为 `true`。
		- 如果 Origin 指定的源不在许可范围内，服务端会返回一个正常的 HTTP 响应。当响应头信息中没有包含 `Access-Control-Allow-Origin` 字段，说明服务端没有开启资源共享，浏览器会认为这次请求失败，终止这次请求并且报错。
		- 如果 Origin 指定的域名在许可范围内，浏览器返回的响应会多出以下几个响应头信息字段。若为 true 则说明资源是共享的，可以拿到。
				- Access-Control-Allow-Origin: * （表示接受任意域名的请求）
				- Access-Control-Allow-Credentials: true（表示是否允许发送Cookie）
				- Access-Control-Expose-Headers: FooBar
				- Content-Type: text/html; charset=utf-8
			注意：因为 Cookie 遵循同源策略，如果要发送Cookie，Access-Control-Allow-Origin就不能设为星号*，必须指定明确的、与请求网页一致的域名。



### 非简单请求
只要不满足简单请求的条件，都认为是复杂请求。
发出非简单`cors`请求，浏览器会做一个 `http` 的查询请求（options 预检请求），options 请求会按照简单请求方式来处理。


1. 做一次 options 请求的原因：
浏览器先询问服务器当前网页所在的域名是否在服务器的许可名单之中(确认是否支持跨域请求)，以及可以使用哪些HTTP动词和头信息字段(确认实际请求的安全性)。只有得到肯定答复，浏览器才会发出正式的XMLHttpRequest请求，否则就报错。
预检请求的目的是为保护客户端的安全，防止不受信任的网站利用用户的浏览器向其它网站发送恶意请求。预检请求头中除了携带 origin 字段还包含两个特殊字段：
	- `Access-Control-Request-Method`：告知服务器实际请求使用的 http 方法。
	- `Access-Control-Request-Headers`：告知服务器实际请求所携带的自定义首部字段。
	
	
2. 什么时候触发预检请求？
    - 发送跨域请求时，请求头中包含了一些费简单请求的头信息，例如自定义头(custom header)等。
    - 发送跨域请求时，使用了 `PUT、DELETE、CONNECT、OPTIONS、TRACE、PATCH` 等请求方法。


3. 优化 options 请求：Access-Control-Max-Age 或者 避免触发
当请求一旦达到触发跨域，跨域请求便会一直发送 2 次请求。OPTIONS预检请求的结果可以被缓存（使用`Access-Control-Max-Age`设定个时限，当在所设定的时限内该请求不会触发 OPTIONS 请求）。
`Access-Control-Max-Age` 这个响应首部表示预检请求的返回结果（即Access-Control-Allow-Methods 和 Access-Control-Allow-Headers 提供的信息）可以被缓存的最长事件，单位是秒。
`Access-Control-Max-Age` 如果值为 `-1`，则表示禁用缓存，每一次请求都需要提供预检请求，即用 OPTIONS 请求进行检测。

```

![image-20230308173922986](./image/image-20230308173922986.png)

![image-20230308173849252](./image/image-20230308173849252.png)

### get和post请求的区别

```bash
## get 和 post 请求
- GET 和 POST 请求都是基于 TCP 连接的，但 get 是从指定的资源请求数据，post 是向指定的资源提交要被处理的数据。
1. '浏览器页面回退'：GET 请求在浏览器回退是无害的，POST 请求则需要再次提交请求的表单信息。
2. '历史记录'：GET 请求参数可保留在浏览器历史记录中，其 URL 地址也可被收藏，而POST无法保存。
3. '数据缓存'：GET 请求会被浏览器主动缓存，而 POST 请求需要手动设置才行。
4. '编码类型'：GET 请求只能进行 url 编码，而 POST 支持多种编码方式。
5. '数据长度限制'：因为 URL 地址最大长度为 2048 个字符(长度受限)，所以 GET 请求在 URL 中传递的参数是有长度限制的；而 post 请求的参数信息存放在请求体，所以没有长度限制，也允许二进制数据。
6. '数据类型限制'：GET 请求的参数数据类型只接受 ASCII 字符，而 POST 请求的参数数据类型则没有限制。
7. '可见/安全性'：因为 GET 请求的参数通过 URL 传递，POST 请求的参数存放在请求体中，导致 GET 相对于 POST 更不安全，所以不建议使用 get 来传递敏感信息。


注意：get请求的 params 参数不能传递数组和对象，需要对其进行转码才能进行发送请求。

```



## 请求技术

### XML语法

> ````bash
> ## XML 语法
> 1. XML 声明：
>     - `<?xml version="1.0" encoding="UTF-8"?>`
>     - （第一行的声明，指定了 XML 版本(1.0)以及使用的编码）
> 
> 2. 自定义标签：
>     - XML 中没有默认的标签，所有的标签都是我们自己已定义的（XML只有双标签）
>     - XML 中必须要有一个根节点，所有的子节点都放置在根节点下
> 
> 3. XML 解析：
> 		- 因为 XML 就是标签，所以我们可以直接用解析 Dom 元素的方法解析 XML
> 
> 
> ### XML 与 html 的区别
> 1. xml 是可扩展标记语言，类似 html，但与html不同的是，xml标签没有被预定义，需要自行定义标签。
> 2. xml 被设计用来传输和存储数据，其焦点是数据内容；
> 	xml 不是 html 的替代，html 被设计用来显示数据，其焦点是数据外观；
> 3. xml 具有自我描述性。
> ````

### Fetch

> - Fetch 是基于 Promise 设计的。Fetch 的代码结构比 AJAX 简单，参数类似 JQuery ajax。但是 Fetch 不是 ajax 的进一步封装（没有使用 XMLHttpRequest 对象），而是原生 js。
>   - 语法简洁，更加语义化。
>   - 脱离 XHR，是 ES 语法规范里的新视线方式。
>   - Fetch 只对网络请求报错，对 400、500 状态码都当做成功的请求。
>   - Fetch 默认不会带 cookie，需要添加配置项。
>
> ```js
> fetch('http://example.com/movies.json')
>   .then(function(response) {
>     return response.json();
>   })
>   .then(function(myJson) {
>     console.log(myJson);
>   });
> 
> 
> // Example POST method implementation:
> postData('http://example.com/answer', {answer: 42})
>   .then(data => console.log(data)) // JSON from `response.json()` call
>   .catch(error => console.error(error))
> 
> function postData(url, data) {
>   return fetch(url, {
>     body: JSON.stringify(data), // must match 'Content-Type' header
>     cache: 'no-cache', // *default, no-cache, reload, force-cache, only-if-cached
>     credentials: 'same-origin', // include, same-origin, *omit
>     headers: {
>       'user-agent': 'Mozilla/4.0 MDN Example',
>       'content-type': 'application/json'
>     },
>     method: 'POST', // *GET, POST, PUT, DELETE, etc.
>     mode: 'cors', // no-cors, cors, *same-origin
>     redirect: 'follow', // manual, *follow, error
>     referrer: 'no-referrer', // *client, no-referrer
>   })
>   .then(response => response.json()) // parses response to JSON
> }
> ```

### AJAX

> ```bash
> ## AJAX
> ### 发送AJAX请求的步骤
> 1. 创建异步对象，即 `XMLHttpRequest` 对象。
> 2. 使用 open 方法设置请求参数。`open(method, url, async)`。
>      1. method：请求的类型；GET 或 POST
>      2. url：文件在服务器上的位置
>      3. async：true(异步)或 false(同步)，不写默认为true
> 3. 使用 res.send() 发送请求：
> 	`response.send()`。注意：send()仅用于 POST 请求
> 4. 注册事件：
> 		注册 onreadystatechange 事件，状态改变时就会调用。
> 		如果要在数据完整请求回来的时候才调用，则要手动写一些判断的逻辑。
> 5. 服务端响应，获取返回的数据。
> 
> 
> 
> ### onreadystatechange 事件
>     - 注册 onreadystatechange 事件后，每当 readyState 属性改变时，就会调用 onreadystatechange 函数
>     - readyState：（存有 XMLHttpRequest 的状态）
>         - 0: 请求未初始化
>         - 1: 服务器连接已建立
>         - 2: 请求已接收
>         - 3: 请求处理中
>         - 4: 请求已完成，且响应已就绪
>     - status：
>         - 200: "OK"
>         - 404: 未找到页面
>     - 在 onreadystatechange 事件中，当 readyState 等于 4，且状态码为 200 时，表示响应已就绪
> 
> 
> ### 服务器响应的内容
>     - responseText：获得字符串形式的响应数据
>     - responseXML：获得 XML 形式的响应数据
> 
> 
> ### AJAX 禁用缓存
> AJAX 能提高页面载入速度的主要原因是通过 ajax 减少重复数据的载入，即在载入数据的同时将数据缓存到内存中，一旦数据被加载其中，只要没有刷新页面，这些数据就会一直被缓存在内存中，使得当我们提交的请求 Url 与 历史 Url 一致时，就不需要提交给服务器，虽然如此可以降低服务器的负载以提高用户的体验，但会让我们无法获取最新的数据信息。
> 为了保证读取的信息都是正确的，就需要禁止 ajax 的缓存功能。
>     1. 可在 ajax 发送请求前添加：`xhr.setRequestHeader("If-Modified-Since", "0")`
>     2. 或在 ajax 发送请求前添加：`xhr.setRequestHeader("Cache-Control", "no-cache")`
> 
> 
> ### Ajax 与 Flash 的优劣
> AJAX：
> 		- AJAX优势：可搜索性、开放性、费用、易用性、易于开发
> 		- AJAX劣势：可能破坏浏览器的后退功能、使用动态页面更新使得用户难以将某个特定的状态保存到收藏夹中
> Flash:
>     - flash优势：多媒体处理、兼容性、矢量图、客户端资源调度
>     - flash劣势：二进制格式、格式私有、flash文件经常很大，用户第一次使用时需要忍耐较长的等待时间、性能问题
> ```
>
> #### 完整的AJAX请求
>
> ```js
> //【发送get请求】
> const xhr1 = new XMLHttpRequest();
> xhr1.open('get', '02-ajax.php');
> xhr1.send();
> xhr1.onreadystatechange = function () {
>   if (xhr1.readyState == 4 && xhr1.status == 200) {
>     console.log('数据返回成功：' + JSON.stringify(xhr1.responseText));
>   }
> };
> 
> 
> // 异步对象【发送post 请求】
> const xhr2 = new XMLHttpRequest();
> xhr2.open('post', '02.post.php');
> // 如果想要使用post提交数据,必须设置如下请求头
> xhr2.setRequestHeader('Content-type', 'application/x-www-form-urlencoded');  
> xhr2.send('name=fox&age=18');
> xhr2.onreadystatechange = function () {
>   if (xhr2.readyState == 4 && xhr2.status == 200) {
>     console.log(xhr2.responseText);
>   }
> };
> ```
>
> #### 封装AJAX
>
> ```js
> // 封装 Ajax为公共函数：传入回调函数 success 和 fail
> function myAjax(url, success, fail) {
>   let xhr;
>   if (window.XMLHttpRequest) {
>     xhr = new XMLHttpRequest();
>   } else {
>     xhr = new ActiveXObject('Microsoft.XMLHTTP'); // 兼容IE5、IE6浏览器
>   }
>   xhr.open('GET', url, true);
>   xhr.send();
>   // 服务端响应
>   xhr.onreadystatechange = function () {
>     if (xhr.readyState === 4 && xhr.status === 200) {
>       console.log('数据返回成功：' + JSON.parse(xhr.responseText));
>       success && success(xhr.responseText);
>     } else {
>       //  当存在 fail 参数才跳出错误
>       fail && fail(new Error('接口请求失败'));
>     }
>   };
> }
> 
> // 单次调用 ajax
> myAjax('a.json', (res) => {
>   console.log(res);
> });
> 
> // 多次调用 ajax。接口请求顺序：a --> b --> c
> myAjax('a.json', (res1) => {
>   console.log(res1);
>   myAjax('b.json', (res2) => {
>     console.log(res2);
>     myAjax('c.json', (res3) => {
>       console.log(res3);
>     });
>   });
> });
> ```

### fetch、ajax、axios 的区别

> ```bash
> ## fetch、ajax、axios 的区别
> 1. AJAX
>     - AJAX 的核心是 XMLHttpRequest 对象，全称为异步的js与xml（Async JavaScript And XML）。
>     - AJAX 的优点是可实现页面局部刷新，进行异步网络请求。
>     - 拥有打开AJAX请求、设置http请求头、发送ajax请求的方法；还有响应请求 onreadystatechange 的回调事件、以及响应返回的状态。
>     - AJAX 基于原生的 XHR 开发，如果多个请求之间如果有先后关系的话，就会出现回调地狱问题。
> 
> 
> 2. Fetch
>     - Fetch 是基于 Promise 设计的。Fetch 的代码结构比 AJAX 简单，参数类似 JQuery ajax。但是 Fetch 不是 ajax 的进一步封装（没有使用 XMLHttpRequest 对象），而是原生 js。
>     - 语法简洁，更加语义化。
>     - 脱离 XHR，是 ES 语法规范里的新实现方式。
>     - Fetch 只对网络请求报错，对 400、500 状态码都当做成功的请求。
>     - Fetch 默认不会带 cookie，需要添加配置项。
>     
> 
> 3. axios
> 		- axios 即提供了并发的封装，也没有 fetch 的各种问题，而且包体积小，所以现在大多选用 axios 作为请求的方式。
> ```

### WebSocket

>```bash
>## WebSocket
>- WebSocket 是 HTML5 提供的一种浏览器与服务器进行全双工通讯的网络技术，属于应用层协议。它基于TCP传输协议，并复用HTTP的握手通道。
>- WebSocket 支持持久连续，Http1.0 和 HTTP1.1 协议不支持持久性连接，HTTP1.1 中的 keep-alive 将多个 http 请求合并为 1 个。
>- 优点：WebSocket 建立 TCP 连接后，服务器可以主动给客户端传递数据，能够更好的节省服务器资源和带宽，实现更实时的数据通讯。
>- 缺点：WebSocket为了保持客户端、服务端的实时双向通信，需要确保客户端、服务端之间的TCP通道保持连接没有断开。然而，对于长时间没有数据往来的连接，如果依旧长时间保持着，可能会浪费包括的连接资源。
>
>
>- 轮询请求的缺点
>		- 在以前，很多网站为了实现数据推送，所用的技术都是ajax轮询。轮询是在特定的时间间隔，由浏览器主动发起请求，将服务器的数据拉回来。轮询需要不断的向服务器发送请求，会占用很多带宽和服务器资源。
>
>- 对WebSocket封装并且与浏览器向下兼容的 socket.io
>		- Node的单线程、非阻塞I/O、事件驱动机制非常适合 Socket服务器：`npm install socket.io`
>
>
>- WebSocket的优点：
>HTTP 的生命周期通过Request 来界定，也就是Request 一个Response，那么在Http1.0 协议中，这次Http 请求就结束了。
>在Http1.1 中进行了改进，添加了一个connection方法： 即在一个Http 连接中，可以发送多个Request，接收多个Response。
>但是在Http 中一个Request 只能对应有一个Response，而且这个Response 是被动的，不能主动发起。
>WebSocket 是基于Http 协议的，也可理解为 Http 协议来完成一部分握手，在握手阶段 与Http 是相同的。
>一个websocket 握手协议的实现，主要是基于 upgrade、connection 这两个属性。
>
>
>#### websocket请求数据渲染，导致卡顿的优化
>- 原因：websocket发送数据或者接收数据是不会卡死的，只有当接收消息时频繁更改页面数据才会造成卡顿。
>- 优化：不要一收到数据就进行渲染，可以利用定时器每秒渲染或者使用 DocumentFragment
>      1. 降低发送频率
>      2. 优化处理过程
>      3. 先获取数据，定时处理
>```
>
>```js
>// 创建 WebSocket 对象
>const Socket = new WebSocket(url, [protocol] ); 
>
>// WebSocket 属性
>Socket.readyState // 只读属性readyState表示连接状态
>// 0 - 连接尚未建立
>// 1 - 连接已建立，可以进行通信
>// 2 - 连接正在进行关闭
>// 3 - 连接已经关闭或者连接不能打开
>
>// WebSocket 事件
>Socket.onopen // 连接建立时触发
>Socket.onmessage // 客户端接收服务端数据时触发
>Socket.onerror // 通信发生错误时触发
>Socket.onclose // 连接关闭时触发
>
>// WebSocket 方法
>Socket.send(JSON.stringify()) // 使用连接发送数据	注意：因为数据需要JSON对象格式，所以需要转换
>Socket.close() // 关闭连接
>```

#### Sec-WebSocket-Key/Accept的作用

> ```bash
> Sec-WebSocket-Key/Sec-WebSocket-Accept在主要作用在于提供基础的防护，减少恶意连接、意外连接。
> 
> 作用大致归纳如下：
>     1. 避免服务端收到非法的websocket连接（比如http客户端不小心请求连接websocket服务，此时服务端可以直接拒绝连接）
>     2. 确保服务端理解websocket连接。因为ws握手阶段采用的是http协议，因此可能ws连接是被一个http服务器处理并返回的，此时客户端可以通过Sec-WebSocket-Key来确保服务端认识ws协议。（并非百分百保险，比如总是存在那么些无聊的http服务器，光处理Sec-WebSocket-Key，但并没有实现ws协议。。。）
>     用浏览器里发起ajax请求，设置header时，Sec-WebSocket-Key以及其他相关的header是被禁止的。这样可以避免客户端发送ajax请求时，意外请求协议升级（websocket upgrade）
>     3. 可以防止反向代理（不理解ws协议）返回错误的数据。比如反向代理前后收到两次ws连接的升级请求，反向代理把第一次请求的返回给cache住，然后第二次请求到来时直接把cache住的请求给返回（无意义的返回）。
>     4. Sec-WebSocket-Key主要目的并不是确保数据的安全性，因为Sec-WebSocket-Key、Sec-WebSocket-Accept的转换计算公式是公开的，而且非常简单，最主要的作用是预防一些常见的意外情况（非故意的）。
>     
> 强调：Sec-WebSocket-Key/Sec-WebSocket-Accept 的换算，只能带来基本的保障，但连接是否安全、数据是否安全、客户端/服务端是否合法的 ws客户端、ws服务端，其实并没有实际性的保证。
> ```

### WEB应用从服务器主动推送数据到客户端的方式

> ```bash
> ## WEB应用从服务器主动推送数据到客户端的方式
> 1. html5 的 websocket
> 2. websocket 通过 Flash
> 3. XHR 长时间连接
> 4. 不可见的 iframe
> 5. <script> 标签的长时间连接(可跨域)
> 6. ajax 轮询调用请求
> 
> 
> 
> ### Ajax 轮询
> Ajax 轮询是定时通过 Ajax 查询服务端，客户端按规定定时向服务端发送 ajax 请求，服务器接到请求后马上返回响应信息并关闭连接。
> 优点： 逻辑简单容易实现。
> 缺点：
>     * 需要不断向服务器发送消息询问，请求中有大半是无用，浪费带宽和服务器资源。
>     * 通过模拟服务器发起的通信，不是实时通信，不顾及应用的状态改变并且盲目检查更新，导致服务器资源浪费，且会加重网络负载，拖累服务器。
>     * 前端长时间处于轮询占用CPU，并且由于JS是单线程，轮询间隔无法保证。
> 实例：适于小型应用。
> 
> 
> ### WebSocket 通过 Flash
> Flash Socket：在页面中内嵌入一个使用了Socket类的 `Flash` 程序，`JavaScript`通过调用此`Flash`程序提供的Socket接口与服务器端的Socket接口进行通信，JavaScript在收到服务器端传送的信息后控制页面的显示。
>  * 优点：实现真正的即时通信，而不是伪即时。
>  * 缺点：客户端必须安装Flash插件；非HTTP协议，无法自动穿越防火墙。
>  * 实例：网络互动游戏。
> 
> 
> ### XHR 长时间连接（长轮询）
> 客户端打开一个到服务器端的 `AJAX` 请求然后等待响应；服务器端需要一些特定的功能来允许请求被挂起，只要一有事件发生，服务器端就会在挂起的请求中送回响应并关闭该请求。
> 客户端 JavaScript 响应处理函数会在处理完服务器返回的信息后，再次发出请求，重新建立连接；如此循环。
> 优点： 
>  		 * 对于前端来说实现简单，与普通的网络请求没有太大区别。
>  		 * 在无消息的情况下不会频繁的请求。
> 缺点： 
>  		 * 需要服务器端有特殊的功能来临时挂起连接，服务器hold连接会消耗资源。
>  		 * 客户端发起的连接较多时，服务器端会长期保持多个连接，具有一定的风险。
> 实例：WebQQ、Hi网页版、Facebook IM。
> 
> 
> ### 不可见的iframe（长连接）
> 在页面中嵌入一个隐藏的`iframe`，将这个隐藏的`iframe`的`src`属性设置为对一个长连接的请求或者采用XRH请求，服务器端就能源源不断地往客户端输入数据。
>  * 优点：消息即时到达，不发无用的请求；管理起来也相对方便。
>  * 缺点：服务器维护一个长连接会增加开销。
>  * 实例：Gmail聊天
> 
> 
> ### `<script>` 标签
> 把 script 标签附加到页面上以让脚本执行。服务器会挂起连接直到有事件发生，接着把脚本内容发送回浏览器，然后重新打开另一个 script 标签来获取下一个事件，从而实现长轮询的模型。
> 	 * 缺点：前后端实现都很麻烦
> 	 
> 	 
> ### html5 websocket
> `WebSocket`是HTML5开始提供的一种在单个 `TCP` 连接上进行全双工通讯的协议。
> 在WebSocket API中，浏览器和服务器只需要做一个握手的动作，然后，浏览器和服务器之间就形成了一条快速通道。两者之间就直接可以数据互相传送。
>  * 优点： 实现简单、可靠。
>  * 缺点： 部分低版本浏览器可能不支持。
> ```

## HTTP状态码

### 状态码概述

> ```bash
> # 1xx：信息响应，临时响应并需要请求者继续执行操作
> 100   （继续） 请求者应当继续提出请求。 服务器返回此代码表示已收到请求的第一部分，正在等待其余部分。  
> 101   （切换协议） 请求者已要求服务器切换协议，服务器已确认并准备切换。
> 
> 
> # 2xx：成功响应
> 200     成功处理了请求，一般情况下都是返回此状态码； 
> 201     请求成功并且服务器创建了新的资源。 
> 202     接受请求但没创建资源。
> 203     返回另一资源的请求。
> 204     服务器成功处理了请求，但没有返回任何内容。
> 205     服务器成功处理了请求，但没有返回任何内容。
> 206     处理部分请求。
> 
> 
> # 3xx：重定向消息
> 300   （多种选择）  针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。 
> 301   （永久移动）  请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。 
> 302   （临时移动）  服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。 
> 303   （查看其他位置） 请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。 
> 304   （未修改） 自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。 
> 305   （使用代理） 请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用代理。 
> 307   （临时重定向）  与302状态码相似，用于post请求，它不允许更改http方法
> 308		 (永久重定向)	与301状态码相似，用于post请求，它不允许更改http方法
> 
> 
> # 4xx：客户端错误响应
> 400   服务器无法理解和处理请求，一般为参数错误或请求地址错误。
> 401   （用户未经授权）对于需要登录的网页，服务器可能返回此响应，需要用户验证 
> 403   （资源访问权限不足）请求者对资源的访问权限不足
> 404   （未找到请求资源）
> 405   禁用请求中指定的方法。 
> 406   无法使用请求的内容特性响应请求的网页。 
> 407   此状态代码与 401类似，但指定请求者应当授权使用代理。 
> 408   服务器等候请求时发生超时。 
> 409   （在请求时发生冲突）当客户端试图执行一个会导致一个或多个资源处于不一致状态的操作时。 
> 410   （所请求资源已移除）由于有意移除，因此请求不再可用
> 411   服务器不接受不含有效内容长度标头字段的请求。 
> 412   服务器未满足请求者在请求中设置的其中一个前提条件。 
> 413   服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。 
> 414   请求的 URI（通常为网址）过长，服务器无法处理。 
> 415   请求的格式不受请求页面的支持。 
> 416   如果页面无法提供请求的范围，则服务器会返回此状态代码。 
> 417   服务器未满足”期望”请求标头字段的要求。
> 
> 
> # 5xx：服务端错误响应
> 500   （服务器内部错误）  通用未处理的服务器错误
> 501   （尚未实施） 服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码。
> 502   （网关错误） 服务器作为网关或代理，从上游服务器收到无效响应
> 503   （服务不可用） 服务器暂时无法处理请求（由于超载或停机维护）
> 504   （网关超时）  服务器作为网关或代理，但是未及时从上游服务器获得请求。 
> 505   （HTTP 版本不受支持） 服务器不支持请求中所用的 HTTP 协议版本
> 
> 
> # 参考：
> [Mozilla HTTP 响应状态码](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status)
> ```

### 连接服务器超时

> - 服务器连接超时就是在程序默认的等待时间内没有得到服务器的响应，可能造成网络连接超时的原因
>   1. 网络断开，不过经常显示无法连接
>   2. 网络阻塞，导致不能在程序默认等待时间内得到回复数据包
>   3. 网络不稳定，网络无法完整传送服务器信息
>   4. 系统问题，系统资源过低，无法为程序提供足够的资源处理服务器信息
>   5. 设备不稳定，如网线松动、接口没插好等等
>   6. 网络注册时系统繁忙，无法回应
>   7. 网速过慢，如使用BT多线程下载，在线收看视频等大量占用带宽的软件，若使用共享带宽还要防范他人恶意占用带宽
>   8. 计算机感染了恶意软件，计算机病毒，计算机木马等

### URL重定向 301/302

> ```bash
> # HTTP URL 重定向概述
> URL 重定向是一种将网络访问者从一个网页 URL 地址映射到另一个网页 URL 地址的 WEB 服务器技术（被映射的URL地址可以进跨域）。
> 当用户访问其浏览器中的某个 URL 时，服务器会发回一条消息，告诉浏览器改为访问其他 URL
> 
> 
> # HTTP 重定向的目的
> 1. 有时以前的域名太长且难以记住，或者某些侵权活动迫使您从一个域转移到另一个域
> 2. 转发多个域：需要永久 HTTP 重定向，以将互联网用户和搜索引擎引导到同一位置，同时同时拥有多个域名。
> 3. 断开链接的识别：可以使用 Google Search Console 识别 404 未找到的页面。覆盖率报告将为您提供有关所有现场入站链接的详细信息，以便在重定向的帮助下修复。
> 4. 修复损坏的 URL：识别损坏的链接后，可以将用户访问流量重定向到首页。但是，更好的选择是将每个损坏的 URL 重定向到具有相同（相似）内容的新页面。
> 5. 页面的新位置：若以前的网站访问量高且在 SERP 中排名靠前的页面，重定向可将此 URL 映射到新位置。对于这种情况，必须确保用于重定向的旧页面没有消失。
> 6. 删除页面的需要：为需要删除的所有页面创建 HTTP 重定向，并确保不要因 404 not found 错误而对访问者感到恐惧和压力。重定向将向 Google 或其他搜索引擎发出信号，表明旧链接的链接值应分配给重定向的 URL。
> 
> 
> # 常见 URL 重定向类型
>   - 301（永久重定向）:旧地址的资源已经被永久删除，搜索引擎在抓取新内容的同时也将旧的网站替换为重定向后的地址，并且告诉浏览器（和搜索引擎）他们将来应该使用更新的 URL
>   - 302（临时重定向）：旧地址的资源还在，这个重定向只是临时从旧地址跳转到新地址，搜索引擎会抓取新的内容且保存旧地址，浏览器和搜索引擎应继续请求原始 URL
> 
> 
> # 301 永久重定向与 302 临时重定向的区别
>     1、 301重定向可促进搜索引擎优化效果
>     从搜索引擎优化角度出发，301重定向是网址重定向最为可行的一种办法。当网站的域名发生变更后，搜索引擎只对新网址进行索引，同时又会把旧地址下原有的外部链接如数转移到新地址下，从而不会让网站的排名因为网址变更而收到丝毫影响。同样，在使用301永久性重定向命令让多个域名指向网站主域时，亦不会对网站的排名产生任何负面影响。
> 
>     2、 302重定向可影响搜索引擎优化效果
>     迄今为止，能够对302重定向具备优异处理能力的只有Google。也就是说，在网站使用302重定向命令将其它域名指向主域时，只有Google会把其它域名的链接成绩计入主域，而其它搜索引擎只会把链接成绩向多个域名分摊，从而削弱主站的链接总量。既然作为网站排名关键因素之一的外链数量受到了影响，网站排名降低也是很自然的事情了。
> ```
>
> ![image-20220821170833515](./image/image-20220821170833515.png)
>
> ![img](./image/http_Redirect.png)

#### 301 与 302 的区别

> ```bash
> ## 301 与 302 的区别
> ### 1. 缓存
> 对于 301 请求，浏览器是默认给一个很长的缓存。而 302 是不缓存的，只有在 Cache-Control 或 Expires 中进行指定的情况下，这个相应才是可缓存的。
> 
> 
> ### 2. 搜索引擎
> - 301：旧地址A的资源不可访问(永久移除)，重定向到网址B，搜索引擎会抓取网址B的内容，同时将网址保存为B网址。
> - 302：旧地址A的资源仍可访问，这个重定向只是临时从旧地址A跳转到B地址，这时搜索引擎会抓取B网址内容，但是会将网址保存为A的。
> 
> 
> 
> ## 302 导致网址劫持
> 搜索引擎在大部分情况下，当收到 302 重定向时，有时搜索引擎（尤其是Google）并不能总是抓取目标网址。
> 比如，有时 A 网址很短，但是它做了一个 302 重定向到 B 网址，而 B 网址是一个很长且杂乱的 URL 网址，甚至还可能包含一些问号之类的参数。此时很显然 A 网址对用户体验感更加友好，这时 Google 很有可能会仍然显示网址 A。
> 搜索引擎排名算法在遇到 302 重定向时，并不能准确判定哪一个网址更适当，这就造成了网址 URL 劫持的可能性。
> 即如果一个不道德的人在他自己的网址A做一个302重定向到你的网址B，出于某种原因，Google 搜索结果所显示的仍然是网址A，但是所用的网页内容却是网址B上的内容，这种情况就叫做网址URL劫持。
> ```

#### 浏览器清除重定向小技巧

> - 如果有一个令人讨厌的 301 重定向无法清除，请打开开发工具勾选 **disable cache** 选项
> - ![image-20220821170941388](./image/image-20220821170941388.png)

## 内容分发网络 CDN

> ```bash
> ## 内容分发网络 CDN（Content Delivery Network）
> CDN 的目的是通过在现有的 Internet 中增加一层新的网络架构，将网站的内容发布到最接近用户的网络“边缘”，使用户可以就近取得所需的内容，提高用户访问网站的响应速度。
> CDN 有别于镜像，因为它比镜像更智能，可理解为：'CDN = 更智能的镜像 + 缓存 + 流量导流'。
> 因而，CDN 可以明显提高 Internet 网络中信息流动的效率。从技术上全面解决了网络带宽小、用户访问量大、网点分布不均等问题，提高用户访问网站的响应速度。
> 
> 
> ### CDN 解决了什么问题？
> 一般网络请求场景下有下面四个问题：
>     1. 带宽限制。
>         作为一个服务器，由于受到带宽限制，所能承受的网络并发请求量和连接数是有限的。容易成为服务能力的瓶颈。
>     2. 延时和拥塞。
>         从客户端发起请求到服务端返回数据，中间会经过很长且复杂的网络环境，如：IDC、骨干网、城域网、接入网等，任何一个环境出现小小的问题都让这个请求发生延迟或拥塞。
>     3. 网络运营商跨越问题。
>         有时网络请求可能从联通的网络到电信，这个可能会导致网络延迟。
>     4. 客户端的网络限流。
>         有时客户端的网络状况会有问题，受到终端运行商的共享带宽限制。
> 		
> 
> ### CDN 流程图
> CDN 工作流程是：
>     1. 当用户访问已经加入 CDN 服务的网站时，首先通过 DNS 重定向技术确定最接近用户的最佳 CDN 节点，同时将用户的请求指向该节点。
>     2. 当用户的请求到达指定节点时，CDN的服务器(节点上的高速缓存)负责将用户请求的内容提供给用户。
> 
> 具体流程：
>     1. 用户在自己的浏览器输入要访问的网站的域名；
>     2. 浏览器向本地 DNS 请求对该域名的破解；
>     3. 本地 DNS 将请求发到网站的主 DNS；
>     4. 主 DNS 根据一系列的策略确定当时最适当的 CDN 节点，并将解析的结果(IP地址)发给用户；
>     5. 用户向给定的 CDN 节点请求相应网站的内容。
> 
> 
> ### CDN 相关技术
> CDN 的声线需要依赖多种网络技术的支持，其中主要包括负载均衡技术、动态内容分发与复制技术、缓存技术等。
> 
> 1. 负载均衡技术
> 负载均衡技术不仅仅应用于CDN中，如服务器的负载均衡、网络流量的负载均衡。
> 网络中的负载均衡就是将网络的流量尽可能均匀分配到几个能完成相同任务的服务器或网络节点上，由此来避免部分网络节点过载。这样既可以提高网络流量，又提高了网络的整体性能。
> 在CDN中，负载均衡又分为服务器负载均衡和服务器全局负载均衡。
> 服务器负载均衡是指能够在性能不同的服务器之间进行任务分配，既能保证性能差的服务器不成为系统的瓶颈，又能保证性能高的服务器的资源得到充分利用。
> 而服务器全局负载均衡允许Web网络托管商、门户站点和企业根据地理位置分配内容和服务。通过使用多站点内容和服务来提高容错性和可用性，防止因本地网或区域网络中断、断电或自然灾害而导致的故障。
> 在CDN的方案中服务器全局负载均衡将发挥重要作用，其性能高低将直接影响整个CDN的性能。
> 
> 
> 2. 动态分发与复制技术
> 网站访问响应速度取决于许多因素，如网络的带宽是否有瓶颈、传输途中的路由是否有阻塞和延迟、网站服务器的处理能力及访问距离等。
> 多数情况下，网站响应速度和访问者与网站服务器之间的距离有密切关系。如果访问者和网站之间的距离过远，它们之间的通信一样需要经过重重的路由转发和处理，网络延误不可避免。
> 一个有效的方法就是利用内容分发与复制技术，将占网站主体的大部分静态网页、图像和流媒体数据分发复制到各地的加速节点上。
> 
> 
> 3，缓存技术
> 一般可通过Web缓存服务来改善用户请求的响应时间，如代理缓存服务、透明代理缓存服务、使用重定向服务的透明代理缓存服务等。
> 通过Web缓存服务，用户访问网页时可以将广域网的流量降至最低。
> 	对于公司内联网用户来说，这意味着将内容在本地缓存，而无须通过专用的广域网来检索网页。
> 	对于Internet用户来说，这意味着将内容存储在他们的ISP的缓存器中，而无须通过Internet来检索网页。
> 这样无疑会提高用户的访问速度。CDN的核心作用正是提高网络的访问速度。
> 
> 
> 
> ### CDN 工作原理
> CDN 网络是在用户和服务器之间增加 Cache 层，主要通过接管 DNS 实现，将用户的请求引导到 Cache 上获得源服务器的数据，从而降低网络的访问时间。
> 
> 传统网络的访问流程：
>     1. 用户输入访问的域名，操作系统向 LocalDns 查询域名的 IP 地址；
>     2. LocalDns 向 Root DNS 查询域名的授权服务器(这里假设 LocalDns 缓存过期)；
>     3. ROOT DNS 将域名授权 dns 记录回应给 LocalDns；
>     4. LocalDns 得到域名的授权 dns 记录后，继续向域名授权 dns 查询域名的 ip 地址；
>     5. 域名授权 dns 查询域名记录后，回应给 LocalDns；
>     6. LocalDns 将得到的域名 ip 地址回应给用户端；
>     7. 用户得到域名 ip 地址后，访问站点服务器；
>     8. 站点服务器应答请求，将内容返回给客户端。
> 
> 使用 CDN 缓存后的网络访问流程：
>     1. 用户输入访问的域名，操作系统向 LocalDns 查询域名的 IP 地址；
>     2. LocalDns 向 Root DNS 查询域名的授权服务器(这里假设 LocalDns 缓存过期)；
>     3. ROOT DNS 将域名授权 dns 记录回应给 LocalDns；
>     4. LocalDns 得到域名的授权 dns 记录后，继续向域名授权 dns 查询域名的 ip 地址；
>     5. 域名授权 dns 查询域名记录后(一般是CNAME)，回应给 LocalDns；
>     6. LocalDns 得到域名记录后，向智能调度 DNS 查询域名的 IP 地址；
>     7. 智能调度 DNS 根据一定的算法和策略(比如静态拓扑、容量等)，将最适合的 CDN 节点 IP 地址回应给 LocalDns；
>     8. LocalDns 将得到的域名 IP 地址回应给用户端；
>     9. 用户得到域名 IP 地址后，访问站点服务器。
> ```
>
> ![image-20230309110016109](./image/image-20230309110016109.png)
>
> #### 使用 CDN 缓存后的网络结构
>
> ![image-20230309155713872](./image/image-20230309155713872.png)
>
> #### 传统的网络结构
>
> ![image-20230309155756692](./image/image-20230309155756692.png)



## 接口规范 - RESTful架构

### RESTful接口设计

```bash
## 接口规范 - RESTful 架构
### 什么是 REST
REST（Representational State Transfer：表述性状态转移），REST 指一组架构约束条件和原则。如果一个架构符合 REST 的约束条件和原则就可称它未 RESTful 架构。
RESTful 理念是使用 Web 现有特征和能力更好地使用现有 Web 的现有特征和能力，更好地使用现有 Web 标准中的一些准则和约束。虽然 REST 本身受 Web 技术的影响很深，但是理论上 REST 架构风格并不是绑定在 HTTP 上，只不过目前 HTTP 是唯一与 REST 相关的实例。


### Restful 接口规范 
1. 使用HTTP方法来表示资源的操作：使用HTTP方法（GET、POST、PUT、PATCH、DELETE等）来表示对资源的不同操作，如获取资源、创建资源、更新资源、删除资源等。
2. 使用URI来标识资源：使用URI（统一资源标识符）来标识资源，例如：/users/{id} 表示获取指定ID的用户信息。
3. 使用HTTP状态码来表示请求结果：根据不同的操作结果，返回相应的HTTP状态码，如200表示成功、400表示请求错误、404表示未找到资源、500表示服务器错误等。
4. 使用JSON格式来传递数据：使用JSON格式来传递数据，它是一种轻量级的数据交换格式，易于阅读、编写和解析。
5. 使用版本号来管理API：在API的URI中使用版本号来管理API的不同版本，如/v1/users/{id}。
6. 使用安全机制来保护API：使用安全机制（如OAuth、JWT等）来保护API，防止未授权的访问和攻击。
7. 提供文档和示例：提供API文档和示例，方便开发者了解API的使用方式和参数，并且可以提高API的可用性和易用性。



### 资源与 URI
REST 全程是表述性装填转移，其表述的是资源。而要让一个资源可以被识别，需要有个唯一标识，在 Web 中这个标识就是 URI（Uniform Resource Identifier）。
URI既可以看成是资源的地址，也可以看成是资源的名称。如果某些信息没有使用URI来表示，那它就不能算是一个资源， 只能算是资源的一些信息而已。URI的设计应该遵循可寻址性原则，具有自描述性，需要在形式上给人以直觉上的关联。

- 使用 `_` 或 `-` 来让URI可读性更好
- 使用 `/` 来表示资源的层级关系
- 使用 `?` 用来过滤资源
- `,` 或 `;` 可以用来表示同级资源的关系


### 统一资源接口
RESTful 架构应该遵循统一接口原则，统一接口包含了一组受限的预定义的操作，不论什么样的资源，都是通过使用相同的接口进行资源的访问。接口应该使用标准的HTTP方法如GET，PUT和POST，并遵循这些方法的语义。
如果按照HTTP方法的语义来暴露资源，那么接口将会拥有安全性和幂等性的特性，例如GET和HEAD请求都是安全的， 无论请求多少次，都不会改变服务器状态。而GET、HEAD、PUT和DELETE请求都是幂等的，无论对资源操作多少次， 结果总是一样的，后面的请求并不会产生比第一次更多的影响。

  1. GET 请求
      - 安全且幂等
      - 获取表示
      - 变更时获取表示（缓存）
          - 200（OK） - 表示已在响应中发出
          - 204（无内容） - 资源有空表示
          - 301（Moved Permanently） - 资源的URI已被更新
          - 303（See Other） - 其他（如，负载均衡）
          - 304（not modified）- 资源未更改（缓存）
          - 400 （bad request）- 指代坏请求（如，参数错误）
          - 404 （not found）- 资源不存在
          - 406 （not acceptable）- 服务端不支持所需表示
          - 500 （internal server error）- 通用错误响应
          - 503 （Service Unavailable）- 服务端当前无法处理请求
  
  2. POST 请求
      - 不安全且不幂等
      - 使用服务端管理的（自动产生）的实例号创建资源
      - 创建子资源
      - 部分更新资源
      - 如果没有被修改，则不会更新资源（乐观锁）
          - 200（OK）- 如果现有资源已被更改
          - 201（created）- 如果新资源被创建
          - 202（accepted）- 已接受处理请求但尚未完成（异步处理）
          - 301（Moved Permanently）- 资源的URI被更新
          - 303（See Other）- 其他（如，负载均衡）
          - 400（bad request）- 指代坏请求
          - 404 （not found）- 资源不存在
          - 406 （not acceptable）- 服务端不支持所需表示
          - 409 （conflict）- 通用冲突
          - 412 （Precondition Failed）- 前置条件失败（如执行条件更新时的冲突）
          - 415 （unsupported media type）- 接受到的表示不受支持
          - 500 （internal server error）- 通用错误响应
          - 503 （Service Unavailable）- 服务当前无法处理请求

  3. PUT 请求
      - 不安全但幂等
      - 用客户端管理的实例号创建一个资源
      - 通过替换的方式更新资源
      - 如果未被修改，则更新资源（乐观锁）
            - 200 （OK）- 如果已存在资源被更改
            - 201 （created）- 如果新资源被创建
            - 301（Moved Permanently）- 资源的URI已更改
            - 303 （See Other）- 其他（如，负载均衡）
            - 400 （bad request）- 指代坏请求
            - 404 （not found）- 资源不存在
            - 406 （not acceptable）- 服务端不支持所需表示
            - 409 （conflict）- 通用冲突
            - 412 （Precondition Failed）- 前置条件失败（如执行条件更新时的冲突）
            - 415 （unsupported media type）- 接受到的表示不受支持
            - 500 （internal server error）- 通用错误响应
            - 503 （Service Unavailable）- 服务当前无法处理请求

  4. DELETE 请求
      - 不安全但幂等
      - 删除资源
          - 200 （OK）- 资源已被删除
          - 301 （Moved Permanently）- 资源的URI已更改
          - 303 （See Other）- 其他，如负载均衡
          - 400 （bad request）- 指代坏请求
          - 404 （not found）- 资源不存在
          - 409 （conflict）- 通用冲突
          - 500 （internal server error）- 通用错误响应
          - 503 （Service Unavailable）- 服务端当前无法处理请求

- POST和PUT用于创建资源时有什么区别？
POST 和 PUT 在创建资源的区别在于所创建的资源的名称（URI）是否由客户端决定。

- 客户端不一定都支持这些HTTP方法吧?
在一些比较古老的基于浏览器的客户端只能支持 GET 和 POST 两种方法。但通常在兼容时都会通过隐藏参数 _method=DELETE 等来传递真实的请求方法，并且可设置 X-HTTP-Method-Override头来规避这个问题。

- 统一接口是否意味着不能扩展带特殊语义的方法?
统一接口并不阻止你扩展方法，只要方法对资源的操作有着具体的、可识别的语义即可，并能够保持整个接口的统一性。

- 统一资源接口对URI有什么指导意义?
统一资源接口要求使用标准的HTTP方法对资源进行操作，所以URI只应该来表示资源的名称，而不应该包括资源的操作。
通俗来说，URI不应该使用动作来描述。例如，下面是一些不符合统一接口要求的URI:
    GET /getUser/1
    POST /createUser
    PUT /updateUser/1
    DELETE /deleteUser/1

- 如果GET请求增加计数器，这是否违反安全性?
安全性不代表请求不产生副作用，例如像很多API开发平台，都对请求流量做限制。像github，就会限制没有认证的请求每小时只能请求60次。
但客户端不是为了追求副作用而发出这些GET或HEAD请求的，产生副作用是服务端"自作主张"的。
另外，服务端在设计时，也不应该让副作用太大，因为客户端认为这些请求是不会产生副作用的。

- 直接忽视缓存可取吗?
即使你按各个动词的原本意图来使用它们，你仍可以轻易禁止缓存机制。 最简单的做法就是在你的HTTP响应里增加这样一个报头： Cache-control: no-cache。 但是，同时你也对失去了高效的缓存与再验证的支持(使用Etag等机制)。
对于客户端来说，在为一个REST式服务实现程序客户端时，也应该充分利用现有的缓存机制，以免每次都重新获取表示。

- 响应代码的处理有必要吗?
HTTP的响应代码可用于应付不同场合，正确使用这些状态代码意味着客户端与服务器可以在一个具备较丰富语义的层次上进行沟通。
例如，201（"Created"）响应代码表明已经创建了一个新的资源，其URI在Location响应报头里。
假如你不利用HTTP状态代码丰富的应用语义，那么你将错失提高重用性、增强互操作性和提升松耦合性的机会。
如果这些所谓的RESTful应用必须通过响应实体才能给出错误信息，那么SOAP就是这样的了，它就能够满足了。



### 资源的表述
资源的表述包括数据和描述数据的元数据，例如，HTTP头"Content-Type" 就是这样一个元数据属性。
客户端可以通过HTTP内容协商来知道服务端提供哪种表述形式。客户端可以通过Accept头请求一种特定格式的表述，服务端则通过Content-Type告诉客户端资源的表述形式。

1. 在URI里边带上版本号
2. 使用URI后缀来区分表述格式
3. 如何处理不支持的表述格式



### 资源的链接



### 状态的转移


```



## 登录鉴权

```bash
## 登录鉴权
1. 用户认证（Authentication）
		- 验证当前用户的身份。
				- 用户名密码登录
				- 邮箱发送登录连接
				- 手机/邮箱验证码登录

2. 用户授权（Authorization）
    - 用户授予第三方应用访问该用户某些资源的权限。如在安装应用时，APP 会询问是否允许授予权限（访问相册、地理位置等权限）
    - 实现授权的方式有：`cookie、session、token、OAuth`

3. 凭证（credentials）
		- 实现认证和授权的前提时需要一种媒介（证书）来标记访问者的身份。
		- 一般应用会存在两种模式：游客模式和登录模式。游客模式可正常浏览，但如果需要操作某些功能，则需要登录或注册账号。当用户登录成功后，服务器会给该用户使用的浏览器颁发一个令牌（token），这个令牌用来表明你的身份，每次浏览器发送请求时会带上这个令牌，就可以使用游客模式下无法使用的功能。

```

### cookie

```bash
### cookie
- HTTP 是无状态的协议（对于事务处理没有记忆能力，每次客户端和服务端会话完成时，服务端不会保存任何会话信息）：每个请求都是完全独立的，服务端无法确认当前访问者的身份信息，无法分辨上一次的请求发送者和这一次的发送者是不是同一个人。所以服务器与浏览器为了进行会话跟踪（知道是谁在访问我），就必须主动的去维护一个状态，这个状态用于告知服务端前后两个请求是否来自同一浏览器。而这个状态需要通过 cookie 或者 session 去实现。

- cookie 临时存储：cookie 默认是临时存储的，当浏览器关闭进程的时候自动销毁，要想长时间保存一个 cookie，就需要设置 cookie 的过期时间。
- cookie 存储在客户端：当 Web 服务器创建 cookie 后，只要在其有效期内，用户访问同一个 Web 服务器时，浏览器首先检查本地的 Cookie，并将其原样发给 Web 服务器。cookie 是保持 web 浏览状态的手段。
- cookie 不可跨域：每个 cookie 都会绑定单一的域名，无法在别的域名下获取使用，一级域名和二级域名之间是允许共享使用的（依靠设置相同的 domain）。


### Cookie 的特点
1. cookie保存在浏览器本地，只要不过期关闭浏览器也会存在。
2. 正常情况下cookie不加密，用户可轻松看到
3. 用户可以删除或者禁用cookie
4. cookie可以被篡改
5. cookie可用于攻击
6. cookie存储量很小，大小一般是4k
7. 发送请求自动带上登录信息



### cookie 的工作过程
cookie 是存放在浏览器中的，在每一个浏览器浏览器安装目录下，都存在一个文件夹，存放着不同域下对应的cookie。
当浏览器通过 http 请求某一个域时，此时浏览器会先检查相应域是否有 cookie，有则自动添加在请求头中的 cookie 字段中。
注意：浏览器自动帮我们携带，此时如果有很多无关紧要的数据都存放在 cookie 中，都会随着请求发送给服务端，这样就无形中增加了网络开销。
但如身份认证信息这些数据在每一次请求都需要携带发给服务端，此时使用 cookie 就可以大大减少重复添加身份认证信息到请求中的操作，就会比较适合，至于其他信息都不适合。
    1. 首先，假设当前域名下还是没有 cookie 的
    2. 接下来，浏览器发送了一个请求给服务器(这个请求是还没带上 cookie 的)
    3. 服务器设置 cookie 并发送给浏览器(当然也可以不设置)
    4. 浏览器将 cookie 保存下来
    5. 接下来，以后每一次请求都会带上这些 cookie 发送给服务器


### cookie 的特征
1. 不同的浏览器存放的 cookie 位置不一样，也是不能通用的。
2. cookie 的存储是以域名形式进行区分的，在同一个浏览器下不同的域名下存储的 cookie 是独立的。
3. cookie 也可以设置过期事件，默认是会话结束时，当时间到期自动销毁。
4. 一个浏览器能创建的 cookie 数量最多为 300 个，并且每个域下的 cookie 不能超过 4KB，每个Web站点能设置的 cookie 总数不能超过 20 个。
5. 可设置 cookie 生效的域(当前设置cookie 所在域的子域)，即我们能够操作的 cookie 是当前域以及当前域下的所有子域。
6. cookie 必须在 HTML 文件的内容输出之前设置，如果用户在浏览器上设置了禁止 cookie，则 cookie 不能建立。
7. cookie 设置的属性是需要在每一个属性后面需要跟一个分号和空格。
		"key=name; expires=Thu, 25 Feb 2016 04:18:00 GMT; domain=ppsc.sankuai.com; path=/; secure; HttpOnly"


### cookie 的设置
1. 在客户端设置
    document.cookie = '名字=值'
    document.cookie = 'username=willy; domain=baike.baidu.com' // 并且设置了生效域
注意：客户端可以设置cookie的下列选项：expires、domain、path、secure（只有在https协议的网页中，客户端设置secure类型的cookie才能成功），但无法设置 HttpOnly 选项。


2. 在服务端设置
   http响应头中 `Set-Cookie` 字段是专门设置 cookie 的：
   		`Set-Cookie: value[; expires=date][; domain=domain][; path=path][; secure]`
   一个 Set-Cookie 字段只能设置一个 cookie，当想要设置多个 cookie 则需要添加多个 Set-Cookie 字段。
   服务端可以设置 cookie 的所有选项：expires、domain、path、secure、HttpOnly。通过 Set-Cookie 指定这些可选项只会在浏览器端使用，而不会被发送至服务端。


### 使用 cookie 注意问题
- 因为存储在客户端，容易被客户端篡改，使用前需要验证合法性。
- 不要存储敏感数据，比如用户密码，帐户余额等。
- 使用 httpOnly 可在一定程度上提高安全性。
- 尽量减少 cookie 的体积，能存储的数据量不能超过 4kb。
-  需要设置正确的 domain 和 path，减少数据传输。
- cookie 无法跨域。
- 一个浏览器针对一个网站最多存储 20 个 cookie，浏览器一般只允许存放 300 个 cookie。
- 移动端对 cookie 的支持不是很好，而 session 需要基于 cookie 实现，所以移动端常用的是 token。

```

#### cookie 属性

```bash
### name=value
- 键值对，设置 `Cookie` 的名称及相对应的值都必须是字符串类型。
- 如果值为 Unicode 字符，需要为字符编码。如果值为二进制数据则需要使用 `BASE64` 编码。


### expires 属性
- expires 属性表示 cookie 的过期时间，超出这个时间点后该 cookie 会自动失效，使用GMT表示。
  	常用 `Date.toUTCString()` 和 `Date.toGMTString()` 来获取时间。
  	console.log(new Date().toUTCString()) // 'Thu, 02 Mar 2023 06:53:51 GMT'
  	console.log(new Date().toGMTString())	// 'Thu, 02 Mar 2023 06:53:51 GMT'
- 如果在新增 cookie 时没有增加 expires 属性，则表示会话阶段，在浏览器关闭时 cookie 会被删除。


### max-age 属性
- expires 是在 http1.0 中的属性，在 http1.1 中新增了 max-age。
- max-age 表示从当前创建开始，到 cookie 过期的时间，单位秒，默认为 -1。
- max-age 可以为三个值，一个负值，0，正值。
  	1. 当 max-age 为负数时，表示 cookie 为会话 cookie，关闭浏览器即失效，浏览器也不会以任何形式保存该 cookie。
  	2. 当 max-age 为 0 时，表示删除该 cookie。
  	3. 当 max-age 为正数时，则该 cookie 在 maxAge 秒后失效，则 expires = max-age + 当前时间。


### cookie 的域(domain)
- domain 指定 cookie 将要被发送至哪个或那些域中。
- 默认情况下，domain 会被设置为创建该 cookie 的页面所在的域名，所以当给相同域名发送请求时该 cookie 会被发送至服务器。
- 浏览器会把 domain 的值与请求的域名做一个尾部比较(即从字符串的尾部开始比较)，并将 domain 能匹配到的域名的 cookie 发送至服务器。
- 如果设置为 /abc，则只有 /abc 下的路由可以访问到该 cookie，如：/abc/read。

  1. 客户端设置
      `document.cookie = "username=willy; path=/; domain=qq.com"`
     上述是将 domain 设置为 qq.com，表示访问域名尾部是 qq.com 的网站时浏览器会将该 cookie 带上。
          path 值为 "/" 表示访问 qq.com 域名下的根目录下的都将能带上该 cookie。

  2. 服务端设置
      `Set-Cookie: username=willy; path=/; domain=qq.com`
      注意：一定时候同域名之间的访问，不能将 domain 的值设置成非主域的域名。



### cookie 的路径(path)
因为安全方面考虑，默认情况下，只有与创建 cookie 的页面在同一个目录或子目录下的网页才可以访问。但 path 属性可以为 cookie 指定路径，domain 和 path 加起来构成 URL，表示当浏览器在访问该 URL 下的网站或者 URL 带有这个前缀的网站都将会带上该 cookie。
  1. 客户端设置
     `document.cooke='username=willy; path=/'`
     让 cookie 在根目录下，这样不管是哪个子页面创建的 cookie，该域名下的所有页面都可以访问到。

  2. 服务端设置
     `Set-Cookie: name=willy; path=/blog`
     如上设置，path 选项值会与任何以 /blog 开发的选项匹配(如：/blog，/blogrool 等)
     需要注意，只有在 domain 选项核实完毕之后才会对 path 属性进行比较。
     path 属性的默认值是发送 Set-Cookie 消息头所对应的 URL 中的 path 部分。

  3. domain 和 path 总结：
     domain 是域名，path 是路径，两者结合构成 URL，domain 和 path 一起来限制 cookie 能被哪些 URL 访问。
     所以 domain 和 path 两个选项共同决定了 cookie 何时被浏览器自动添加到请求头中发送出去。
     如果没有设置这两个选项，则会使用默认值。domain 的默认值为设置该 cookie 的网页所在的域名，path 默认值为设置该 cookie 的网页所在的目录。
     如 `document.cooke='name=willy; domain=baidu.com; path=/'`，当浏览器访问域名为 `api.baidu.com` 或 `baidu.com` 时携带 cookie，当 url 为任何值均携带 cookie。
     注意：xhr 请求默认不会携带 cookie。


### secure
- secure 是保证网络请求安全的，是否仅被使用安全协议传输。默认为false。
- 如果设置 cookie 的 secure 为 true，则在网络上传输数据之前先将数据加密，发送的请求必须使用安全协议传输（https、SSL 等安全协议）。
- 当 secure 值为 true 时，cookie 在 HTTP 中是无效，在 HTTPS 中才有效。


### httpOnly
- 在设置 cookie 时默认 httpOnly 为空，如果给某个 cookie 设置了 httpOnly 属性，则无法通过 JS 脚本操作到该 cookie 的信息（删改查），但还是能通过 Application 中手动修改 cookie，所以只是在一定程度上可以防止 XSS 攻击，不是绝对的安全。
- 不是绝对安全的原因：如果在某一个用户登录过的网站，其 cookie 没有设置 httpOnly，则当用户受到 xss 攻击(跨站脚本攻击)时，其会注入一段 JS 脚本，如果这个脚本读取的是用户的 cookie，并且将该 cookie 发送给攻击者，则用户信息泄露，攻击者可以拿到该用户登录信息模拟用户登录，造成用户不安全。
```



#### JS 操作 cookie

```bash
### JS 操作 cookie
1. 创建 cookie
   - 默认情况，cookie在浏览器关闭时删除
     	`document.cookie="username=willy"`
   - 添加过期时间(以UTC或GMT为准)
     	`document.cookie="username=willy; expires=Thu, 18 Dec 2043 12:00:00 GMT"`	
   - 添加浏览器 cookie 的路径。默认情况，cookie 属于当前页面
     	`document.cookie="username=willy; expires=Thu, 18 Dec 2043 12:00:00 GMT; path=/"`
   - 设置多个 cookie
     	如 `document.cookie="name=willy; age=20; sex:man;` 只能设置成功一个`name=willy;`，其他都是无效的。
     	需要分开去设置 cookie。


2. 读取 cookie
   通过 document.cookie 能获取当前网站下非定义 httpOnly 属性的全部 cookie。
   获取到的值为 key=value 形式组成的字符串，并且在每一个 value 与下一个 key 之间使用分号和空格隔开。
   	`const getCookie = document.cookie`	// 假设获取结果：`username=willy; job=coding`


3. 修改/删除 cookie
   修改：直接进行赋新值，不过必须保证domain/url属性不变，如果改变则直接新增一个。
   删除：直接赋新值，不过必须保证domain/url属性不变，并且将expires的时间设置为过去的时间。
   注意：
   在 cookie 中只有 key、domain、path 都相同时，才能进行覆盖。
   在设置 domain 的 value 设置多个点，则任何子域名都可以访问；如果不设置点，则只有该 domain 才能访问。

```

#### node 操作 cookie

```bash
## node 操作 cookie （服务端）
1. 安装
$ pnpm install cookie-parser --save


2. 引入
const cookieParser = require("cookie-parser")


3. 设置中间件
app.use(cookieParser())


4. 设置 cookie
res.cookie("name", 'willy', { maxAge: 1000*60*60, httpOnly: true })
// res.cookie(名称,值,{配置信息})


5. 获取 cookie
req.cookies.name

```

```js
const express = require("express")
const cookieParser = require("cookie-parser")

const app = express()

// 设置中间件
app.use(cookieParser())

app.get("/", (req, res) => {
  res.send("首页")
})

// 设置cookie
app.get("/set", (req, res) => {
  // 如果不进行任何设置,有效期默认为1个会话，浏览器关闭即失效
  // res.cookie('isLogin','true')
  res.cookie("userName", '张三', { maxAge: 1000 * 60 * 60, httpOnly: true })
  res.send("设置cookie成功")
})

// 获取cookie
app.get("/get", (req, res) => {
  res.send("获取cookie成功，cookie为: " + req.cookies.userName)
})

app.listen(8080)

```



#### cookie、sessionStorage、localStorage

```bash
## cookie、sessionStorage、localStorage 的区别
相同点：都存储在客户端，在所有同源窗口中都是共享的，并且不会失效，不管窗口或浏览器关闭与否都会始终生效。

不同点：
  1. 存放的数据大小：
      - cookie 数据大小不能超过 4KB；
      - sessionStorage和localStorage 存储的数据大小可以达到 5MB+。
      
  2. 数据的生命周期
      - cookie：若不设置过期时间，则视为会话，关闭浏览器后丢失；
      					若设置时间，则在设置的过期时间之前一直有效，即使窗口或浏览器关闭。
      - session：是一个会话，当页面不同，即使同一页面打开两次也被视为同一次会话。
      - sessionStorage：数据仅在当前浏览器窗口关闭前有效。
      - localStorage：永久存储，浏览器关闭后如果不主动删除数据都不会丢失掉。
      
  3. 与服务器通信
      - cookie 的数据会携带在 http 头中自动传递到服务器；但如果使用 cookie 保存过多数据会带来性能问题。
      - sessionStorage和localStorage 数据只能保存在本地。
      
	4. 易用性
			- cookie 需要自己封装，源生的 cookie 接口不友好。
			- sessionStorage和localStorage 源生接口可接受，也可再次封装对 Object和Array有更好的支持。
			
	5. 应用场景
			从安全性来说，因为每次 http 请求都会携带 cookie 信息，这样会浪费带宽，所以 cookie 应该尽可能地少用。
			此外，cookie 还需要指定作用域，不可以跨域调用，限制很多。
			但是用户识别用户登录来说，cookie 还是比 storage 好用，其他情况可以使用 sessionStorage。
			localStorage 可以用来在页面传递参数。
			sessionStorage 可以用来保存一些临时的数据，防止用户刷新页面后丢失了一些参数。
```

![image-20211027104432156](./image/image-20211027104432156.png)



#### sessionStorage 同一网站下共享问题

```bash
## sessionStorage 同一网站下共享问题
以下情况是以同源为前提的。并不是所有的 sessionStorage 都能共享。

1. 第一种情况：
浏览器中打开 A 页面，再通过 A 页面打开新的标签页 B 页面，此时 A、B 两个页面的 sessionStorage 是共享的。
这里的共享是指 B 页面会把 A 页面中的 sessionStorage 拷贝一份，作为 B 页面的初始缓存值，此时改变 B 页面的 session，A 页面并不受影响。即不同 Tab 页之间 session 读写操作独立，互不影响。

2. 第二种情况：
浏览器中打开 A 页面，然后手动新开一个标签页，在新的标签页中打开 B 页面，此时 A、B 两个页面的 sessionStorage 是不共享的。即 B 页面不会继承 A 页面 session 作为初始值。
新开一个标签页总是会初始化一个 session，即使是同一个网站。

```



### Session

```bash
## Session
- Session 是记录客户状态的机制。当客户端浏览器访问服务端时，服务器把客户端信息以某种形式记录在服务器上，客户端浏览器再次访问时只需要从该 Session 中查找该客户的状态即可。

- 与 Cookie 不同的是 Cookie 保存在客户端浏览器中，而 Session 保存在服务器上。

- 使用 Session 的原因：由于 Cookie 是存在用户端，而且它自身存储的大小有限、对用户可见、可随意修改，所以十分不安全。



### Session 认证流程：
- 用户第一次请求服务器时，服务器根据用户提交的相关信息，创建对应的 Session
- 请求返回时将此 Session 的唯一标识信息 SessionID 返回给浏览器
- 浏览器接收到服务器返回的 SessionID 信息后，会将此信息存入到 Cookie 中，同时 Cookie 记录此 SessionID 属于哪个域名
- 当用户第二次访问服务器的时候，请求会自动判断此域名下是否存在 Cookie 信息，如果存在自动将 Cookie 信息也发送给服务端，服务端会从 Cookie 中获取 SessionID，再根据 SessionID 查找对应的 Session 信息，如果没有找到说明用户没有登录或者登录失效，如果找到 Session 证明用户已经登录可执行后面操作。

根据以上流程可知，SessionID 是连接 Cookie 和 Session 的一道桥梁，大部分系统也是根据此原理来验证用户登录状态。


### Cookie 和 Session 的区别
- **安全性**： Session 比 Cookie 安全，Session 是存储在服务器端的，Cookie 是存储在客户端的。
- **存取值的类型不同**：Cookie 只支持存字符串数据，想要设置其他类型的数据，需要将其转换成字符串，Session 可以存任意数据类型。
- **有效期不同**： Cookie 可设置为长时间保持，比如我们经常使用的默认登录功能，Session 一般失效时间较短，客户端关闭（默认情况下）或者 Session 超时都会失效。
- **存储大小不同**： 单个 Cookie 保存的数据不能超过 4K，Session 可存储数据远高于 Cookie，但是当访问量过多，会占用过多的服务器资源。

```

![image-20220620212335597](./image/dacfa03c50bd2e7d2225a7cd3e61291d5da00f63.png)

![session](./image/29cfe2cc7bd13bc659227e62c3e89063.png)

#### express-session

##### 参数

```js
const option = {
  cookie: {
    // Cookie Options
    // 默认为{ path: '/', httpOnly: true, secure: false, maxAge: null }
    /** maxAge: 设置给定过期时间的毫秒数（date）
  * expires: 设定一个utc过期时间，默认不设置，http>=1.1的时代请使用maxAge代替之（string）
  * path: cookie的路径（默认为/）（string）
  * domain: 设置域名，默认为当前域（String）
  * sameSite: 是否为同一站点的cookie（默认为false）（可以设置为['lax', 'none', 'none']或 true）
  * secure: 是否以https的形式发送cookie（false以http的形式。true以https的形式）true 是默认选项。 但是，它需要启用 https 的网站。 如果通过 HTTP 访问您的站点，则不会设置 cookie。 如果使用的是 secure: true，则需要在 express 中设置“trust proxy”。
  * httpOnly: 是否只以http(s)的形式发送cookie，对客户端js不可用（默认为true，也就是客户端不能以document.cookie查看cookie）
  * signed: 是否对cookie包含签名（默认为true）
  * overwrite: 是否可以覆盖先前的同名cookie（默认为true）*/
  },

  // 默认使用uid-safe这个库自动生成id
  genid: req => genuuid(),  

  // 设置会话的名字，默认为connect.sid
  name: 'value',  

  // 设置安全 cookies 时信任反向代理（通过在请求头中设置“X-Forwarded-Proto”）。默认未定义（boolean）
  proxy: undefined,

  // 是否强制保存会话，即使未被修改也要保存。默认为true
  resave: true, 

  // 强制在每个响应上设置会话标识符 cookie。 到期重置为原来的maxAge，重置到期倒计时。默认值为false。
  rolling: false,

  // 强制将“未初始化”的会话保存到存储中。 当会话是新的但未被修改时，它是未初始化的。 选择 false 对于实现登录会话、减少服务器存储使用或遵守在设置 cookie 之前需要许可的法律很有用。 选择 false 还有助于解决客户端在没有会话的情况下发出多个并行请求的竞争条件。默认值为 true。
  saveUninitialized: true,

  // 用于生成会话签名的密钥,必须项  
  secret: 'secret',

  // 会话存储实例，默认为new MemoryStore 实例。
  store: new MemoryStore(),

  // 设置是否保存会话，默认为keep。如果选择不保存可以设置'destory'
  unset: 'keep'
}
```

##### 方法

```bash
### 方法
- .regenerate(callback)
要重新生成会话，只需调用该方法。 完成后，将在 req.session 处初始化一个新的 SID 和 Session 实例，并调用回调。


- .destroy(callback)
销毁会话并取消设置 req.session 属性。 完成后，将调用回调。


- .reload(callback)
从存储重新加载会话数据并重新填充 req.session 对象。 完成后，将调用回调。


- .save(callback)
将会话保存回 store，用内存中的内容替换 store 上的内容。
如果会话数据已更改，则在 HTTP 响应结束时自动调用此方法。
在某些情况下调用此方法很有用，例如重定向、long-lived 请求或在 WebSockets 中。


- .touch()
更新 .maxAge 属性。 通常不需要调用，因为会话中间件会为您执行此操作。

```

##### 存储 Session 的 Store

```bash
### 存储 Session 的 Store

store.all(callback)
此可选方法用于将存储中的所有会话作为数组获取。 callback中第一个为error，第二个是sessions。

store.destroy(sid, callback)
这个必需的方法用于在给定会话 ID (sid) 的情况下从存储中销毁/删除会话。 callback的对象为error。

store.clear([callback])
此方法用于从存储中删除所有会话.callback的对象为error。

store.length(callback)
此方法用于获取商店中所有会话的数量。 callback中第一个为error，第二个是len。

store.get(sid, callback)
这个方法第一个参数为会话 ID (sid) 。 callback中第一个为error，第二个是session。
找不到不会错误，而是在session返回null 或 undefined。

store.set(sid, session, callback)
这个方法用于新建或修改session 保存在store中。 callback的对象为error。

store.touch(sid, session, callback)
这个方法用给定会话 ID (sid) 和会话 (session)来“touch”对应的session。callback的对象为error。
这主要用于当存储将自动删除空闲会话并且此方法用于向存储发出信号给定会话处于活动状态时，可能会重置空闲计时器。

```



##### 示例

```js
const express = require('express')
const session = require('express-session')
const MongoStore = require('connect-mongo')

const app = express()

// 配置中间件
// session会自带一个httpOnly
app.use(
  session({
    name: 'session-id',
    secret: 'this is session', // 服务器生成 session 的签名
    resave: true, // 每次是否都刷新到期时间
    saveUninitialized: true, // 强制将为初始化的 session 存储(该session_id是没有用的)
    cookie: {
      maxAge: 1000 * 60 * 10, // 过期时间
      secure: false, // 为 true 时候表示只有 https 协议才能访问cookie
    },
    // 自动在mongodb中创建一个数据库存储session，并且过期时间也会同步刷新
    store: MongoStore.create({
      mongoUrl: 'mongodb://127.0.0.1:27017/ds2_session',
      ttl: 1000 * 60 * 10, // 过期时间
    }),
  }),
)

// 授权中间件，在这个之后的路由，除了错误处理，都是需要授权的。
app.use((req, res, next) => {
  // 排除login相关的路由和接口（因为login就不需要重定向到login了）
  if (req.url.includes('login')) {
    next()
    return
  }
  if (req.session.user) {
    // 重新设置以下sesssion
    req.session.mydate = Date.now() // 加这个设置才能访问刷新过期时间
    next()
  } else {
    // 是接口, 就返回错误码
    // 不是接口，就重定向（因为ajax请求是不能重定向的，只能前端接收错误码做处理）
    req.url.includes('api')
      ? res.status(401).json({ ok: 0 })
      : res.redirect('/login')
  }
})

// 设置session
app.use('/login', (req, res) => {
  req.session.userinfo = '张三'
  res.send('登陆成功！')
})

// 注销session
app.use('/loginOut', (req, res) => {
  req.session.destroy((err) => {
    res.send('退出登录！' + err)
  })
})

// 获取session
app.use('/', (req, res) => {
  if (req.session.userinfo) {
    res.send('hello ' + req.session.userinfo + ', welcome')
  } else {
    res.send('未登陆')
  }
})

app.listen(8080)

```



### Token

```bash
## Token 令牌

### Acesss Token
- 访问资源接口（API）时所需要的资源凭证
- 简单 token 的组成：uid(用户唯一的身份标识)、time(当前时间的时间戳)、sign（签名，token 的前几位以哈希算法压缩成的一定长度的十六进制字符串）
- 特点：
    - 服务端无状态化、可扩展性好
    - 支持移动端设备
    - 安全
    - 支持跨程序调用


- token 的身份验证流程：
    1. 客户端使用用户名跟密码请求登录
    2. 服务端收到请求，去验证用户名与密码
    3. 验证成功后，服务端会签发一个 token 并把这个 token 发送给客户端
    4. 客户端收到 token 后会把它存储起来，比如放在 cookie 里或者 localStorage 里
    5. 客户端每次向服务端请求资源时需要携带服务端签发的 token
    6. 服务端收到请求后去验证客户端请求中携带的 token ，如果验证成功，就向客户端返回请求的数据

- 请求中 token 的携带：
    - 每一次请求都需要携带 token，需要把 token 放到 HTTP 的 Header 里
    - 基于 token 的用户认证是一种服务端无状态的认证方式，服务端不用存放 token 数据。用解析 token 的计算时间换取 session 的存储空间，从而减轻服务器的压力，减少频繁的查询数据库
    - token 完全由应用管理，所以它可以避开同源策略



### Token 和 Session 的区别
Session 是一种记录服务器和客户端会话状态的机制，使服务端有状态化，可以记录会话信息。而 Token 是令牌，访问资源接口（API）时所需要的资源凭证。Token 使服务端无状态化，不会存储会话信息。

作为身份认证 Token 安全性比 Session 好，因为每一个请求都有签名还能防止监听以及重放攻击，而 Session 就必须依赖链路层来保障通讯安全。如果需要实现有状态的会话，仍然可以增加 Session 来在服务器端保存一些状态。

Session 认证只是简单地把 User 信息存储到 Session 里，因为 SessionID 的不可预测性，暂且认为是安全的。而 Token ，如果指的是 OAuth Token 或类似的机制提供的是 认证 和 授权 ，认证是针对用户，授权是针对 App 。其目的是让某 App 有权利访问某用户的信息。这里的 Token 是唯一的。不可以转移到其它 App上，也不可以转到其它用户上。Session 只提供一种简单的认证，即只要有此 SessionID ，即认为有此 User 的全部权利。是需要严格保密的，这个数据应该只保存在站方，不应该共享给其它网站或者第三方 App。所以简单来说：如果你的用户数据可能需要和第三方共享，或者允许第三方调用 API 接口，用 Token 。如果永远只是自己的网站，自己的 App，用什么就无所谓了。

```

![image-20221107232241864](./image/8ac75ad617c60df2eadc8ee51e25309f9bff4bd2.png)

#### 无感知刷新 Token

```bash
### 无感知刷新 token
refresh token 是专用于刷新 access token 的 token。如果没有 refresh token，也可以刷新 access token，但每次刷新都要用户输入登录用户名与密码，会很麻烦。而 refresh token，可以减少这个麻烦，客户端直接用 refresh token 去更新 access token，无需用户进行额外的操作。

Access Token 的有效期比较短，当 Acesss Token 由于过期而失效时，使用 Refresh Token 就可以获取到新的 Token，如果 Refresh Token 也失效，则用户就只能重新登录。

Refresh Token 及过期时间是存储在服务器的数据库中，只有在申请新的 Acesss Token 时才会验证，不会对业务接口响应时间造成影响，也不需要向 Session 一样一直保持在内存中以应对大量的请求。

```

![image-20221107232317906](./image/3eae487e7388066531659df5637a0b6af29007b9.png)



### JWT 认证

```bash
## JWT 认证
- JWT（JSON Web Token）是一种用于在网络应用间传递信息的开放标准（RFC 7519），它通过对JSON对象进行数字签名来实现信息的安全传输。
- JWT 的声明一般被用来在身份提供者和服务提供者间传递被认证的（用户身份信息），以便于从资源服务器获取资源。比如用在用户登录上。
- JWT通常用于身份验证和授权，可以在不需要再次验证用户身份的情况下传递用户信息。
- 在前端中，通常会使用现成的JWT库来进行JWT的生成、解析和验证。常见的JWT库有jsonwebtoken和jsrsasign等。使用这些库可以简化JWT的使用和处理过程。


### 前端使用JWT通常需要进行以下步骤：
  1. 客户端发送用户名和密码给服务器进行验证。
  
  2. 服务器验证通过后，生成JWT并将其返回给客户端（将包含用户信息的数据作为JWT的Payload，将其与JWT Header分别进行Base64编码拼接后签名，形成一个JWT Token，形成的JWT Token就是一个如同lll.zzz.xxx的字符串 后端将JWT Token字符串作为登录成功的结果返回给客户端）
  
  3. 客户端将JWT保存在本地（通常使用localStorage或sessionStorage保存），退出登录时删除保存的JWT。
  
  4. 客户端在每次请求时将JWT添加到请求头中（通常放在 http 头的 "Authorization" 属性中，需要解决XSS和XSRF问题）。
  
  5. 服务器在接收到请求时，需要验证JWT的有效性和签名是否正确（比如检查签名是否正确、是否过期、token的接收方是否是自己等）。
  
  6. 验证通过后（后端解析出JWT Token中包含的用户信息，进行其他逻辑操作，如根据用户信息得到用户权限），服务器返回请求所需的数据给客户端。



### Token 和 JWT 的区别
相同：
	- 都是访问资源的令牌
	- 都可以记录用户的信息
	- 都是使服务端无状态化
	- 都是只有验证成功后，客户端才能访问服务端上受保护的资源

区别：
	- Token：服务端验证客户端发送过来的 Token 时，还需要查询数据库获取用户信息，然后验证 Token 是否有效。
	- JWT： 将 Token 和 Payload 加密后存储于客户端，服务端只需要使用密钥解密进行校验（校验也是 JWT 自己实现的）即可，不需要查询或者减少查询数据库，因为 JWT 自包含了用户信息和加密的数据。



### Token 和 Session 的区别
Session 认证的问题
  - 每个用户的登录信息都会保存到服务器的session中，随着用户的增多，服务器开销会明显增大。
  - 由于session是存在与服务器的物理内存中，所以在分布式系统中，这种方式将会失效。虽然可以将 session 统一保存到Redis中，但是这样会增加系统的复杂性，对于不需要 redis 的应用也会白白多引入一个缓存中间件。
  - 对于非浏览器的客户端、手机移动端等不适用，因为session依赖于cookie，而移动端经常没有cookie。
  - 因为session认证本质基于cookie，所以如果cookie被截获，用户很容易收到跨站请求伪造攻击。并且如果浏览器禁用cookie，这种方式也会失效。
  - 前后端分离系统中更加不适用，后端部署复杂，前端发送的请求往往经过多个中间件到达后端，cookie中关于session的信息会转发多次。
  - 由于基于Cookie，而cookie无法跨域，所以session的认证也无法跨域，对单点登录不适用。

JWT认证的优势
  - 简洁：JWT Token 数据量小，传输速度也很快。
  - 因为 JWT Token 是以 JSON 加密形式保存在客户端的，所以 JWT 是跨语言的，原则上任何web形式都支持。
  - 不需要在服务端保存会话信息，即不依赖于cookie和session，所以没有传统session认证的弊端，特别适用于分布式微服务。
  - 单点登录友好：使用Session进行身份认证的话，由于cookie无法跨域，难以实现单点登录。但是，使用token进行认证的话， token可以被保存在客户端的任意位置的内存中，不一定是cookie，所以不依赖cookie，不会存在这些问题。
  - 适合移动端应用：使用Session进行身份认证，需要保存一份信息在服务器端，而且这种方式会依赖到Cookie（需要 Cookie 保存 SessionId），所以不适合移动端。
> 因为这些优势，目前无论单体应用还是分布式应用，都更加推荐用JWT token的方式进行用户认证。
```

![jwt](./image/900b3e81f832b2f08c2e8aabb540536a.png)



## 跨域

> ```bash
> ## 跨域
> - 广义的跨域是指一个域下的文档或脚本试图去请求另一个域下的资源。
> - 狭义的是由浏览器同源策略限制的一类请求场景。
> - 广义的跨域
>     1. 资源跳转：A链接、重定向、表单提交
>     2. 资源嵌入：<link>、<script>、<frame> 等 dom 标签，还有样式中 background:url()、@font-face() 等文件外链
>     3. 脚本请求：js 发起的 ajax 请求获取数据、dom 和 js 对象的跨域操作等。
> 
> 
> ## 同源策略
> - 同源是指域名，协议，端口完全相同。
> - 同源策略/SOP（Same origin policy）浏览器的一种安全策略，该策略是浏览器用于隔离潜在恶意文件的设立安全机制（降低浏览器收到XSS、CSFR等攻击恶意窃取数据），确保一个应用中的资源只能被本应用的资源访问。
> - 同源策略的限制行为：
> 		1. Cookie、localStorage 和 IndexedDB 无法读取。
> 		2. DOM 和 JS 对象无法获得。
> 		3. AJAX 请求不能发送。
> 
> 
> 
> ## 跨域解决方案
> 1. JSONP: 利用加载 JS 文件不需要遵循同源策略的原理，使用sript标签的src属性传递数据
> 2. CORS 跨域资源共享，在服务器端设置返回允许跨域访问的响应头 Access-Control-Allow-Origin
> 3. WebSocket：利用 WebSocket 协议不需要遵循同源策略的原理
> 4. document.domain + iframe：两个域都创建相同的域名来达到跨域访问资源的目的（需要主域名相同），父子域都设立同一域名
> 5. location.hash + iframe：iframe跨域+hash携带参数
> 6. window.name + iframe：iframe跨域+同一窗口共享window.name
> 7. postMessage 跨域：窗口/页面通信
> 8. Nginx 反向代理跨域
> 9. nodejs 中间件代理跨域：开发环境下使用 webpack 的 proxy
> ```

### 常见的跨域场景

> ```bash
> ## 常见的跨域场景
> URL                                      说明                    是否允许通信
> http://www.demo.com/a.js
> http://www.demo.com/b.js         同一域名，不同文件或路径           允许
> http://www.demo.com/lab/c.js
> 
> http://www.demo.com:8000/a.js
> http://www.demo.com/b.js         同一域名，不同端口                不允许
>  
> http://www.demo.com/a.js
> https://www.demo.com/b.js        同一域名，不同协议                不允许
>  
> http://www.demo.com/a.js
> http://127.0.0.1/b.js           域名和域名对应相同ip              不允许
>  
> http://www.demo.com/a.js
> http://x.demo.com/b.js           主域相同，子域不同                不允许
> http://demo.com/c.js
>  
> http://www.demo1.com/a.js
> http://www.demo2.com/b.js        不同域名                         不允许
> ```
>
> ![image-20210917092605140](./image/image-20210917092605140.png)

### 1. Nginx代理跨域

> ```bash
> ## 1. nginx 配置解决 iconfont 跨域
> 浏览器访问 js、css、img 等常规静态资源被同源策略许可，但 iconfont 字体文件(eot | otf | ttf | woff | svg)例外，此时可在 nginx 的静态资源服务器中加入以下配置。
> location / {
> 	add_header Access-Control-Allow-Origin *;
> }
> ```
>
> ```bash
> ## 2. nginx 反向代理接口跨域
> 跨域原理：同源策略是浏览器的安全策略，不是HTTP协议的一部分，服务器端调用 HTTP 接口只是使用 HTTP 协议，不会执行 JS 脚本，不需要同源策略，也就不存在跨域问题。
> 实现思路：通过 nginx 配置一个代理服务器做跳板机，反向代理demo2接口，并且顺便修改cookie中demo信息，方便当前域 cookie 写入，实现跨域登录。
> nginx 具体配置
> 
> 
> ### proxy 服务器配置参考
> server {
>     listen	81;
>     server_name	www.demo1.com;
> 
>     location / {
>       proxy_pass	http://www.demo2.com:8080; # 反向代理
>       proxy_cookie_demo www.demo2.com www.demo1.com; # 修改cookie里域名
>       index index.html index.htm;
> 
>       # 当用 webpack-dev-server 等中间件代理接口访问nginx时，此时无浏览器参与，故没有同源限制，下面的跨域配置可不启用
>       add_header Access-Control-Allow-Origin http://www.demo1.com;	# 当前端只跨域不带cookie时，可为 *
>       add_header Access-Control-Allow-Credentials true;
>     }
> }
> 
> 
> ### 前端代码示例
> const xhr = new XMLHttpRequest()
> xhr.withCredentials = true	// 前端开关：浏览器是否读取cookie
> xhr.open('get', 'http://www.demo1.com:81/?user=admin', true)	// 访问nginx中的代理服务器
> xhr.send()
> 
> 
> ### nodejs 代理示例
> const http = require('http')
> const server = http.createServer()
> const qs = require('querystring')
> server.on('request', (req, res) => {
> 	const params = qs.parse(req.url.substring(2))
> 	// 向前台写 cookie
> 	res.writeHead(200, {
> 		'Set-Cookie': 'l=a123456;Path=/;Domain=www.demo2.com;HttpOnly', // HttpOnly: 脚本无法读取
> 	})
> 	res.write(JSON.stringify(params))
> 	res.end()
> })
> server.listen('8080')
> console.log('Server is running at port 8080...')
> ```

### 2. WebSocket 协议跨域

> ```bash
> ## WebSocket 协议跨域
> - WebSocket protocol 是 HTML5 一种新的协议。它实现了浏览器与服务器全双工通信，同时允许跨域通讯，是 server push 技术的一种很好的实现。
> - 原生 WebSocket API 使用繁琐，但可使用 Socket.io，它很好地封装了 WebSocket 接口，提供了更简单、灵活的接口，也对不支持 WebSocket 的浏览器提供了向下兼容。
> 
> 
> ### 实现
> #### 1) 前端代码：
>     <div>user input: <input type="text" /></div>
>     <script src="./socket.io.js"></script>
>     <script>
>       const socket = io('http://www.demo2.com:8080')
>       // 连接成功处理
>       socket.on('connect', () => {
>         // 监听服务端消息
>         socket.on('message', (msg) => {
>           console.log('data from server: -->', msg)
>         })
> 
>         // 监听服务端关闭
>         socket.on('disconnect', () => {
>           console.log('Server socket has closed.')
>         })
>       })
>       document.getElementsByTagName('input')[0].onblur = function () {
>         socket.send(this.value)
>       }
>     </script>
> 
> #### 2) NodeJS socket 后端代码：
>     const http = require('http')
>     const server = http.createServer((req, res) => {
>       res.writeHead(200, {
>         'Content-type': 'text/html'
>       })
>       res.end()
>     })
>     server.listen('8080')
>     console.log('Server is running at port 8080...')
>     // 监听 socket 连接
>     server.listen(server).on('connection', (client) => {
>       // 接收信息
>       client.on('message', (msg) => {
>         client.send('hello:' + msg)
>         console.log('data from client: --->', msg)
>       })
>       // 断开处理
>       client.on('disconnect', () => {
>         console.log('Client socket has closed.')
>       })
>     })
> ```

### 3. postMessage（跨窗口/页面通信）

> ```bash
> ## postMessage 跨域
> - postMessage 是 HTML5 XMLHttpRequest Level 2 中的 API，且是为数不多可以跨域操作的window属性之一，
> - 它可以解决以下问题：
>     1. 页面和其打开的新窗口的数据传递
>     2. 多窗口之间的消息传递
>     3. 页面与嵌套的 iframe 消息传递
>     4. 上面三个场景的跨域数据传递
> - 用法：postMessage(data, origin) 方法接收两个参数
> 		- data：html5规范支持任意基本类型或可复制的对象，但部分浏览器只支持字符串，所以传参时最好用 JSON.stringify() 序列化。
> 		- origin：协议+主机+端口号，也可设置为 `"*"`，表示可传递给任意窗口，如果要指定和当前窗口同源的话设置为 `"/"`。
> 
> 
> ### 案例
> #### 1) a.html：(http://www.demo1.com/a.html)
>     <iframe id="iframe" src="http://www.demo2.com/b.html" style="display:none;"></iframe>
>     <script>       
>       const iframe = document.getElementById('iframe')
>       iframe.onload = () => {
>         const data = { name: 'willy' }
>         // 向domain2传送跨域数据
>         iframe.contentWindow.postMessage(JSON.stringify(data), 'http://www.demo2.com')
>       }
> 
>       // 接受domain2返回数据
>       window.addEventListener('message', (e) => {
>         console.log('data from demo2 ---> ', e.data)
>       }, false)
>     </script>
> 
> 
> #### 2) b.html：(http://www.demo2.com/b.html)
>     <script>
>       // 接收domain1的数据
>       window.addEventListener('message', (e) => {
>         console.log('data from demo1 ---> ', e.data)
>         const data = JSON.parse(e.data)
>         if (data) {
>           data.number = 16
>           // 处理后再发回domain1
>           window.parent.postMessage(JSON.stringify(data), 'http://www.demo1.com')
>         }
>       }, false)
>     </script>
> ```

### 4. CORS跨域共享（设置响应头 `Access-Control-Allow-Origin` ）

```bash
## CORS 跨域共享 (Cross-Origin Resource Sharing)
- 普通跨域请求：在服务端设置 `Access-Control-Allow-Origin` 即可，在前端无需设置，若要带 cookie 请求，前后端都需要设置。
- CORS 是主流的跨域解决方案，目前所有浏览器都支持该功能（IE8+: IE8/9需要使用`XDomainRequest`对象来支持CORS）。
- 需要注意：
    - 由于同源策略的限制，所读取的 cookie 为跨域请求接口所在域的 cookie，而非当前页。
    - 如果想要实现当前 cookie的写入，可参考 nginx反向代理设置`proxy_cookie_domain` 和 NodeJS中间件代理中 `cookieDomainRewrite` 参数的设置。
- 前端设置：原生ajax设置是否带cookie：`xhr.withCredentials = true`


### 前端配置的案例
#### 1) 前端设置的原生ajax（如果请求需要用cookie才需要设置）
    const xhr = new XMLHttpRequest() 	// IE8/9需用window.XDomainRequest兼容
    xhr.withCredentials = true	// 前端设置是否带 cookie
    xhr.open('post', 'http://www.demo2.com:8080/login', true)
    xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded')
    xhr.send('user=admin')
    xhr.onreadystatechange = () => {
      if (xhr.readyState == 4 && xhr.status == 200) {
        console.log(xhr.responseText);
      }
    }

#### 2) vue框架
在vue-resource封装的ajax组件中加入以下代码：
		Vue.http.options.credentials = true


### 后端配置的案例
若后端设置成功，前端浏览器控制台则不会出现跨域报错信息，反之，说明没设成功。
#### 1) PHP后台：
    // 若有端口需写全（协议+域名+端口）
    response.setHeader("Access-Control-Allow-Origin", "http://www.domain1.com"); 
    response.setHeader("Access-Control-Allow-Credentials", "true")

#### 2) Nodejs后台:
const http = require('http');
const server = http.createServer();
const qs = require('querystring');

server.on('request', (req, res) => {
  let postData = ''
  // 数据块接收中
  req.addListener('data', (chunk) => {
  	postData += chunk
  })

  // 数据接收完毕
  req.addListener('end', () => {
    postData = qs.parse(postData)

    // 跨域后台设置
    res.writeHead(200, {
      'Access-Control-Allow-Credentials': 'true',     // 后端允许发送Cookie
      'Access-Control-Allow-Origin': 'http://www.demo1.com',    // 允许访问的域（协议+域名+端口）
      'Set-Cookie': 'l=a123456;Path=/;Domain=www.demo2.com;HttpOnly'   // HttpOnly:脚本无法读取cookie
    })
    res.write(JSON.stringify(postData))
    res.end()
	})
})
server.listen('8080')
console.log('Server is running at port 8080...')
```



### 5. JSONP（利用script标签的可跨域性）

> ```bash
> ## jSONP (JSON with Padding)
> 1. JSONP 原理：
> 本质是利用 script 标签具有可跨域的特性，由服务端返回一个预先定义好的 JS 函数的调用，并且将服务器数据将以该函数参数的形式传递返回。
> JSON 只支持 get，因为 script 标签只能使用 get 请求； JSONP 需要后端配合返回指定格式的数据。
> 
> 2. JSONP 应用场景
> 通常为了减轻web 服务器的负载，把 js、css、image等静态资源分离到另一台独立域名的服务器上，在 html 页面中再通过相应的标签从不同域名下加载静态资源，从而被浏览器允许，基于此原理，我们可通过动态创建 script，再请求一个带参网址实现跨域通信。
> 
> 
> ### 案例
> #### 1) 前端html
>     <script>
>       const script = document.createElement('script')
>       script.type = 'text/javascript'
> 
>       // 传参并制定回调执行函数为 onBack
>       sciprt.src = 'http://www.demo.com:3000/login?user=admin&callback=onBack'
>       document.head.appendChild(script)
> 
>       // 回调执行函数
>       function onBack(res) {
>         console.log("后端返回的数据", res)
>       }
>     </script>
> 
> 
> #### 2) 后端 nodejs
>     const querystring = require('querystring')
>     const http = require('http')
>     const server = http.createServer()
> 
>     server.on('request', (req, res) => {
>       const params = qs.parse(req.url.split('?')[1])
>       const fn = params.callback
> 
>       // jsonp 返回设置
>       res.writeHead(200, { 'Content-Type': 'text/javascript' })
>       res.write(fn + '(' + JSON.stringify(params) + ')')
>       res.end()
>     })
>     server.listen('3000')
>     console.log('Server is running at port 3000...')
> ```

### 6. Nodejs中间件代理跨域

> ```bash
> ## Nodejs中间件代理跨域
> node 中间件实现跨域代理，原理大致与 nginx 相同，都是通过开启一个代理服务器来实现数据的转发，也可通过设置 `cookieDomainRewrite` 参数修改响应头中 cookie 的域名，实现当前域的 cookie 写入，方便接口登录认证。
> ```
>
> ````bash
> ## 1. 非Vue框架的跨域（2次跨域）：利用node + express + http-proxy-middleware搭建一个proxy服务器。
> 1) 前端代码示例
>      const xhr = new XMLHttpRequest()
>      // 前端开关：浏览器是否读写cookie
>      xhr.withCredentials = true
>      // 访问http-proxy-middleware代理服务器
>      xhr.open('get', 'http://www.demo1.com:3000/login?user=admin', true)
>      xhr.send()
> 
> 
> 2) 中间件服务器示例
>     const express = require('express')
>     const proxy = require('http-proxy-middleware')
>     const app = express()
>     app.use('/', proxy({
>       // 代理跨域目标接口
>       target: 'http://www.demo2.com:8080',
>       changeOrigin: true,
> 
>       // 修改响应头信息，实现跨域并允许带cookie
>       onProxyRes: (proxyRes, req, res) => {
>         res.header('Access-Control-Allow-Origin', 'http://www.domain1.com')
>         res.header('Access-Control-Allow-Credentials', 'true')
>       },
> 
>       // 修改响应信息中的cookie域名
>       cookieDomainRewrite: 'www.demo1.com'  // 可以为false，表示不修改
>     }))
>     app.listen(3000)
>     console.log('Proxy server is listen at port 3000...')
> 
> 
> 3) Nodejs后台
>     const http = require('http');
>     const server = http.createServer();
>     const qs = require('querystring');
>     server.on('request', (req, res) => {
>         const params = qs.parse(req.url.substring(2));
>         // 向前台写cookie
>         res.writeHead(200, {
>           'Set-Cookie': 'l=a123456;Path=/;Domain=www.demo2.com;HttpOnly'   // HttpOnly:脚本无法读取
>         })
>         res.write(JSON.stringify(params))
>         res.end()
>     })
>     server.listen('8080')
>     console.log('Server is running at port 8080...')
> ````
>
> ```bash
> ## 2.  vue框架的跨域（1次跨域）
> 利用node + webpack + webpack-dev-server代理接口跨域。
> 在开发环境下，由于vue渲染服务和接口代理服务都是webpack-dev-server同一个，所以页面与代理接口之间不再跨域，无须设置headers跨域信息了。
> 
> 
> ### vue项目的 webpack.config.js 部分配置
> module.exports = {
>     entry: {},
>     module: {},
>     ...
>     devServer: {
>       historyApiFallback: true,
>       proxy: [{
>         context: '/login',
>         target: 'http://www.demo2.com:8080',  // 代理跨域目标接口
>         changeOrigin: true,
>         secure: false,  // 当代理某些https服务报错时用
>         cookieDomainRewrite: 'www.demo1.com'  // 可以为false，表示不修改
>       }],
>       noInfo: true
>     }
> }
> ```

### 7. document.domain + iframe （需要主域名相同）

> ```bash
> ## document.domain + iframe 跨域（此方案需要两个都设置为域名，且主域名需要相同）
> - 此方案仅限于基础域名相同，子域名不同的跨域应用场景
> - 实现原理：两个页面都通过 js 强制设置 document.domain 为基础主域，就实现了同域。
> 
> 
> ### 使用 document.domain 的注意点
> - 如 `http:news.baidu.com` 这个地址如果要修改域名，只能修改为 `news.baidu.com`（满足第一条限制） 和 `baidu.com`（满足第二条限制），而不能设置为 `map.baidu.com` 或者 `.com` 等。
> - 如 `a.taobao.com` 页面通过 `document.domain='taobao.com'` 之后，不能直接访问 `taobao.com` 页面的资源：
> 		因为此时如果可以直接访问父级的资源，那么任何域名的子级域名地址（如`a.taobao.com`）都可以对父级（`taobao.com`）发起 xss 攻击。
> 		只有父子级都设置 `document.domain='taobao.com'` 才能达到跨域访问资源的目的。
> 
> 
> ### 实现的demo
> 1. 父窗口：http://www.demo.com/a.html
>     <iframe id="iframe" src="http://child.demo.com/b.html"></iframe>
>     <script>
>       document.domain = 'demo.com';
>       const user = 'admin';
>     </script>
> 
> 2. 子窗口：http://child.demo.com/b.html
>     <script>
>       document.domain = 'demo.com';
>       // 获取父窗口中的变量
>       alert('get js data from parent ->' + window.parent.user)
>     </script>
> ```

### 8. location.hash + iframe （需要创建第三个页面协同通信）

> ```bash
> ## location.hash + iframe 跨域
> 1. 实现原理：
> 	页面A想与页面B相互通信，通过中间页C来实现。
> 	三个页面，不同域之间利用 iframe 的 location.hash 传值，相同域之间直接 JS 访问通信。
> 2. 具体实现：
> 		A域：a.html -> B域：b.html -> A域：c.html
> 		a与b页面不同域只能通过hash值单向通信，b与c页面不同域也只能单向通信，但是 c与a 同域，所以 c 可通过 parent.parent 访问 a 页面所有对象。
> 
> 
> ### 实现 demo
> #### 1) a.html：http://www.demo1.com/a.html
>     <iframe id="iframe" src="http://www.demo2.com/b.html" style="display: none;"></iframe>
>     <script>
>       const iframe = document.getElementById('iframe')
>       // 向 b.html 传 hash 值
>       setTimeout(() => {
>         iframe.src = iframe.src + '#user=admin'
>       }, 1000)
>       // 开始给同域 c.html 的回调方法
>       function onCallback (res) {
>         alert('data from c.html --->', res)
>       }
>     </script>
> 
> #### 2) b.html：http://www.demo2.com/b.html
>     <iframe id="iframe" src="http://www.demo1.com/c.html" style="display: none;"></iframe>
>     <script>
>       const iframe = document.getElementById('iframe')
>       // 监听 a.html 传来的 hash 值，再传给 c.html
>       window.onhashchange = function () {
>         iframe.src = iframe.scr + location.hash
>       }
>     </script>
> 
> #### 3) c.html：http://www.demo1.com/c.html
>     <script>
>       const iframe = document.getElementById('iframe')
>       // 监听 b.html 传来的 hash 值
>       window.onhashchange = function () {
>         // 再通过操作同域 a.html 的js回调，将结果传回
>         window.parent.parent.onCallback('hello: ' + location.hash.replace('#user=', ''))
>       }
>     </script>
> ```
>

### 9. window.name + iframe（利用在同一个浏览器窗口内载入的域名共享一个 window.name）

> ```bash
> ## window.name + iframe
> - 利用在一个浏览器窗口内，载入所有的域名都是共享一个window.name
> - window.name 属性的独特之处：name值在不同的页面(甚至不同域名)加载后依旧存在，并且支持非常长的 name 值（2MB）。
> - 该跨域主要是通过 iframe 的 src 属性由外域转向本地域，跨域数据即由 iframe 的 window.name 从外域传递到本地域。这个巧妙地绕过浏览器的跨域访问限制，但同时它又是安全操作。
> 
> 
> ### 案例
> #### 1) a.html：http://www.demo1.com/a.html
>     const proxy = function (url, callback) {
>       let state = 0
>       const iframe = document.createElement('iframe')
>       iframe.src = url // 加载跨域页面
> 
>       // onload事件会触发2次
>       iframe.onload = function () {
>         if (state === 0) {
>           // 第1次加载跨域页成功后，切换到同域代理页面，并留存数据与 window.name
>           iframe.contentWindow!.location = 'http://www.demo1.com/proxy.html'
>           state = 1
>         } else if (state === 1) {
>           // 第2次onload（同域proxy页）成功后，读取同域 window.name 中数据
>           callback(iframe.contentWindow?.name)
> 
>           // 获取数据以后销毁这个iframe，释放内存；这也保证安全（不配其他域 frame js 访问）
>           iframe.contentWindow?.document.write('')
>           iframe.contentWindow?.close()
>           document.body.removeChild(iframe)
>         }
>       }
>     }
>     // 请求跨域 b 页面数据
>     proxy('http://www.demo2.com/b.html', function (data) {
>       console.log(data)
>     })
> 
> 
> #### 2) proxy.html：http://www.demo1.com/proxy.html
> 中间代理页，与a.html同域，内容为空
> 
> 
> #### 3) b.html：http://www.demo2.com/b.html
>     <script>
>       window.name = 'This is demo2 data!'
>     </script>
> ```

