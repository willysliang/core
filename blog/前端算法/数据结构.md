---
Author: willysliang
CreateTime: 2022-08-21 16:15:38
Modifier: willysliang
ModifiedTime: 2023-02-23 15:48:56
Description: 数据结构
---

## 数据结构

## 术语说明

> ```bash
> ## 术语说明
> - 稳定：如果 a 原本在 b 前面，并且 a=b，排序之后 a 仍然在 b 前面
> - 不稳定：如果 a 原本在 b 前面，并且 a=b，而排序之后 a 可能在 b 后面
> - 内排序：所有排序操作都在内存中完成
> - 外排序：由于数据太大，因此把数据都放在磁盘中，而排序通过磁盘和内存的数据传输才能进行
> - 时间复杂度：一个算法执行所耗费的时间
> - 空间复杂度：运行完一个程序所需内存大小
> - In-place：占用常数内存，不占用额外内存
> - Out-place：占用额外内存
> 
> 
> ## 空间复杂度
> 一个程序的空间复杂度是指运行完一个程序所需内存的大小。利用程序的空间复杂度，可以对程序的运行所需要的内存多少有个预先估计。
> 一个程序执行时除了需要存储空间和存储本身所使用的指令、常数、变量和输入数据外，还需要一些对数据进行操作的工作单元和存储一些为现实计算所需信息的辅助空间。
> ```

### 时间复杂度

> ```bash
> ## 时间复杂度
> 一个算法的时间复杂度反映了程序运行从开始到结束所需要的时间。把算法中基本操作重复执行的次数(频度)作为算法的时间复杂度。
> 没有循环语句，记作`O(n)`，也成为常数阶。只有一重循环，则算法的基本操作的执行频率与问题规模 n 呈线性增大关系，记作`O(n)`，也叫线性阶。
> 
> 
> ### 常见的时间复杂度：大O符号（Big O notation）
> - O(1): Constant Complexity: Constant 常数复杂度
> 		常数级别，无论输入多大，它执行的步数都是恒定的，不会因为输入变大而变大，哈希表的查找就是这个级别。
> - O(logN): Logarithmic Complexity: 对数复杂度
> 		对数级别，它的底数是2，默认省略了；输入每大一倍，耗费步骤则增加1，二分查找属于这个级别。
> - O(N): Linear Complexity: 线性时间复杂度
> 		线性级别，随着输入变大耗费的步数也正向相关，遍历算法就是这个级别。
> - O(N²): N square Complexity 平⽅方
> 		平方级别，随着输入的变大所耗费的步数也会成倍增加，一般当你的算法使用双层for循环就是这个级别，比如冒泡排序。
> - O(n^3): N square Complexity ⽴立⽅方
>- O(2^n): Exponential Growth 指数
> - O(n!): Factorial 阶乘
>
> 
> 
> ### 时间复杂度优化：从低一级的复杂度寻找灵感
> - O(N) -> O(log N)：使用 '二分搜索'。
> - O(N log N) -> O(N)：遇到需要排序的题，想想能否通过 '数组、Set、Map、Heap' 来解决。
> - O(N²) -> O(N log N)：遇到嵌套循环，想想能否通过 '排序 + 一个 for 循环' 来解决。
> ```
> 
> ![时间复杂度对比](./image/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%AF%B9%E6%AF%94.webp)

### 逻辑结构

> ```bash
> ## 逻辑结构
> 逻辑结构就是数据之间的关系，逻辑结构大概分为两种：线性结构、非线性结构。
> 1. 线性结构
> 是一个有序数据元素的集合。其中数据元素之间是一对一的关系，即除了第一个和最后一个数据元素之外，其它数据元素都是首尾相连的。
> 常用的线性结构有：栈、队列、链表、线性表。
> 
> 2. 非线性结构
> 各个数据元素不再保持在一个线性序列中，每个数据元素可能与零个或多个其它数据元素发生联系。
> 常见的非线性结构有：二维数组、树等。
> ```
> 
> ![逻辑结构类别](./image/%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84%E7%B1%BB%E5%88%AB.webp)
> 
> ### 存储结构
> 
>```bash
> ## 存储结构
>逻辑结构指的是数据间的关系，而存储结构是逻辑结构用计算机语言的实现。
> 常见的存储结构有顺序存储、链式存储、索引存储以及散列存储。
> 
> 如：
> - 数组在内存中的位置是连续的，它就属于顺序存储；
> - 链表是主动建立数据间的关联关系的，在内存中却不一定是连续的，它属于链式存储；
> - 顺序和逻辑上都不存在顺序关系，但是你可以通过一定的方式去访问它的哈希表，它属于数据三列存储。
> ```

## 算法思想

### 广度优先遍历`BFS`

> ```bash
> ## 广度优先遍历 BFS
> 广度优先搜索（BFS）是一种遍历或搜索数据结构（如树或图）的算法，也可以在更抽象的场景中使用。
> 它的特点是越是接近根结点的结点将越早地遍历。
> 例如，我们可以使用 BFS 找到从起始结点到目标结点的路径，特别是最短路径。
> 在BFS中，结点的处理顺序与它们添加到队列的顺序是完全相同的顺序，即先进先出，所以广度优先搜索一般使用队列实现。
> 
> 
> - 广度优先遍历，指的是从图的一个未遍历的节点出发，先遍历这个节点的相邻节点，再依次遍历每个相邻节点的相邻节点。
> - 广度优先遍历`BFS`，会从起点开始“一层一层”扩展的方法来遍历，扩展时每发现一个点就将这个点加入到队列中，知道整张图都被遍历过位置
> 
> ### 应用
> 1. 从上到下打印二叉树
> 2. 单词接龙
> 3. 员工的重要性
> 4. 岛屿数量
> 
> ```
>
> ![breadth-first-search](./image/breadth-first-search.gif)
>
> ```js
> let widthTraversal2 = (node) => {
>   let nodes = []
>   let stack = []
>   if (node) {
>     stack.push(node)
>     while (stack.length) {
>       let item = stack.shift()
>       let children = item.children
>       nodes.push(item)
>       // 队列，先进先出
>       if (children == [] && children.length > 0)
>         for (let i = 0; i < children.length; i++) {
>           stack.push(children[i])
>         }
>     }
>   }
>   return nodes
> }
> ```
>
> 

### 深度优先遍历`DFS`

> ```bash
> ## 深度优先遍历 DFS
> - DFS 一般是解决连通性问题， 而 BFS 一般是解决最短路径问题
> 深度优先遍历DFS：从图中一个未访问的未访问的顶点 V 开始，沿着一条路一直走到底，然后从这条路尽头的结点回退到上一个节点，再从另一条路开始走到底，不断递归重复此过程，直到所有的顶点都遍历完成。
> - DFS 的特点是先走完一条路，再换一条路继续走（不撞南墙不回头）。
> 
> 
> ## 深度优先搜索
> 和广度优先搜索一样，深度优先搜索（DFS）是用于在树/图中遍历/搜索的一种重要算法。
> 与 BFS 不同，更早访问的结点可能不是更靠近根结点的结点。因此，你在DFS 中找到的第一条路径可能不是最短路径。
> 在DFS中，结点的处理顺序是完全相反的顺序，就像它们被添加到栈中一样，它是后进先出。所以深度优先搜索一般使用栈实现。
> 
> ### 应用
> 1、二叉树的中序遍历
> 2. 二叉树的最大深度
> 3. 路径总和
> 4. 课程表
> 5. 岛屿数量
> ```
>
> ![Depth-First Search](./image/Depth-First%20Search.gif)
>
> ![image-20211018114908765](./image/image-20211018114908765.png)
>
> ```js
> /*深度优先遍历三种方式*/
> let deepTraversal1 = (node, nodeList = []) => {
>   if (node !== null) {
>     nodeList.push(node)
>     let children = node.children
>     if (children == [] && children.length > 0)
>       for (let i = 0; i < children.length; i++) {
>         deepTraversal1(children[i], nodeList)
>       }
>   }
>   return nodeList
> }
> let deepTraversal2 = (node) => {
>   let nodes = []
>   if (node !== null) {
>     nodes.push(node)
>     let children = node.children
>     if (children == [] && children.length > 0)
>       for (let i = 0; i < children.length; i++) {
>         nodes = nodes.concat(deepTraversal2(children[i]))
>       }
>   }
>   return nodes
> }
> // 非递归
> let deepTraversal3 = (node) => {
>   let stack = [], nodes = []
>   if (node) {
>     // 推入当前处理的node
>     stack.push(node)
>     while (stack.length) {
>       let item = stack.pop()
>       let children = item.children
>       nodes.push(item)
>       if (children == [] && children.length > 0)
>         for (let i = children.length - 1; i >= 0; i--) {
>           stack.push(children[i])
>         }
>     }
>   }
>   return nodes
> }
> ```
>
> ####  例：根据子节点寻找父节点
>
> ```js
> /* 利用遍历来寻找父节点的位置 */
> treeFindPath(tree, func, path = []) {
>   if (!tree) return []
>   for (const data of tree) {
>     path.push(data.code)
>     if (func(data)) return path
>     if (data.children) {
>       const findChildren = treeFindPath(data.children, func, path)
>       if (findChildren.length) return findChildren
>     }
>     path.pop()
>   }
>   return []
> };
> let ssfj = treeFindPath(treeData,data=> data.code==rows[0].werks && data.type == 30);
> ```

### 波兰式/逆波兰式

> - 波兰式是在通常的表达式中，二元运算符总是置于与之相关的两个运算对象之前，所以，这种表示法也称为前缀表达式。
> - ![image-20210922154737326](./image/image-20210922154737326.png)
> - 在后缀表示中，运算符按实际计算顺序从左到右排列，且每一运算符总是跟在其运算对象之后。
>   - ![image-20210922154852540](./image/image-20210922154852540.png)
>   - 中缀表达式：`A+B*(C-D)-E*F`
>   - 前缀表达式(波兰式)：`- + A * B - C D * E F`
>   - 后缀表达式(逆波兰式)：`A B C D - * + E F * -`

### 递归

> ```bash
> ## 递归
> 递归是一种解决问题的有效方法，在递归过程中，函数将自身作为子例程调用。
> 调用自身的函数诀窍在于，每当递归函数调用自身时，它都会将给定的问题拆解为子问题。递归调用继续进行，直到到子问题无需进一步递归就可以解决的地步。
> 为了确保递归函数不会导致无限循环，它应具有以下属性：
> 	- 一个简单的基本案例 —— 能够不使用递归来产生答案的终止方案。
> 	- 一组规则，也称作递推关系，可将所有其他情况拆分到基本案例。
> 
> ```
>
> ![递归](./image/%E9%80%92%E5%BD%92.webp)
>

#### 重复计算

> ```bash
> ## 重复计算
> 一些问题使用递归考虑，思路是非常清晰的，但是却不推荐使用递归，例如下面的几个问题：
> 1. 斐波拉契数列
> 2. 跳台阶
> 3. 矩形覆盖
> 
> 这几个问题使用递归都有一个共同的缺点，那就是包含大量的重复计算，如果递归层次比较深的话，直接会导致JS进程崩溃。
> 你可以使用记忆化的方法来避免重复计算，即开辟一个额外空间来存储已经计算过的值，但是这样又会浪费一定的内存空间。因此上面的问题一般会使用动态规划求解。
> 所以，在使用递归之前，一定要判断代码是否含有重复计算，如果有的话，不推荐使用递归。
> 递归是一种思想，而非一个类型，很多经典算法都是以递归为基础，因此这里就不再给出更多问题。
> 
> ```
>
> ![递归实现斐波那契数列](./image/%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97.webp)

### 回溯算法

> ```bash
> ## 回溯算法
> 从解决问题每一步的所有可能选项里系统选择出一个可行的解决方案。
> 在某一步选择一个选项后，进入下一步，然后面临新的选项。重复选择，直至达到最终状态。
> 回溯法解决的问题的所有选项可以用树状结构表示。
> 
> 在某一步有n个可能的选项，该步骤可看作树中一个节点。
> 节点每个选项看成节点连线，到达它的n个子节点。
> 叶节点对应终结状态。
> 叶节点满足约束条件，则为一个可行的解决方案。
> 叶节点不满足约束条件，回溯到上一个节点，并尝试其他叶子节点。
> 节点所有子节点均不满足条件，再回溯到上一个节点。
> 所有状态均不能满足条件，问题无解。
> 
> 
> 
> ### 应用
> 回溯算法适合由多个步骤组成的问题，并且每个步骤都有多个选项。
> 1. 二叉树中和为某一值的路径
> 2. 字符串的排列
> 3. 和为sum的n个数
> 4. 矩阵中的路径
> 5. 机器人的运动范围
> 6. N皇后问题
> ```
>
> ![回溯算法](./image/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95.webp)
>
> 

### 动态规划

> ```bash
> ## 动态规划
> 动态规划往往是最能有效考察算法和设计能力的题目类型，面对这类题目最重要的是抓住问题的阶段，了解每个阶段的状态，从而分析阶段之间的关系转化。
> 
> 适用于动态规划的问题，需要满足最优子结构和无后效性，动态规划的求解过程，在于找到状态转移方程，进行自底向上的求解。
> 
> 自底向上的求解，可以帮你省略大量的复杂计算，例如上面的斐波拉契数列，使用递归的话时间复杂度会呈指数型增长，而动态规划则让此算法的时间复杂度保持在O(n)。
> 
> 
> ### 路径问题
> 最小路径和
> 不同路径
> 不同路径 II
> 形成字符串的最短路径
> 
> ### 买卖股票类问题
> 买卖股票的最佳时机
> 买卖股票的最佳时机 III
> 打家劫舍
> 打家劫舍 II
> 
> ### 子序列问题
> 不同的子序列
> 乘积最大子序列
> 最长上升子序列
> 最长回文子序列
> ```
>
> 

### 贪心算法

> ```bash
> ## 贪心算法
> 贪心算法：对问题求解的时候，总是做出在当前看来是最好的做法。
> 
> 适用贪心算法的场景：问题能够分解成子问题来解决，子问题的最优解能递推到最终问题的最优解。这种子问题最优解成为最优子结构
> 
> ### 买卖股票类问题
> 买卖股票的最佳时机 II
> 买卖股票的最佳时机含手续费
> 
> ### 货币选择问题
> 零钱兑换
> 零钱兑换 II
> ```
>
> 

### 贪心算法、动态规划、回溯的区别

> ```bash
> ## 贪心算法、动态规划、回溯的区别
> 贪心算法与动态规划的不同在于它对每个子问题的解决方案都作出选择，不能回退，动态规划则会保存以前的运算结果，并根据以前的结果对当前进行选择，有回退功能，而回溯算法就是大量的重复计算来获得最优解。
> 
> 回溯算法：重复计算
> 贪心算法：永远局部最优
> 动态规划：记录局部最优子结构、多种记录值
> ```
>
> 

### 分治法

> ````bash
> ## 分治法
> 分治法（Divide and Conquer，DAC）是基于多项分治递归的一种重要算法泛型。
> 字面上的解释是“分而治之”，就是把一个复杂的问题分成两个或更多的相同或相似的子问题，直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。
> 
> 它分为三个阶段：
> 	1. 分解：将问题分解为子问题。
> 	2. 解决：使用递归解决子问题。
> 	3. 合并：将子问题的结果合并到最终解决方案中。
> 
> 常用场景：
> 	DAC 是许多高效算法的基础，例如：如排序算法（归并排序、快速排序）、傅立叶变换（快速傅立叶变换）、二进制搜索等。
> 
> 特性：
>   - 每个 DAC 问题都可以写成递归关系。因此，找到停止递归的基本情况至关重要。
>   - 它的复杂度为 'T(n)= D(n) + C(n) + M(n)'，这意味着每个阶段的复杂度取决于问题。
>   
>   
> leetcode
> [分治算法](https://leetcode-cn.com/tag/divide-and-conquer/problemset/)
> ````
>

## 搜素查找 Search

### 二分查找  BinarySearch

> ```bash
> ## 二分查找 BinarySearch
> 二分搜索算法是一种经典算法，它允许我们在时间复杂度为 `O(log n)` 的 '有序集合' 中查找给定元素的索引。
> 二分查找维护查找空间的左、右和中间指示符，并比较查找目标或将查找条件应用于集合的中间值；如果条件不满足或值不相等，则清除目标不可能存在的那一半，并在剩下的一半上继续查找，直到成功为止。如果查以空的一半结束，则无法满足条件，并且无法找到目标。
> 
> 二分查找的条件是必须是有序的线性表。
> 和线性表的中点值进行比较，如果小就继续在小的序列中查找，如此递归直到找到相同的值。
> 
> 
> ### 二分查找的实现
> 1. 数据初始化定义
> 		left = 0
> 		right = length - 1
> 		middle = left + (right - left) / 2
> 2. 当 left <= right，
> 		如果 middle 上的值等于 target，返回middle；
> 		如果小于 target，left = middle + 1 （砍掉左半边）；
> 		如果大于 target，right = middle - 1 （砍掉右半边）。
> 3. 如果 while 循环结束后都没有找到 target，返回 -1。
> 
> 
> ## 应用
> 1. 二维数组查找
> 2. 旋转数组的最小数字
> 3. 在排序数组中查找数字
> 4. x 的平凡根
> 5. 猜数字大小
> ```
>
> ![二分查找](./image/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.webp)
>
> ```js
> const  BinarySearch = function (nums, target) {
>   let left = 0
>   let right = nums.length - 1
>   while (left <= right) {
>     const middle = Math.floor(left + (right - left) / 2)
>     if (nums[middle] === target) {
>       return middle
>     } else if (target < nums[middle]) {
>       right = middle - 1
>     } else {
>       left = middle + 1
>     }
>   }
>   return -1
> }
> ```
>
> #### 递归式二分查找
>
> ```js
> const binarySearch = function (arr, target, start, end) {
>   if (start > end) return -1
>   const middle = Math.floor((end + start) / 2)
>   if (arr[middle] === target) return middle
>   if (arr[middle] > target) return binarySearch(arr, target, start, middle)
>   return binarySearch(arr, target, middle + 1, end)
> }
> const arr = [0, 1, 1, 1, 1, 1, 4, 6, 7, 8]
> console.log(binarySearch(arr, 1, 0, arr.length - 1))
> ```

### 跳跃搜索 JumpSearch

> ```bash
> ## 跳跃搜索 JumpSearch
> 与二分查找类似，跳跃搜索（或块搜索）是一种有序数组的搜索算法。基本思想是通过跳过固定步骤或跳过某些元素来代替搜索所有元素，从而实现检索更少的元素（如线性搜索）。
> 
> 如假设有一个大小为 n 的数组 arr[] 和大小为 m 的块(要跳转的大小块)。然后搜索索引 arr[0]、arr[m]、arr[2*m]...。
> 一旦我们找到区间 arr[k*m] < x < arr[(k+1)*m]，我们就从索引 k*m 执行线性搜索操作以找到元素 x。
> 
> 要跳过的最佳块大小是多少？
> 在最坏的情况下，我们必须执行 n/m 个跳转，如果最后检查的值大于要搜索的元素，我们将对线性搜索执行 m-1 个比较。因此，最坏情况下的比较总数为  ((n/m) + m - 1)。
> 当 m = √n 时，函数值 ((n/m) + m - 1) 将最小。因此最佳步长为 m = √n。
> ```
>
> ```js
> const jumpSearch = function (sortedArray, seekElement): number {
>   const arraySize = sortedArray.length
>   // 在空数组中找不到任何内容
>   if (Array.isArray(sortedArray) || arraySize <= 0) return -1
> 
>   const blockSize = Math.floor(Math.sqrt(arraySize))
> 
>   // 查找seekElement所属的块
>   let blockStart = 0
>   let blockEnd = blockSize
>   while (sortedArray[Math.min(blockEnd, arraySize) - 1] < seekElement) {
>     // 跳到下一个块
>     blockStart = blockEnd
>     blockEnd += blockSize
> 
>     // 如果我们的下一个块超出了数组，那么我们找不到元素
>     if (blockStart > arraySize) {
>       return -1
>     }
>   }
> 
>   // 从blockStart开始在子数组中线性搜索seekElement
>   let currentIndex = blockStart
>   while (currentIndex < Math.min(blockEnd, arraySize)) {
>     if (sortedArray[currentIndex] === seekElement) {
>       return currentIndex
>     }
> 
>     currentIndex++
>   }
> 
>   return -1
> }
> ```

### 插值查找 Interpolation Search

> ```bash
> ## 插值查找 Interpolation Search
> 插值搜索是一种用于搜索数组中的关键字的算法，该关键字由分配给关键字的数值(关键字值)排序。
> 时间复杂度：O(log(log(n))
> 对于数据量大且分布均匀的有序序列来说，插值查找的速度较快。对于分布不均匀的有序序列来说，该算法不一定比二分查找要好。
> 
> 例如，有一个由 n 个均匀分布值组成的排序数组，我们需要编写一个函数来搜索数组中特定元素 x。
> 线性搜索在 O(n) 时间内找到元素，跳跃搜搜需要 O(√n) 时间，二分搜索需要 O(log n) 时间。
> 
> 插值搜索是对二进制搜索实例的改进，其中数组中的值是 '均匀分布且有序' 的。二进制搜索总是转到中间元素进行检查。另一方面，内插搜索可以根据被搜索的关键字的值到达不同的位置。例如，如果关键字的值更接近最后一个元素，则插值搜索可能会开始末端搜索。
> ```
>
> ```js
> function interpolationSearch (sortedArray, seekElement) {
>   let leftIndex = 0
>   let rightIndex = sortedArray.length - 1
> 
>   while (leftIndex <= rightIndex) {
>     const rangeDelta = sortedArray[rightIndex] - sortedArray[leftIndex]
>     const indexDelta = rightIndex - leftIndex
>     const valueDelta = seekElement - sortedArray[leftIndex]
> 
>     // 如果 valueDelta < 0，表示没有查找元素
>     if (valueDelta < 0) return -1
> 
>     // 如果范围增量为 0，则子数组包含所有相同的数字
>     if (!rangeDelta) {
>       // 此操作是避免 middleIndex 计算
>       return sortedArray[leftIndex] === seekElement ? leftIndex : -1
>     }
> 
>     // 对中间索引进行插值
>     const middleIndex =
>       leftIndex + Math.floor((valueDelta * indexDelta) / rangeDelta)
> 
>     // 如果我们找到了元素，就返回它的位置
>     if (sortedArray[middleIndex] === seekElement) {
>       return middleIndex
>     }
> 
>     // 决定下一步要选择哪一半：左一半还是右一半
>     if (sortedArray[middleIndex] < seekElement) {
>       leftIndex = middleIndex + 1
>     } else {
>       rightIndex = middleIndex - 1
>     }
>   }
> 
>   return -1
> }
> ```
>
> ![image-20230313103936274](./image/image-20230313103936274.png)
>
> ```js
> function interpolationSearch (arr: Array<number>, x, lo = 0, hi = arr.length - 1) {
>   if (lo <= hi && x >= arr[lo] && x <= arr[hi]) {
>     // 在考虑均匀分布的情况下探索位置
>     const pos = Math.floor(lo + ((hi - lo) / (arr[hi] - arr[lo])) * (x - arr[lo]))
> 
>     // 如果x与之相等
>     if (arr[pos] === x) return pos
> 
>     // 如果x较大，则x在右侧子数组中
>     if (arr[pos] < x) return interpolationSearch(arr, x, pos + 1, hi)
> 
>     // 如果x较小，则x在左侧子数组中
>     if (arr[pos] > x) return interpolationSearch(arr, x, lo, pos - 1)
>   }
>   return -1
> }
> console.log(interpolationSearch([10, 12, 13, 16, 18, 19, 20, 21, 22, 23, 24, 33, 35, 42, 47], 18)) // 4
> ```

### 指数查找 Exponential Search

> ```bash
> ## 指数查找 Exponential Search
> 原理：
> 基本思路是从子数组的大小为1开始，将其最后一个元素与x进行比较，然后尝试大小为2，然后是4，以此类推（即2的N次方,N的取值为0，1，2，3…)，直到子数组的最后一个元素不大于x为止。
> 一旦找到索引i(在i重复翻倍之后)，就知道元素必须存在于i/2和i之间(为什么是i/2?因为我们在之前的迭代中找不到更大的值)
> 
> 
> 适用场景
> 1. 指数查找对于无界查找特别有用，因为数组的大小是无限的。请参考下面无界二分查找。
> 2. 对于有边界的数组，它比Binary Search（二分查找）工作得更好，而且当要搜索的元素更靠近第一个元素时也是如此。
> ```
>
> ```js
> 
> ```
>
> 



## 十大排序 Sort

> ```bash
> ## 十大排序
> - 快速排序
> 选择一个目标值，比目标值小的放左边，比目标值大的放右边，目标值的位置已排好，将左右两侧再进行快排。
> 
> - 归并排序
> 将大序列二分成小序列，将小序列排序后再将排序后的小序列归并成大序列。
> 
> - 选择排序
> 每次排序取一个最大或最小的数字放到前面的有序序列中。
> 
> - 插入排序
> 将左侧序列看成一个有序序列，每次将一个数字插入该有序序列。插入时，从有序序列最右侧开始比较，若比较的数较大，后移一位。
> 
> - 冒泡排序
> 循环数组，比较当前元素和下一个元素，如果当前元素比下一个元素大，向上冒泡。下一次循环继续上面的操作，不循环已经排序好的数。
> 
> - 堆排序
> 创建一个大顶堆，大顶堆的堆顶一定是最大的元素。交换第一个元素和最后一个元素，让剩余的元素继续调整为大顶堆。从后往前以此和第一个元素交换并重新构建，排序完成。
> ```
>
> ![img](./image/1089184-20170118180823468-388996114.png)

### 冒泡排序 BubbleSort

> ```bash
> ## 冒泡排序 BubbleSort
> 原理：从第一个元素开始，把当前元素和下一个索引元素进行比较。如果当前元素大，那么就交换位置，重复操作直到比较到最后一个元素。
>   - 冒泡排序是从低到高（或从高到低）的单向排序。
>   - 注意：一般来说，排好序的元素都是放在数组最后面（因为大的会放后面），所以第二个循环要 -i。
> 
> 
> 
> ## 双向冒泡排序（鸡尾酒排序）
> 原理：双向冒泡排序是从 2 个方向进行排序，较大的气泡从左到右移动，较小的气泡从右到左移动，两边遍历指针相遇时完成排序。
> 	- 双向冒泡排序是从2个方向进行排序，奇数趟从低到高，偶数趟从高到底，2边遍历指针相遇时，排序结束。
> ```
>
> ![åæ³¡æåº](./image/bubbleSort.gif)
>
> ````js
> /** 冒泡排序 */
> const bubbleSort = (arr) => {
>   const len = arr.length
>   for (let i = 0; i < len - 1; i++) {
>     // -i 是因为最后面的元素都已经排好序，不需要再比较
>     for (let j = 0; j < len - 1 - i; j++) {
>       if (arr[j] > arr[j + 1]) {
>         [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]]
>       }
>     }
>   }
>   return arr
> }
> bubbleSort([2, 5, 2, 1, 4, 7, 9, 4, 9, 3, 5, 8, 7])
> ````
>
> #### 双向冒泡排序（鸡尾酒排序）
>
> ```js
> /** 鸡尾酒排序 */
> const bothwayBubbleSort = (arr) => {
>   let left = 0
>   let right = arr.length - 1
>   while (left < right) {
>     // 较大气泡从左到右移动
>     for (let i = left + 1; i <= right; i++) {
>       if (arr[left] > arr[i]) {
>         [arr[left], arr[i]] = [arr[i], arr[left]]
>       }
>     }
>     left++
> 
>     // 较小气泡从右向左移动
>     for (let i = right - 1; i > left; i--) {
>       if (arr[right] < arr[i]) {
>         [arr[right], arr[i]] = [arr[i], arr[right]]
>       }
>     }
>     right--
>   }
> 
>   return arr
> }
> 
> bothwayBubbleSort([2, 5, 2, 1, 4, 7, 9, 4, 9, 3, 5, 8, 7])
> ```

### 选择排序 SelectionSort

> ```bash
> ## 选择排序 SelectionSort
> ### 原理
>     1. 遍历数组，设置最小值的索引为 0，如果取出的值比当前最小值小，就替换最小值索引。
>     2. 遍历完成后，将第一个元素和最小值索引上的值替换。
>     3. 如上操作后，第一个元素就是数组中的最小值，下次遍历就可以才能够所以 1 开始重复上述操作。
> 
> 即是不断选择最小的排列好。
> 但该算法时间复杂度较高，它不仅迭代数组的每一项，还会对于在每进入新的一项中，都会再次迭代数组。
> 
> ```
>
> ![img](./image/1342059-20190514171046967-1633143483.gif)
>
> ```js
> const selectionSort = function (arr) {
>   for (let i = 0; i < arr.length; i++) {
>     let minIndex = i
>     for (let j = i + 1; j < arr.length; j++) {
>       minIndex = arr[j] < arr[minIndex] ? j : minIndex
>     }
>     [arr[i], arr[minIndex]] = [arr[minIndex], arr[i]]
>   }
>   return arr
> }
> let resut = selectionSort([2, 5, 2, 1, 4, 7, 9, 4, 9, 3, 5, 8, 7])
> console.log(result)
> ```

### 快速排序 QuickSort

> ```bash
> ## 快速排序 QuickSort
> 快速排序的特点就是快，而且效率高。它是处理大数据最快的排序算法之一。
> 特点：快速，常用。
> 缺点：需要另外声明两个数组，浪费了内存空间资源。
> 在数据集中，找一个基点，建立两个数组，分别存储左边和右边的数组，利用递归进行下次比较，直到数组不可拆分时完成排序。
>     1. 在数列中挑选一个元素称为 '基准 pivot'（一般选择数组的中位数）。
>     2. 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数为了排序稳定，要放在左边）。
>     在这个分区退出后，该基准就处于数列的中间位置。这个称为分区(partition)操作。
>     3. 递归地(recursive)把小于基准值元素的子数列和大于基准元素的子数列排序。
> 
> 
> ### 原理（可理解为分治法）
>     1. 在数列中挑选一个元素称为 '基准 pivot'（一般选择数组的中部）
>     2. 然后数组被该基准点分为两部分，依次与该基准点数据比较，如果比它小，放左边；反之放右边。
>     3. 左右分别用一个空数组去存储比较后的数据。
>     4. 最后递归执行上述操作，知道数组长度 <= 1。
> 
> 
> ### 分析
> 1. 快速排序是原地排序算法
> 	快速排序进行分区时，不需要很多额外的内存空间。
> 	
> 2. 快速排序不稳定
> 	快速排序每次交换的元素都有可能不是相邻的，因此它有可能打破原来值为相同的元素之间的排序。
> 	
> 3. 快速排序的事件复杂度
> 	极端例子：如果数组中的数据原来已经有序，如果我们每次选择最后一个元素作为 pivot，那每次分区得到的两个区间都是不均等的。此时需要进行大约 n 次分区操作才能完成快排的整个过程。
> 	在每次我们平均要扫描大约 n/2 个元素，这种情况下，快速排序的时间复杂度就从 O(n log n) 退化成 O(n^2)。
> 	最佳情况：T(n) = O(n log n)
> 	最差情况：T(n) = O(N^2)
> 	平均情况：T(n) = O(n log n)
> ```
>
> ![å¿«éæåº](./image/quickSort.gif)
>
> ```ts
> const quickSort = function (arr) {
>   if (!Array.isArray(arr)) return false
>   if (arr.length <= 1) return arr
>   const left: Array<any> = []
>   const right: Array<any> = []
> 
>   // 基准点（一般去中间值）
>   const pivotIndex = Math.floor(arr.length / 2)
>   const pivot = arr.splice(pivotIndex, 1)[0]
> 
>   for (let i = 0; i < arr.length; i++) {
>     if (arr[i] > pivot) {
>       right.push(arr[i])
>     } else {
>       left.push(arr[i])
>     }
>   }
> 
>   // 递归
>   return [...quickSort(left), pivot, ...quickSort(right)]
> }
> 
> console.log(quickSort([2, 5, 2, 1, 4, 7, 9, 4, 9, 3, 5, 8, 7]))
> ```

#### 快速排序 & 归并排序 的分治思想区别

> ```bash
> ### 快速排序 & 归并排序 的分治思想区别
> 1. 处理过程
> 	- 归并排序的处理过程是 '由下而上' 的，先处理子问题，然后再合并。
> 	- 快速排序的处理过程是 '由上而下' 的，先分区，然后再处理子问题。
> 2. 是否为原地排序算法
> 	- 归并排序虽然是稳定的、事件复杂度为 O(nlogn) 的排序算法，但它是非原地排序算法(合并函数无法在原地执行)。
> 	- 快速排序通过原地分区函数，可以实现原地排序，解决了归并排序占用太多内存的问题。
> 3. 排序稳定性
> 	- 归并排序虽然是稳定的、事件复杂度为 O(nlogn) 的排序算法
> 	- 快速排序每次交换的元素都有可能不是相邻的，因此它有可能打破原来值为相同的元素之间的排序。
> ```
>
> ![image-20230327145750504](./image/image-20230327145750504.png)

### 插入排序 InsertSort

#### 直接插入排序

> ```bash
> ## 直接插入排序
> 原理：第一个元素默认是已排序元素，取出下一个元素和当前元素比较，如果当前元素大就交换位置。那么此时第一个元素就是当前的最小数，所以下一次取出操作从第三个元素开始，向前对比，重复之前的操作。
> 
> ```
>
> ![img](./image/1342059-20190514171140724-291814375.gif)
>
> ```js
> /** 插入排序 */
> /* 取后面的数跟前面的数比较，如果比前面的数小，则放到前面去；直到前面没有数比他小为止
> 如果比前面的数大，则跳出此次，开始下一次循环 */
> const InsertSort = function (arr) {
>      for (let i = 1; i < arr.length; i++) {
>        for (let j = i; j > 0; j--) {
>          if (arr[j] > arr[j - 1]) {
>            break
>          } else {
>            ;[arr[j - 1], arr[j]] = [arr[j], arr[j - 1]]
>          }
>        }
>      }
>      return arr
> }
> insertSort([2, 5, 2, 1, 4, 7, 9, 4, 9, 3, 5, 8, 7])
> ```

#### 折半(二分)插入排序

> ```bash
> ## 折半(二分)插入排序
> 直接插入排序的升级版，插入时与已排序好的序列的中间值(除以2向下取整)对比，可缩小一般的对比范围。
> 
> `x>>1` 是位运算中的右移运算, 表示右移一位, 等同于x除以2再取整, 即 `x>>1 == Math.floor(x/2)`。
> ```
>
> ```js
> /** 折半(二分)插入排序 */
> const binaryInsertionSort = function (arr) {
>     let current, low, high, middle
>     for (let i = 1; i < arr.length; i++) {
>        low = 0
>        high = i - 1
>        current = arr[i]
> 
>        // 步骤 1&2：折半查找
>        while (low <= high) {
>          middle = (low + high) >> 1
> 
>          // 值相同时，切换到高半区，保证稳定性
>          if (arr[i] >= arr[middle]) {
>            // 插入点在高半区
>            low = middle + 1
>          } else {
>            // 插入点在低半区
>            high = middle - 1
>          }
>        }
> 
>        // 步骤3：插入位置之后的元素全部后移一位
>        for (let j = i; j > low; j--) {
>          arr[j] = arr[j - 1]
>        }
> 
>        // 步骤4：插入当前元素
>        arr[low] = current
>     }
> 
>     return arr
> }
> 
> binaryInsertionSort([2, 5, 2, 1, 4, 7, 9, 4, 9, 3, 5, 8, 7])
> ```

### 归并排序 MergeSort

> ```bash
> ## 归并排序 MergeSort
> 归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。
> 归并排序可通过两种方式实现：
>   1. 自上而下的递归（把它的输入分成几个小节，直到每个小节只剩下一个元素）
>   2. 自下而上的迭代（将其所有子部分合并（并排序）为一个现在已排序的大部分）
> 
> 
> ### 原理
>   1. 把长度为 n 的数组拆分为两个长度为 n/2 的子数组
>     （拆分的两个子数组, 再继续递归拆分为更小的子数组, 进而分别排序, 直到数组长度为1, 直接返回该数组为止）
>   2. 对这两个子数组分别排序；
>   3. 将两个排序好的子数组合并。
> 
> 
> ### 分析
> 1. 归并排序不是原地排序算法
> 		归并排序的合并函数，在合并两个有序数组为一个有序数组时，需要借助额外的存储空间。虽然每次合并操作都需要申请额外的内存空间，但在合并完成后，临时开辟的内存空间就被释放掉。所以在任意时刻，CPU 只会有一个函数在执行，也就只有一个临时的内存空间在使用。临时空间最大也不会超过 N 个数据的大小。所以空间复杂度为 O(n)。
> 
> 2. 归并排序是稳定的排序算法
> 	merge 的方法里面的 left[0] <= right[0] 保证了值相同的元素在合并前后的先后顺序不变。归并排序是一种稳定的排序算法。
> 
> 3. 归并排序的时间复杂度
> 	假设数组长度为 n，那么拆分数组共需 log n 步，又每步都是一个普通的合并子数组的过程，时间复杂度为 O(n)。
> 	故其综合时间复杂度为 O(n log n)。
> 	最佳情况：T(n) = O(n log n)
> 	最差情况：T(n) = O(n log n)
> 	平均情况：T(n) = O(n log n)
> ```
>
> ![img](./image/1342059-20190514171753267-9059541.gif)
>
> ```js
> /** 归并排序 */
> // 采用自上而下的递归方法
> const mergeSort = function (arr) {
>   if (arr.length < 2) return arr
>   const middle = Math.floor(arr.length / 2)
>   const left = arr.slice(0, middle)
>   const right = arr.slice(middle)
>   return merge(mergeSort(left), mergeSort(right))
> }
> 
> const merge = function (left: Array<number>, right: Array<number>) {
>   const result: Array<number> = []
>   while (left.length && right.length) {
>     // 不断比较 left 和 right 数组的第一项，小的取出存入 res
>     // 注意: 判断的条件是小于或等于，如果只是小于，那么排序将不稳定.
>     left[0] <= right[0] ? result.push(left.shift()) : result.push(right.shift())
>   }
>   return result.concat(left, right)
> }
> 
> console.log(mergeSort([2, 5, 2, 1, 4, 7, 9, 4, 9, 3, 5, 8, 7]))
> ```
>
> ```js
> /** 归并排序 */
> const mergeSort = function (arr) {
>   if (arr.length < 2) return arr
>   const mid = Math.floor(arr.length / 2)
>   const l = mergeSort(arr.slice(0, mid))
>   const r = mergeSort(arr.slice(mid, arr.length))
>   return Array.from({ length: l.length + r.length }, () => {
>     if (!l.length) return r.shift()
>     else if (!r.length) return l.shift()
>     else return l[0] >= r[0] ? r.shift() : l.shift()
>   })
> }
> 
> console.log(mergeSort([2, 5, 2, 1, 4, 7, 9, 4, 9, 3, 5, 8, 7]))
> ```

### 希尔排序 ShellSort

> ```bash
> ## 希尔排序 ShellSort
> 希尔排序，也称递减增量排序算法， 是插入排序的一种更高效的改进版本。
> 	- 插入排序在对几乎已经排好序的数据操作时，效率高（可以达到线性排序的效率）。
> 	- 但因为插入排序每次只能将数据移动一位，所以插入排序一般是低效的。
> 希尔排序的基本思想是：先将整个待排序的记录序列分割称为若干子序列，并分别进行 '直接插入排序'，直到整个序列表的记录 '基本有序' 时，再对全体记录进行依次 '直接插入排序'。
> 
> 
> ### 原理
>     1. 将数组拆分为若干个子分组，每个分组由相距一定 '增量' 的元素组成。
>     2. 然后对每个子分组应用 '直接插入排序'。
>     3. 逐步减少 '增量'，重复步骤 1、2。
>     4. 直到 '增量为 1'，这是最后一个排序，此时对全数组进行直接插入排序。
>     注意：一般情况下，'增量 = 待分组序列长度 / 2'，并向下取整。
> 
> 
> ### 分析
> 1. 希尔排序是原地算法
> 	希尔排序过程中，只设计相邻数据的交换操作，只需要常量级的临时空间，空间复杂度为 O(1)。
> 2. 希尔排序不稳定
> 	单次直接插入排序是稳定的，它不会改变相同元素之间的相对顺序，但在多次不同的插入排序过程中，相同的元素可能在各自的插入排序中移动，可能导致相同元素的相对顺序发生变化。
> 3. 希尔排序的时间复杂度
> 	最佳情况：T(n) = O(n logn)
> 	最差情况：T(n) = O(n (log(n))2)
> 	平均情况：T(n) = 取决于间隙序列
> ```
>
> ![image-20210922185514310](./image/image-20210922185514310.png)
>
> ```ts
> /** 希尔排序 */
> const ShellSort = function (arr: Array<number>) {
>   // 动态定义间隔序列
>   let gap = Math.floor(arr.length / 2)
>   // 每次递减增量，直到为1
>   for (let gap; gap > 0; gap = Math.floor(gap / 2)) {
>     // 按组进行排序
>     for (let i = gap; i < arr.length; i++) {
>       // 获取当前元素
>       const currentVal = arr[i]
>       let j = i
>       // 将相邻元素比较，满足条件就后移
>       for (j; j >= 0 && arr[j] > currentVal; j -= gap) {
>         arr[j] = arr[j - gap]
>       }
>       // 将当前元素插入合适的位置
>       arr[j] = currentVal
>     }
>   }
>   return arr
> }
> 
> ShellSort([2, 5, 2, 1, 4, 7, 9, 4, 9, 3, 5, 8, 7])
> ```

### 堆排序 HeapSort

> ```bash
> ## 堆排序 HeapSort
> 堆排序是指利用 '堆' 这种数据结构所设计的一种排序算法。
> 堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引值总是小于（或大于）它的父节点。
> 		1. 大顶堆：每个节点的值都大于或等于其子节点的值，在堆排序算法中用于升序排列。
>     2. 小顶堆：每个节点的值都小于或等于其子节点的值，在堆排序算法中用于降序排列。
> 堆排序简单描述：
>     1. 比较父节点是否大于叶子节点（把最大的放在父子节点），直到一趟建堆完成，最大的一定在堆顶。
>     2. 把堆顶和最右下的叶子节点对换，再把右下叶子节点（最大值）抽出。
> 
> 
> ### 原理
> 1. 将初始待排序关键字序列（R1, R2, ..., Rn）构建成大顶堆，此堆为初始的无序区。
> 2. 将堆顶元素 R[1] 与最后一个元素 R[n] 交换，此时得到新的无序区（R1, R2, ..., Rn-1）和新的有序区（Rn），且满足 R[1, 2, ..., n-1] <= R[n]。
> 3. 由于交换后的新堆顶 R[1] 可能违反堆的性质，因此需要对当前无序区（R1, R2, ..., Rn-1）调整为新堆，然后再次将 R[1] 与无序区最后一个元素交换，得到新的无序区（R1, R2, ..., Rn-2）和新的有序区（Rn-1, Rn）。不断重复此过程，直到有序区的元素个数为 n-1，则整个排序过程完成。
> ```
>
> ![å æåº](./image/heapSort.gif)
>
> ```js
> /** 堆排序 */
> const HeapSort = function (arr: Array<number>) {
>   // 建立大顶堆：初始化大顶堆，从第一个非叶子节点开始
>   for (let i = Math.floor(arr.length / 2); i >= 0; i--) {
>     heapify(arr, i)
>   }
> 
>   // 排序：每一次遍历找出一个当前最大值，数组长度减一
>   for (let i = Math.floor(arr.length - 1); i > 0; i--) {
>     [arr[0], arr[i]] = [arr[i], arr[0]]
>     // 从根节点开始调整，并且最后一个节点已经为当前最大值，不需要再参与比较，所以第三个参数为 i，即比较到最后一个结点前一个即可
>     heapify(arr, 0, i)
>   }
> 
>   return arr
> }
> 
> // 堆调整
> // 2 * i  非叶子节点
> const heapify = (arr, i, len = arr.length) => {
>   const left = 2 * i + 1 // 左叶子节点
>   const right = 2 * i + 2 // 右叶子节点
>   let largest = i
> 
>   if (left < len && arr[left] > arr[largest]) {
>     largest = left
>   }
>   if (right < len && arr[right] > arr[largest]) {
>     largest = right
>   }
> 
>   if (largest !== i) {
>     [arr[i], arr[largest]] = [arr[largest], arr[i]]
>     heapify(arr, largest, len)
>   }
> }
> 
> HeapSort([4, 6, 8, 5, 9, 1, 2, 5, 3, 2])
> ```

### 计数排序 CountingSort

> ```bash
> ## 计数排序 CountingSort
> - 计数排序是唯一不基于比较的排序算法，其排序速度快于任何比较排序算法。
> - 适用场景：适合处理一定范围内的整数排序。
> - 计数排序利用了一个特征：对于数组的某个元素，一旦知道了有多少个其它元素比它小（假设为m个），那么就可以确定出该元素的正确位置（第 m+1 位）。
> - 缺陷：值不能使其为负数，否则会导致其下标为负数。
> 
> 
> ### 原理
> 1. 花O(n)时间找出待排序的数组A的最小值min，最大值max
> 2. 开辟新的空间创建新数组B，长度为(`max - min + 1`)
> 		B中`index`元素记录的是A中某元素值出现的次数（`index = A的元素值 - min + 1`）
> 3. 遍历数组A，对数组A的所有值进行计数累加（若A中出现相同值，则B中相应的下标中的值加一）	
> 4. 遍历数组B，根据其记录的值次数来计算值重新赋值给数组A（`A[sortedIndex++] = j + min - 1`）
> 
> 
> ### 计数 & 桶 & 基数 的区别
> 1. 计数排序：每个桶只存储单一键值。
> 2. 桶排序：每个桶存储一定范围的数值。
> 3. 基数排序：根据键值的每位数字来分配桶。
> ```
>
> ![è®¡æ°æåº](./image/countingSort.gif)
>
> ```ts
> /** 计数排序 */
> const countingSort = function (arr: Array<number>) {
>   /** 查找出数组的最大值和最小值 */
>   let max = arr[0]
>   let min = arr[0]
>   for (let i = 1; i < arr.length; i++) {
>     max = Math.max(max, arr[i])
>     min = Math.min(max, arr[i])
>   }
> 
>   /** 新开辟的空间计算数值出现的次数 */
>   const bucket: Array<number> = Array.from({ length: max - min + 1 })
> 
>   /** 计算次数并安入数组中 */
>   for (let i = 0; i < arr.length; i++) {
>     bucket[arr[i] - min + 1] = (bucket[arr[i] - min + 1] ?? 0) + 1
>   }
> 
>   /** 重新覆盖 arr 的值 */
>   for (let j = 0, sortedIndex = 0; j < bucket.length; j++) {
>     while (bucket[j] > 0) {
>       arr[sortedIndex++] = j + min - 1
>       bucket[j]--
>     }
>   }
> 
>   return arr
> }
> 
> countingSort([4, 6, 8, 5, 9, 1, 2, 5, 3, 2])
> ```

### 桶排序 BucketSort

> ```bash
> ## 桶排序 BucketSort
> - 桶排序(箱排序)是计数排序的升级版。
> - 桶排序是将数组分配给有限数量的桶子里，每个桶里在各自排序（因此有可能使用别的排序算法或递归方式继续桶排序）。当每个桶里的元素个数趋于一致时，桶排序只需花费 O(n) 的时间。
> - 桶排序的核心在于怎么把元素分配给每个桶里，合理地分配将大大提高排序的效率。
> - 当输入的数据可以均匀地分配到每一个桶中的时候是最快的。
> 
> 
> ```
>
> ![æ¡¶æåº2](./image/Bucket_sort_2.svg_.png)
>
> ```ts
> /** 插入  */
> const InsertSort = function (arr) {
>   for (let i = 1; i < arr.length; i++) {
>     for (let j = i; j > 0; j--) {
>       if (arr[j] > arr[j - 1]) {
>         break
>       } else {
>         [arr[j - 1], arr[j]] = [arr[j], arr[j - 1]]
>       }
>     }
>   }
>   return arr
> }
> 
> /**
>  * 桶排序
>  * @params bucketSize：设置桶的默认数量为5
>  */
> const BucketSort = function (arr: Array<number>, bucketSize = 5) {
>   if (arr.length < 2) return arr
> 
>   /** 计算数组的最大值和最小值 */
>   const min = Math.min(...arr)
>   const max = Math.max(...arr)
> 
>   /** 桶的初始化 */
>   const bucketCount = Math.floor((max - min) / bucketSize) + 1
>   const buckets: Array<Array<number>> = Array.from({ length: bucketCount }).map(
>     (_) => [],
>   )
> 
>   // 利用映射函数将数据分配到各个桶中
>   for (let i = 0; i < arr.length; i++) {
>     buckets[Math.floor((arr[i] - min) / bucketSize)].push(arr[i])
>   }
> 
>   // 对桶排序后，循环给 arr 重新赋值
>   arr.length = 0 // 清空数组
>   for (let i = 0; i < buckets.length; i++) {
>     buckets[i] = InsertSort(buckets[i]) // 使用插入排序，对桶进行排序
>     let j = 0
>     while (j < buckets[i].length) {
>       arr.push(buckets[i][j++])
>     }
>   }
> 
>   return arr
> }
> 
> BucketSort([42, 62, 81, 52, 92, 13, 24, 55, 36, 22])
> ```

### 基数排序 RadixSort

> ```bash
> ## 基数排序 RadixSort
> 基数排序是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。
> 由于整数也可以表达字符串(比如名字或日期)和特定格式的浮点数，所以基数排序也不是只能使用于整数。
> 
> 按照优先从高位或低位来排序有两种实现方案：
> - MSD: 由高位为基底, 先按k1排序分组, 同一组中记录, 关键码k1相等, 再对各组按k2排序分成子组, 之后, 对后面的关键码继续这样的排序分组, 直到按最次位关键码kd对各子组排序后. 再将各组连接起来, 便得到一个有序序列. MSD方式适用于位数多的序列.
> - LSD: 由低位为基底, 先从kd开始排序，再对kd-1进行排序，依次重复，直到对k1排序后便得到一个有序序列. LSD方式适用于位数少的序列.
> ```
>
> ![åºæ°æåº](./image/radixSort.gif)		
>
> ```js
> /**
>  * name: 基数排序
>  * @param arr 待排序数组
>  * @param max 最大位数
>  */
> const RadixSort = function (arr: Array<number>, maxDigit = 2) {
>   const counter: any[] = []
>   for (
>     let i = 0, unit = 10, base = 1;
>     i < maxDigit;
>     i++, base *= 10, unit *= 10
>   ) {
>     for (let j = 0; j < arr.length; j++) {
>       // 依次过滤出个位,十位等等数字
>       const bucket = ~~((arr[j] % unit) / base)
>       // 初始化桶
>       if (counter[bucket] === null) {
>         counter[bucket] = []
>       }
>       // 往不同桶里添加数据
>       counter[bucket].push(arr[j])
>     }
> 
>     let pos = 0
>     for (let j = 0; j < counter.length; j++) {
>       let value = null
>       if (counter[j] != null) {
>         while ((value = counter[j].shift()) != null) {
>           // 将不同桶里数据挨个捞出来,为下一轮高位排序做准备,由于靠近桶底的元素排名靠前,因此从桶底先捞
>           arr[pos++] = value
>         }
>       }
>     }
>   }
> 
>   return arr
> }
> 
> RadixSort([42, 62, 81, 52, 92, 13, 24, 55, 36, 22])
> ```
>

## 经典算法

### 素数(质数)

> ```bash
> ## 素数(质数)
> 质数(Prime number) 又称素数，指在大于 1 的自然数中，除了 1 和自身外，无法被其他自然数整除的数（也可定义为只有 1 与该数本身两个正因数的数）。
> 
> 埃拉托斯特尼筛法：简称埃氏筛，也称素数筛。是一种由希腊数学家埃拉托斯特尼所提出的一种简单鉴定素数的算法。
> 要得到自然数 n 以内的全部素数，必须把不大于根号 n 的所有素数倍数剔除，省下的就是素数。
> 
> 
> ### LeetCode
> - [回文素数](https://leetcode-cn.com/problems/prime-palindrome/)
> - [第 K 个最小的素数分数](https://leetcode-cn.com/problems/k-th-smallest-prime-fraction/)
> ```
>
> ```js
> /**
>  * 埃拉托斯特尼筛法 查找所有数字
>  * @param num 给定的数字
>  *    1. 从 2 到给定数字生成一个数组
>  *    2. 使用 filter() 筛选出可被 2 到所提供数字的平凡根的任何数字整除的值
>  */
> const primes = function (num) {
>   let arr = Array.from({ length: num - 1 }).map((_, i) => i + 2)
>   const sqroot = Math.floor(Math.sqrt(num))
>   const numsTillSqroot = Array.from({ length: sqroot - 1 }).map((_, i) => i + 2)
>   numsTillSqroot.forEach(
>     (x) => (arr = arr.filter((y) => y % x !== 0 || y === x)),
>   )
>   return arr
> }
> primes(10) // [2, 3, 5, 7]
> ```

### 杨辉三角形

> - 杨辉三角形（pascal triangle）又称帕斯卡三角形，是二项系数的三角形数组。
> - 表达式为：`C(lineNumber, i) = C(lineNumber, i - 1) * (lineNumber - i + 1) / i`
> - 当前行的第i位的数值为 = 当前行的第i-1位的数值 * (当前行 - 所在位置i  + 1) / 所在位置i
>
> ![img](./image/1626927345-DZmfxB-PascalTriangleAnimated2.gif)
>
> ### 获取杨辉三角形的设定行数据
>
> - 第一行默认为 1，第 n 行的个数需要在 n 的基础上加 1
> - 进行循环，每一行的每个条目都是通过将左上方的数字与右上方的数字相加来构建的，如果没有将视为为 0
>
> ```js
> const pascalTriangle = (lineNumber) => {
>   const currentLine = [1]
>   const currentLineSize = lineNumber + 1
>   for(let i = 1; i < currentLineSize; i++) {
>     currentLine[i] = (currentLine[i - 1] * (lineNumber - i + 1)) / i
>   }
>   return currentLine
> }
> 
> pascalTriangle(0) // [1]
> pascalTriangle(1) // [1, 1]
> pascalTriangle(2) // [1, 2, 1]
> pascalTriangle(3) // [1, 3, 3, 1]
> pascalTriangle(4) // [1, 4, 6, 4, 1]
> ```
>
> ### 获取杨辉三角形设定行所有数据
>
> - 使用动态规划，获取上一层的j-1列与j列的和
>
> ```js
> /**
>  * @param {number} numRows
>  * @return {number[][]}
>  */
> var generate = function (numRows = 5) {
>   if (numRows === 0) return [];
>   let result = [];
>   result.push([1]);
> 
>   for (let i = 1; i < numRows; i++) {
>     const preArr = result[i - 1];
>     let row = [];
>     row.push(1);
> 
>     for (let j = 1; j < preArr.length; j++) {
>       row.push(preArr[j - 1] + preArr[j]);
>     }
> 
>     row.push(1);
>     result.push(row);
>   }
> 
>   return result;
> };
> ```
>

### K均值

> - k-均值算法（k-means clustering）源于信号处理中的一种向量量化方法，现在则更多地作为一种聚类分析方法流行于数据挖掘和机器学习领域。
>
> ```js
>  
> ```
>

### 数组乱序 - 洗牌算法

> ```bash
> ## 数组乱序 - 洗牌算法
> 从最后一个元素开始，从数组中随机选出一个位置来交换，直到第一个元素为止。
> ```
>
> ```js
> function disorder (arr) {
>   const length = arr.length
>   let current = length - 1
>   while (current > -1) {
>     const random = Math.floor(Math.random() * length)
>     [arr[current], arr[random]] = [arr[random], arr[current]]
>     current--
>   }
>   return arr
> }
> ```
>



## 字符串 String

### 判断字符串是否表示为数值

> ```bash
> ## 判断字符串是否表示为数值
> 请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。 
> 例如，字符串 "+100", "5e2", "-123", "3.1416" 和 "-1E-16" 都表示数值。 
> 但是 "12e", "1a3.14", "1.2.3", "+-5" 和 "12e+4.3" 都不是。
> 
> 
> ### 思路
> 1. 只能出现数字、符号位、小数点、指数位
> 2. 小数点、指数符号只能出现一次，且不能出现在开头和结尾
> 3. 指数位出现后，小数点不允许再出现
> 4. 符号位只能出现在开头和指数位后面
> ```
>
> ```ts
> function isNumeric (s) {
>   if (s === undefined) return false
> 
>   let hasPoint = false
>   let hasExp = false
>   for (let i = 0, len = s.length; i < len; i++) {
>     const target = s[i]
>     if (target >= 0 && target <= 9) {
>       // 数字
>       continue
>     } else if (target === 'e' || target === 'E') {
>       // 指数位
>       if (hasExp || i === 0 || i === len - 1) {
>         return false
>       }
>       hasExp = true
>       continue
>     } else if (target === '.') {
>       // 小数点
>       if (hasPoint || hasExp || i === 0 || i === len - 1) {
>         return false
>       }
>       hasPoint = true
>       continue
>     } else if (target === '-' || target === '+') {
>       // 符号位
>       if (i === 0 || s[i - 1] === 'e' || s[i - 1] === 'E') {
>         continue
>       } else {
>         return false
>       }
>     } else {
>       return false
>     }
>   }
> 
>   // 循环后仍然不返回 false，则可判定该字符串可表示为数值
>   return true
> }
> 
> const truelist = ['+100', '5e2', '-123', '3.1416', '-1E-16']
> const falselist = ['12e', '1a3.14', '1.2.3', '+-5', '12e+4.3']
> const result: boolean[] = []
> truelist.forEach((item) => result.push(isNumeric(item)))
> falselist.forEach((item) => result.push(isNumeric(item)))
> console.log(result)
> ```

### 替换空格

> ```bash
> ## 替换空格
> 请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy。则经过替换之后的字符串为We%20Are%20Happy。
> 
> ### 1. 直接使用空格将字符串切割成数组，再用 `%20` 进行连接
> const replaceSpace = (str) => str.split(' ').join('%20')
> 
> ### 2. 使用正则表达式找到所有空格依次替换
> const replaceSpace = (str) => str.replace('/s/g', '%20')
> 
> 
> ### 扩展：多个空格用一个 `%20` 替换
> const replaceSpace = (str) => str.replace('/s+/g', '%20')
>```

### 正则表达式匹配

> ```bash
> ## 正则表达式匹配
> 请实现一个函数用来匹配包括 '.' 和 '*' 的正则表达式。
> 模式中的字符 '.' 表示任意一个字符，而 '*' 表示它前面的字符可以出现任意次（包含0次）。 
> 在本题中，匹配是指字符串的所有字符匹配整个模式。
> 例如，字符串 "aaa" 与模式 "a.a" 和 "ab*ac*a" 匹配，但是与 "aa.a" 和 "ab*a" 均不匹配。
> 
> 
> ### 思路
> 1. 当模式中的第二个字符不是 '*' 时：
> 	- 如果字符串第一个字符和模式中的第一个字符相匹配，那么字符串和模式都后移一个字符，然后匹配剩余的。
> 	- 如果字符串第一个字符和模式中的第一个字符不匹配，直接返回 false。
> 
> 2. 当模式中的第二个字符是 '*' 时：
> 	- 不匹配：如果字符串第一个字符跟模式第一个字符不匹配，则模式后移两个字符，继续匹配。
> 	- 产生匹配：如果字符串第一个字符跟模式第一个字符匹配，可以有 3 种匹配方式：
>       - 匹配了零次：模式后移 2 个字符，相当于 'x*' 被忽略；
>       - 匹配了1次：字符串后移 1 个字符，模式后移 2 个字符；
>       - 匹配了n次：字符串后移 1 个字符，模式不变，即继续匹配字符下一位，因为 '*' 可以匹配多位。
> ```
>
> ```js
> function matchStr (s, pattern, sIndex, patternIndex) {
>   // 字符串和模式都匹配完成
>   if (sIndex === s.length && patternIndex === pattern.length) return true
>   // 字符串还未匹配完，但模式已经匹配完成
>   if (sIndex !== s.length && patternIndex === pattern.length) return false
> 
>   // 如果下一位为 '*'
>   if (patternIndex + 1 < pattern.length && pattern[patternIndex + 1] === '*') {
>     // 当前字符等于当前匹配的字符 或 当前字符可为任意字符，则产生匹配次数
>     if (
>       sIndex < s.length &&
>       (s[sIndex] === pattern[patternIndex] || pattern[patternIndex] === '.')
>     ) {
>       return (
>         matchStr(s, pattern, sIndex, patternIndex + 2) ||
>         matchStr(s, pattern, sIndex + 1, patternIndex + 2) ||
>         matchStr(s, pattern, sIndex + 1, patternIndex)
>       )
>     } else {
>       // 不产生匹配，只有模式右移两位
>       return matchStr(s, pattern, sIndex, patternIndex + 2)
>     }
>   }
> 
>   // 如果下一位不为'*' 且（当前字符等于当前匹配的字符 或 当前字符为任意字符），则模式与字符都后移一位
>   if (
>     sIndex < s.length &&
>     (s[sIndex] === pattern[patternIndex] || pattern[patternIndex] === '.')
>   ) {
>     return matchStr(s, pattern, sIndex + 1, patternIndex + 1)
>   }
> 
>   // 上述所有情况都不满足，则为不匹配
>   return false
> }
> 
> function match (s, pattern) {
>   if (s === undefined || pattern === undefined) return false
>   return matchStr(s, pattern, 0, 0)
> }
> 
> console.log(match('aa', 'a'), match('aa', 'a*'), match('ab', '.*')) // false true true
> ```
>

## 数组 Array

> ```bash
> ## 数组
> - '存储'：在现今往往使用数组作为一个容器，用于按顺序存储元素的集合，它可以方便的存储成千上万个元素，并且数组中的每个元素都可以通过数组索引来识别；如果没有数组，存储这么多的元素则需要成千上万个引用。
> 
> - '查找'：在数组中中，每一个数组都有一个地址，同时可以通过数组的下标方便的算出每个元素的内存地址，从而实现快速访问和赋值，所以它通过下标查找的效率是 O(1) 级别的。
> 
> - '插入/删除'：在数组的插入和删除中，如果是在数组尾部插入或删除一个元素则可以直接进行；但如果在其他位置插入或者删除元素，则需要要移动后续元素的位置，比如你删除数组的第一个元素之后，则需要把后面的元素都往前移动一位。
> 
> - '数组容量'：数组的巨大弱点是当这个数组已经装满时，就无法再继续装入元素，此时需要考虑扩容问题。
> 
> - '动态数组'：在高级编程语言中，往往使用动态数组来解决这个问题，所谓动态数组是自动会进行数组扩容，当数组容量达到某个临界点时，动态数组会开辟一个更大的数组，然后将原来的元素复制过去。
> ```
>

### 双指针

> ```bash
> ## 双指针
> 主要是利用两个或多个不同位置的指针，通过速度和方向的变换解决问题。
> 注意这种技巧经常在排序数组中使用。
> 
> 
> ### 应用
> 1. 调整数组顺序使奇数位于偶数前面
> 2. 和为 S 的两个数字
> 3. 和为 S 的连续正整数序列
> ```
>
> 

### N数之和

> ```bash
> ## N数之和
> 主要考虑如果比暴力法降低时间复杂度，而且也会用到上面的双指针技巧。
> 
> 
> ## 应用
> 1. 两数之和
> 2. 三数之和
> 3. 四数之和
> ```
>
> 

### 二维数组

> ```bash
> ## 二维数组
> 建立一定的抽象建模能力，将实际中的很多问题进行抽象。
> 
> 
> ## 应用
> 1. 构建乘积数组
> 2. 顺时针打印矩阵
> ```
>
> 

### 数据统计

> ```bash
> ## 数据统计
> 数组少不了的就是统计和计算，此类问题考察如何用更有效的方法对数组进行统计计算。
> 
> ## 应用
> 1. 数组中出现次数超过数组长度一半的数字
> 2. 连续子数组的最大和
> 3. 扑克牌顺子
> 4. 第一个只出现一次的字符
> ```
>
> 

## 链表 LinkedList

### 单向链表

```bash
## 单向链表
用一组任意存储的单元来存储线性表的数据元素。每个节点有一个 next 指针指向后一个节点（下一个元素的地址），还有一个成员变量用于存储该节点本身的数值。
链表的效率：
  - 链表的结构注定它无法快速访问某个元素，只能依靠遍历的方式慢慢查找，所以链表查询数据的效率为 O(N) 级别；
  - 但它在头节点进行插入和删除，只需改变第一个元素的引用，此时的插入效率为 O(1) ；
  - 如果在尾节点进行插入和删除，必须要遍历整个链表，找到最后这个链表节点再进行插入，遍历链表的花费为 O(N)。
  
单向链表的两个特殊节点：
  - 头节点用来记录链表的基地址，知道头节点我们可以遍历得到整条链表。
  - 尾节点的指针指向一个空指针 NULL。
  
单向链表的特征：
	- 优点：动态扩容，不需要占用过多的内存；插入元素快，只需断开连接重新赋值。
	- 缺点：查询元素慢：不能随机访问，不能根据索引访问，需要从头节点开始遍历才能查询到元素。
	- 遍历：要遍历链表就是不断找到当前节点的 next 节点，当 next 节点为 null 时说明是最后一个节点，停止遍历。



### 链表与数组的区别
链表与数组都是存储有序的元素集合，但与数组的区别是链表中的元素在内存中并不是连续的，每个元素由一个存储元素本身的节点和一个指向下一个元素的引用（指针）组成。
相较于传统的数组，链表的一个好处是添加或移除元素时不需要移动其它元素；但在数组中可以直接访问任何位置的元素，而链表无法实现，因为链表中每个节点只有对下一个节点的引用，所以想访问链表中间的一个元素，必须从起点（链表头部节点）开始迭代链表知道找到所需的元素。



### 应用场景
React16 的 Fiber Node 连接起来形成的 Fiber Tree 就是个单链表结构。



### 链表的案例
1. 基础应用
    - 从尾到头打印链表
    - 删除链表中的节点
    - 反转链表
    - 复杂链表的复制
 
2. 环形链表
    - 环形链表
    - 链表中环的入口节点
    - 约瑟夫环
    - 圈圈中最后剩下的数字
 
 3. 双指针
    - 两个链表的第一个公共节点
    - 两个链表的公共节点
    - 链表倒数第 k 个节点
    - 相交链表
    - 删除链表中的节点 / 重复节点
 
 4. 双向链表
    - 合并两个排序的链表
    - 扁平化多级双向链表

```

![image-20230215183533947](./image/image-20230215183533947.png)



#### 链表实现

```ts
/** 链表单个节点数据字段约束 */
interface ILinkedNode {
  next: ILinkedNode | null
  value: unknown
}
/** 当前节点数据字段约束 */
type ICurListNode = null | ILinkedNode

/** 链表节点类 */
class ListNode {
  next: ILinkedNode | null
  value: unknown

  constructor (nodeValue) {
    this.next = null
    this.value = nodeValue
  }
}

/** 链表类 */
class LinkedList {
  /** 链表长度 */
  length: number
  /** 链表头部节点 */
  head: ICurListNode

  constructor () {
    this.length = 0
    this.head = null
  }

  /** 获取链表中索引所对应的元素，返回所查找节点 | null */
  getElementAt (index: number): ICurListNode {
    if (index < 0 || index >= this.length) return null

    let currentNode: ICurListNode = this.head
    while (index--) {
      currentNode = currentNode?.next || null
    }
    return currentNode
  }

  /** 获取链表中某个节点 */
  find (nodeValue: unknown): ICurListNode {
    let currentNode: ICurListNode = this.head
    while (currentNode) {
      if (currentNode.value === nodeValue) return currentNode
      currentNode = currentNode.next
    }
    return null
  }

  /** 追加节点 */
  append (nodeValue: unknown) {
    const node = new ListNode(nodeValue)

    if (!this.head) {
      this.head = node
    } else {
      const cur = this.getElementAt(this.length - 1)
      cur!.next = node
    }
    this.length++
  }

  /** 指定位置插入节点: 返回是否插入成功 */
  insert (index: number, nodeValue: unknown): boolean {
    // 边界判定是否超出界限
    if (index < 0 || index > this.length) return false

    const node = new ListNode(nodeValue)

    if (index === 0) {
      node.next = this.head
      this.head = node
    } else {
      const prev = this.getElementAt(index - 1)
      node.next = prev?.next || null
      prev!.next = node
    }

    this.length++
    return true
  }

  /** 删除指定位置的元素，并返回这个元素的值 */
  removeAt (index: number): ILinkedNode['value'] {
    if (index < 0 || index >= this.length) return null

    let currentNode: ICurListNode = this.head

    if (index === 0) {
      this.head = currentNode?.next || null
    } else {
      const prev = this.getElementAt(index - 1)
      currentNode = prev?.next || null
      prev!.next = currentNode?.next || null
    }

    this.length--
    return currentNode?.value || null
  }

  /** 获取链表中给定元素的索引 */
  indexOf (nodeValue: unknown): number {
    let currentNode: ICurListNode = this.head

    for (let i = 0; i < this.length; i++) {
      // 边界判定
      if (currentNode === null) return -1
      // 查找到
      if (currentNode?.value === nodeValue) return i
      // 未找到，往下一个节点查找
      currentNode = currentNode.next ?? null
    }
    // 始终为查找到该节点值
    return -1
  }

  /** 删除链表中对应元素 */
  remove (nodeValue: unknown) {
    const index = this.indexOf(nodeValue)
    return this.removeAt(index)
  }

  /** 判断链表是否为空 */
  isEmpty (): boolean {
    return this.length > 0
  }

  /** 获取链表的长度 */
  size () {
    return this.length
  }

  /** 获取链表的头元素 */
  getHead () {
    return this.head
  }

  /** 清空链表 */
  clear () {
    this.head = null
    this.length = 0
  }

  /** 链表转数组 */
  toArray (): ILinkedNode['value'][] {
    let currentNode: ICurListNode = this.head
    const tempArr: unknown[] = []
    while (currentNode !== null) {
      tempArr.push(currentNode.value)
      currentNode = currentNode.next ?? null
    }
    return tempArr
  }

  /** 序列化链表 */
  join (str: string) {
    return this.toArray().join(str)
  }

   /**
   * @reverse 反转链表
   * @param head 所需要反转的链表
   * 说明：
   *    1. 以链表的头部节点为基准节点
   *    2. 将基准节点的下一个节点挪到头部作为头结点
   *    3. 当基准节点的 next 为 null，则其已经成为最后一个节点，链表已经完成反转
   *  注意：传递的 head 需要深拷贝，否则会改变原链表
   */
  reverse (head: ICurListNode = cloneDeep(this.head)): ICurListNode {
    let currentNode: ICurListNode = null
    let reverseNode: ICurListNode = head
    while (head && head.next) {
      currentNode = head.next
      head.next = currentNode?.next || null
      currentNode.next = reverseNode
      reverseNode = currentNode
    }
    return reverseNode
  }
}

/** 测试内容 */
const linkedList = new LinkedList()
linkedList.append(10)
linkedList.append(20)
linkedList.append(30)
console.log(linkedList.join('--'))

linkedList.insert(0, 5)
linkedList.insert(2, 15)
linkedList.insert(4, 25)
console.log(linkedList.join('--'))

console.log(linkedList.getHead(), linkedList.reverse())

console.log(linkedList.removeAt(0))
console.log(linkedList.removeAt(1))
console.log(linkedList.removeAt(2))
console.log(linkedList.join('--'))

console.log(linkedList.indexOf(20))

linkedList.remove(20)

console.log(linkedList.join('--'))

console.log(linkedList.find(10))

linkedList.clear()
console.log(linkedList.size())

/* 输出结果：
10--20--30
191 5--10--15--20--25--30
193 5
194 15
195 25
196 10--20--30
198 1
202 10--30
204 ListNode {next: ListNode, value: 10} 
0 */
```

    - 
    - 删除链表中的节点
    - 反转链表
    - 复杂链表的复制
#### 从尾到头打印链表

```ts
/** 链表结构 */
class ListNode {
  value: unknown
  // eslint-disable-next-line no-use-before-define
  next: null | ListNode
  constructor(value) {
    this.value = value
    this.next = null
  }
}

/** 从尾到头打印链表 */
const printListFromTailToHead = (head: ListNode | null): Array<unknown> => {
  const result: Array<unknown> = []
  while (head) {
    result.unshift(head.value)
    head = head.next
  }
  return result
}

/** 测试代码 */
const listNode = new ListNode(1)
listNode.next = new ListNode(2)
const result = printListFromTailToHead(listNode)
console.log(result)

```



#### 反转链表

```bash
### 反转链表
1. 以链表的头部节点为基准节点
2. 将基准节点的下一个节点挪到头部作为头结点
3. 当基准节点的 next 为 null，则其已经成为最后一个节点，链表已经完成反转
    reverse (head = cloneDeep(this.head)) {
      let currentNode = null, reverseNode = head
      while (head && head.next) {
        currentNode = head.next
        head.next = currentNode?.next || null
        currentNode.next = reverseNode
        reverseNode = currentNode
      }
      return reverseNode
    }
```

#### 复杂链表的复制

```bash
### 复杂链表的复制
输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的head。
1. 复制一份链表放在前一个节点后面，即根据原始链表的每个节点 N 创建 N，把 N 直接放在 N 的 next 位置，让复制后的链表和原始链表组成新的链表。
2. 给复制的链表 random 赋值，即 N.random = N.random.next。
3. 拆分链表，将 N 和 N 进行拆分，保证原始链表不受影响。

```



### 双指针

```bash
## 双指针
双指针主要利用两个或多个不同位置的指针，通过速度和方向的变换解决问题。
  1. 两个指针从不同位置出发：一个从始端开始，另一个从末端开始；
  2. 两个指针以不同速度移动：一个指针快一些，另一个指针慢一些。
因为在单链表中只能在一个方向上遍历链表，所以第一种情况可能无法工作。
然而第二种情景，也被称为慢指针和快指针，是非常有用的。


### 应用
- 两个链表的第一个公共节点
- 两个链表的公共节点
- 链表倒数第 k 个节点
- 相交链表
- 删除链表中的节点 / 重复节点

```



### 双向链表

> ```bash
> ## 双向链表
> - 双向链表支持两个方向，每个节点不仅有一个后驱节点指针 next 指向后面的节点，还有一个前驱指针 prev 指向前面的节点。
> - 双链表中，除了可以像单向链表一样从头部开始遍历之外，还可以从尾部进行遍历。
> 
> ### 应用
> 1. 扁平化多级双向链表
> ```
>
> ![image-20230215183448698](./image/image-20230215183448698.png)
>
> ```ts
> /** 链表单个节点数据字段约束 */
> interface ILinkedNode {
>   next: ILinkedNode | null
>   prev: ILinkedNode | null
>   value: unknown
> }
> /** 当前节点数据字段约束 */
> type ICurListNode = null | ILinkedNode
> 
> /** 链表节点类 */
> class ListNode implements ILinkedNode {
>   next: ILinkedNode | null
>   prev: ILinkedNode | null
>   value: unknown
> 
>   constructor (nodeValue) {
>     this.next = null
>     this.prev = null
>     this.value = nodeValue
>   }
> }
> 
> /** 双向链表类 */
> class DoubleLinkedList {
>   /** 链表长度 */
>   length: number
>   /** 链表头部节点：仅在插入首个节点or头部插入新节点时才修改，主要通过节点next属性查找下一个节点  */
>   head: ICurListNode
>   /** 链表尾部的节点：仅在插入首个节点or尾部插入新节点时才更改，主要通过节点prev属性查找上一个节点 */
>   tail: ICurListNode
> 
>   constructor () {
>     this.length = 0
>     this.head = null
>     this.tail = null
>   }
> 
>   /** 获取双向链表中索引所对应的元素，返回所查找节点 | null */
>   getElementAt (index: number): ICurListNode {
>     if (index < 0 || index >= this.length) return null
>     let currentNode: ICurListNode = null
>     // 当索引大于链表长度的一半时，从后往前找
>     if (index > Math.floor(this.length / 2)) {
>       currentNode = this.tail
>       let i = this.length - 1
>       while (i > index) {
>         currentNode = currentNode?.prev || null
>         i--
>       }
>     } else {
>       currentNode = this.head
>       while (index--) {
>         currentNode = currentNode?.next || null
>       }
>     }
>     return currentNode
>   }
> 
>   /** 获取双向链表中某个节点 */
>   find<T = any> (nodeValue: T): ICurListNode {
>     let curHead: ICurListNode = cloneDeep(this.head)
>     let curTail: ICurListNode = cloneDeep(this.tail)
>     // 双向迭代，理想状态下相对单向链表更快速
>     while (curHead) {
>       if (curHead.value === nodeValue) return curHead
>       curHead = curHead.next
> 
>       if (curTail?.value === nodeValue) return curTail
>       curTail = curTail?.prev || null
>     }
>     return null
>   }
> 
>   /** 向双向链表中追加节点 */
>   append<T = any> (nodeValue: T): void {
>     const node = new ListNode(nodeValue)
> 
>     if (this.head === null) {
>       // 链表为空，head 和 tail 都指向当前追加的节点
>       this.head = node
>       this.tail = node
>     } else {
>       // 链表不为空，将当前节点添加到链表的尾部
>       this.tail!.next = node
>       node.prev = this.tail
>       this.tail = node
>     }
> 
>     this.length++
>   }
> 
>   /** 在双向链表的指定位置插入节点 */
>   insert<T = any> (index: number, nodeValue: T): boolean {
>     if (index < 0 || index > this.length) return false
> 
>     // 插入到尾部
>     if (index === this.length) {
>       this.append<T>(nodeValue)
>     } else {
>       const node = new ListNode(nodeValue)
>       if (index === 0) {
>         // 插入到头部
>         if (this.head === null) {
>           this.head = node
>           this.tail = node
>         } else {
>           node.next = this.head
>           this.head.prev = node
>           this.head = node
>         }
>       } else {
>         // 插入到中间位置
>         const curNode = this.getElementAt(index)
>         const prevNode = curNode!.prev
>         node.next = curNode
>         node.prev = prevNode
>         prevNode!.next = node
>         curNode!.prev = node
>       }
>       this.length++
>     }
> 
>     return true
>   }
> 
>   /** 删除双向链表中指定位置的元素，并返回这个元素的值 */
>   removeAt (index: number): ILinkedNode['value'] {
>     if (index < 0 || index >= this.length) return null
> 
>     let curNode: ICurListNode
>     let prevNode: ICurListNode
> 
>     // 移除头部元素
>     if (index === 0) {
>       curNode = this.head
>       this.head = curNode!.next
>       this.head!.prev = null
>       if (this.length === 1) this.tail = null
>     } else if (index === this.length - 1) {
>       // 移除尾部元素
>       curNode = this.tail
>       this.tail = curNode!.prev
>       this.tail!.next = null
>     } else {
>       // 移除中间元素
>       curNode = this.getElementAt(index)
>       prevNode = curNode!.prev
>       prevNode!.next = curNode!.next
>       prevNode!.next!.prev = prevNode
>     }
> 
>     this.length--
>     return curNode!.value
>   }
> 
>   /** 获取双向链表中给定元素的索引 */
>   indexOf<T = any> (nodeValue: T): number {
>     let curHead = this.head
>     let curTail = this.tail
>     let idx = 0
> 
>     while (curHead !== curTail) {
>       if (curHead?.value === nodeValue) return idx
>       curHead = curHead!.next
> 
>       if (curTail?.value === nodeValue) return this.length - 1 - idx
>       curTail = curTail!.prev
> 
>       idx++
>     }
>     return -1
>   }
> 
>   /** 删除链表中对应的元素 */
>   remove <T = any> (nodeValue: T) {
>     const index = this.indexOf(nodeValue)
>     return this.removeAt(index)
>   }
> 
>   /** 序列化双向链表 */
>   join (str: string): string {
>     let curNode = this.head
>     let tempStr = ''
>     while (curNode) {
>       tempStr += curNode.value
>       if (curNode.next) tempStr += str
>       curNode = curNode.next
>     }
>     return tempStr
>   }
> }
> 
> /** 测试内容 */
> const doubleLinkedList = new DoubleLinkedList()
> doubleLinkedList.append(10)
> doubleLinkedList.append(15)
> doubleLinkedList.append(20)
> doubleLinkedList.append(25)
> console.log(doubleLinkedList.join('<->'))
> 
> console.log(doubleLinkedList.getElementAt(0)?.value)
> console.log(doubleLinkedList.getElementAt(1)?.value)
> console.log(doubleLinkedList.getElementAt(5))
> 
> console.log(doubleLinkedList.join('<->'))
> console.log(doubleLinkedList.indexOf(10))
> console.log(doubleLinkedList.indexOf(25))
> console.log(doubleLinkedList.indexOf(50))
> 
> doubleLinkedList.insert(0, 5)
> doubleLinkedList.insert(3, 18)
> doubleLinkedList.insert(6, 30)
> console.log(doubleLinkedList.join('<->'))
> 
> console.log(doubleLinkedList.find(10)?.value)
> console.log(doubleLinkedList.removeAt(0))
> console.log(doubleLinkedList.removeAt(1))
> console.log(doubleLinkedList.removeAt(5))
> console.log(doubleLinkedList.remove(10))
> console.log(doubleLinkedList.remove(100))
> 
> console.log(doubleLinkedList.join('<->'))
> console.log(doubleLinkedList.tail, doubleLinkedList.head)
>     
> /* 测试结果：
> 10<->15<->20<->25
> 10
> 15
> null
> 10<->15<->20<->25
> 0
> 3
> -1
> 5<->10<->15<->18<->20<->25<->30
> 10
> 5
> 15
> null
> 10
> null
> 18<->20<->25<->30 */
> ```

### 循环列表(环类)

> ```bash
> ## 循环列表（环类）
> 循环列表是一种特殊的单链表，与单链表不同的是尾节点不指向空地址，指向链表的头结点。
> 优点是从链尾到链头比较方便，当要处理的数据具有环形结构特点时，非常适合用循环列表来处理。
> 
> 
> ## 环类：从判定一个单链表是否存在循环而扩展衍生的问题
> 1. 环形链表
> 2. 链表环的入口节点
> 3. 约瑟夫环
> ```
>
> ![image-20230216183655897](./image/image-20230216183655897.png)

### JS & 链表

> ```bash
> ### JavaScript 不内置链表的原因
> 链表效率高于数组效率这种话，事实上在 JavaScript 中是不存在的，即使创建一个长度为 1亿 的数组，在创建一个长度为 10 的数组，并且向这两个数组的中间添加元素，会发现两者所用时间与数组长度无关，这说明 JavaScript 数组达到了链表的效率要求。
> 
> 而且数组中可用 `splice()` 方法向数组的指定位置去添加和删除元素，所需时间同样与数组长度无关，也能达到链表的要求，而数组的下标完全可以取代链表的 `head、tail、next、prev` 等方法，并且大多数使用链表的情况不多。
> 
> 当然这只局限于 JavaScript 这门语言中，这和 JS 内部的数组实现机制有关，其实 JS 的数组只是叫数组而已，它和常规语言中的数组概念不同。
> 
> 
> 
> ### JavaScript 链表的作用：React 16 引入的 Fiber 架构的更新算法
> Fiber 翻译为纤维化，将任务进行细化。它把一个耗时长的任务分成很多小片，每一个小片的运行时间很短，虽然总时间依然很长，但是在每个小片执行完之后，都给其他任务一个执行的机会，这样唯一的线程就不会被独占，其他任务依然有运行的机会，React 中的 Fiber 就把整个 VDOM 的更新过程碎片化。
> 
> 在之前 React 的 render() 方法会接收一个 虚拟DOM 对象和一个真实的 容器DOM 作为 虚拟DOM 渲染完成后的挂载节点，其主要作用是将 虚拟DOM 渲染为 真实DOM 并挂载到容器下，这个方法在更新时是进行递归操作的，如果在更新的过程中有大量的节点需要更新，就会出现长时间占用 JS 主线程的情况，并且整个递归过程是无法被打断的，由于 JS 线程和 GUI 线程是互斥的，所以大量更新的情况下会看到界面有些卡顿。
> 
> Fiber 架构主要是解决两个问题：一是保证任务在浏览器空闲时执行，二是将任务进行碎片化。
> 
> JS 中有一个实验性质的方法 `requestIdleCallback(callback)`，它可以传入一个回调函数，回调函数能够收到一个 deadline 对象，通过该对象的 timeRemaining() 方法可以获取到当前浏览器的空闲时间，如果有空闲时间，那么就可以执行一小段任务，如果时间不足，则继续 requestIdleCallback，等到浏览器有空闲时间时再接着执行，这样就实现了浏览器空闲时执行。
> 
> 但虚拟 DOM 是树结构，当任务被打断后，树结构无法恢复之前的任务继续执行。
> Fiber 架构为了使整个更新过程可随时暂停恢复，节点与树分别采用了 FiberNode 与 FiberTree 进行重构。FiberNode 使用了双链表结构，链表中就包含三个指针，parent 指向其父 Fiber 节点，child 指向其子 Fiber 节点，sibling 指向其兄弟 Fiber 节点，一个 Fiber 节点对应一个任务节点，这样就可以直接找到兄弟节点与子节点，继而可以恢复任务的执行。
> 整个过程由 current 与 workInProgress 两株树双缓冲完成。workInProgress 更新完成后，再通过修改 current 相关指针指向新节点。
> ```

## 队列 Queue

> ```bash
> ## 队列
> - 队列是线性结构，遵循先进先出原则，特点是在尾部插入元素，在头部取出元素。
> - 队列分为两种：
> 		1. 有界队列：能装入的元素有限。
> 		2. 无界队列：能装入的元素无线，只要内存还有，就能一直装下去。
> 
> - 队列的应用场景
> 面对无法同时处理多个问题的场景，通常使用队列先进先出的特性一个一个地解决问题，还可以保证有序性。
>     1. 食堂排队打饭
>     2. JS异步中的任务队列：JS使用队列先后处理异步任务，因为JS是单线程的，无法同时处理异步中的并发任务。
>     3. 计算最近请求次数
> 
> 
> ### 循环队列
> 因为单链队列出队操作的时间复杂度为 O(n)，而循环队列的出队操作的时间复杂度为 O(1)
> ```

### 单链队列

> ```ts
> class Queue {
>   private queue: Array<number> = []
> 
> 	/** 入队 */
>   public enter (num) {
>     this.queue.push(num)
>   }
> 
>   /** 出队 */
>   public delete (): null | number | undefined {
>     if (this.queue.length === 0) return null
>     return this.queue.shift()
>   }
> 
>   public clear (): void { this.queue = [] }
>   get length () { return this.queue.length }
> }
> ```
>
> #### 【典例】933. 最近的请求次数
>
> ```bash
> ### 【典例】933. 最近的请求次数
> 题目：
> 请你实现 RecentCounter 类来计算特定时间范围内最近的请求：
> RecentCounter() 初始化计数器，请求数为 0 。
> int ping(int t) 在时间 t 添加一个新请求，其中 t 表示以毫秒为单位的某个时间，并返回过去 3000 毫秒内发生的所有请求数（包括新请求）。确切地说，返回在 [t-3000, t] 内发生的请求数。
> 保证 每次对 ping 的调用都使用比之前更大的 t 值。
> 
> 
> 输入：
> ["RecentCounter", "ping", "ping", "ping", "ping"]
> [[], [1], [100], [3001], [3002]]
> 输出：
> [null, 1, 2, 3, 3]
> 
> 解释：
> RecentCounter recentCounter = new RecentCounter();
> recentCounter.ping(1);     // requests = [1]，范围是 [-2999,1]，返回 1
> recentCounter.ping(100);   // requests = [1, 100]，范围是 [-2900,100]，返回 2
> recentCounter.ping(3001);  // requests = [1, 100, 3001]，范围是 [1,3001]，返回 3
> recentCounter.ping(3002);  // requests = [1, 100, 3001, 3002]，范围是 [2,3002]，返回 3
> 
> 
> 复杂度分析:
> 时间：O(n)n为while中踢出的个数
> 空间：O(n)n为队列长度 即 最近请求次数
> ```
>
> ```ts
> class RecentCounter {
>   queue: number[]
>   constructor() {
>     this.queue = []
>   }
> 
>   ping(t: number): number {
>     this.queue.push(t)
>     while(this.queue[0] < t - 3000) {
>       this.queue.shift()
>     }
>     return this.queue.length
>   }
> }
> ```
>

### 链表实现队列

> ```ts
> interface IListNode {
>   value: number
>   next: IListNode | null
> }
> 
> class Queue {
>   private head: IListNode | null = null
>   private tail: IListNode | null = null
>   private len = 0
> 
>   /**
>    * 入队，在 tail 位置
>    * @param n number
>    */
>   add (n: number) {
>     const newNode: IListNode = {
>       value: n,
>       next: null,
>     }
> 
>     // 处理 head
>     if (this.head === null) {
>       this.head = newNode
>     }
> 
>     // 处理 tail
>     const tailNode = this.tail
>     if (tailNode) {
>       tailNode.next = newNode
>     }
>     // 记录尾结点
>     this.tail = newNode
> 
>     // 记录长度
>     this.len++
>   }
> 
>   /**
>    * 出队，在 head 位置
>    */
>   delete (): number | null {
>     const headNode = this.head
>     if (headNode === null) return null
>     if (this.len <= 0) return null
> 
>     // 取值
>     const value = headNode.value
> 
>     // 处理 head
>     this.head = headNode.next
> 
>     // 记录长度
>     this.len--
> 
>     return value
>   }
> 
>   get length (): number {
>     // length 要单独存储，不能遍历链表来获取（否则时间复杂度太高 O(n)）
>     return this.len
>   }
> }
> ```

### 循环队列

> ```ts
> /** 循环队列 */
> class SqQueue {
>     /** 队列 */
>     private queue: any[]
>     /** 队头 */
>     private head = 0
>     /** 队尾 */
>     private tail = 0
>     /** 队列大小 */
>     private size = 0
>     constructor (length: number) {
>        this.queue = new Array(length + 1)
>      }
>    
>      private resize (length) {
>       const q = new Array(length)
>     for (let i = 0; i < length; i++) {
>         q[i] = this.queue[(i + this.head) % this.queue.length]
>        }
>        this.queue = q
>        this.head = 0
>        this.tail = this.size
>      }
>    
>      public pushQueue (item) {
>       //  % this.queue.length 是为了防止数组越界
>     if (this.head === (this.tail + 1) % this.queue.length) {
>         this.resize(this.getLength() * 2 + 1)
>        }
>        this.queue[this.tail] = item
>        this.size++
>        this.tail = (this.tail + 1) % this.queue.length
>      }
>    
>      /** 出队 */
>     public popQueue () {
>     if (this.isEmpty()) {
>         throw Error('Queue is empty')
>       }
>        const result = this.queue[this.head]
>        this.queue[this.head] = null
>        this.head = (this.head + 1) % this.queue.length
>        this.size--
>        // 为了保证不浪费空间，在队列空间等于总⻓度四分之⼀且不为2时,缩⼩总⻓度为当前的⼀半
>        if (this.size === this.getLength() / 4 && this.getLength() / 2 !== 1) {
>          this.resize(this.getLength() / 2)
>        }
>        return result
>      }
>    
>      /** 获取队列 */
>     public getQueue () {
>     if (this.isEmpty()) {
>         throw Error('Queue is empty')
>       }
>        try {
>          return Array.from(this.queue)
>        } catch (error) {
>          console.error('error----', error)
>        }
>      }
>    
>      /** 获取队头、队尾 */
>     public getQueueHeadAndTail = () => ({ tail: this.tail, head: this.head })
>   /** 获取长度 */
>     public getLength = () => this.queue.length - 1
>     /** 判断是否为空 */
>     public isEmpty = () => this.head === this.tail
>   }
>   const quese = new SqQueue(10)
>   quese.pushQueue('a')
> quese.pushQueue('b')
> quese.pushQueue('c')
> quese.pushQueue('d')
> quese.pushQueue('e')
> console.log(quese) // SqQueue { queue: [ 'a', <10 empty items> ], head: 0, tail: 1, size: 1 }
> ```
> 

## 栈 Stack

> ```bash
> ## 栈
> - 栈是一个线性结构，所以栈元素具有线性关系，即前驱后继关系，只不过它是一种的特殊的线性表。
> - 栈的插入操作叫进栈，栈的删除操作叫出栈，遵循'先进后出'的原则。
> - 栈的特殊在于限制了这个线性表的插入和删除位置，它始终只在栈顶进行。即栈底是固定的，最先进栈的只能在栈底。
> - 对于一个栈，需要实现添加、删除元素、获取栈顶元素、已经是否为空，栈的长度、清除元素等几个基本操作。
> - 在计算机中，栈长被用于程序的调用帧栈，在程序中出现的 StackOverFlow 异常就是由于程序调用栈用尽，所以栈一般都是有相对固定的深度（栈深往往被设定的内存影响）。
> 
> 
> ### 匹配括号
> 通过栈先进后出的特点来判断是否形成闭环
> ```
>
> ```ts
> function Stack() {
>   this.items = [];
> }
> Stack.prototype = {
>   constructor: Stack,
>   push: function (element) {	// 在栈顶添加数据
>     this.items.push(element);
>   },
>   pop: function () {	// 移除栈顶数据
>     return this.items.pop();
>   },
>   peek: function () {	// 获取栈顶数据
>     return this.items[this.items.length - 1];
>   },
>   isEmpty: function () {	// 判断栈是否为空
>     return this.items.length === 0;
>   },
>   clear: function () {	// 清空栈
>     this.items = [];
>   },
>   size: function () {	// 查看栈的大小
>     return this.items.length;
>   },
>   print: function () {	// 输出栈数据
>     console.log(this.items.toString());
>   }
> }
> let stack = new Stack();
> stack.items = [1, 2, 3];
> stack.push('a');
> console.log(stack.isEmpty());
> ```
>
> ### 【典例】匹配括号
>
> ```ts
> let isValid = function (str) {
>   strArr = str.split('');	// 字符串转数组
>   let map = {
>     '(': -1, ')': 1,
>     '[': -2, ']': 2,
>     '{': -3, '}': 3,
>   }
>   let stack = [];
>   for (let i = 0; i < strArr.length; i++) {
>     if (map[strArr[i]] < 0) {
>       stack.push(strArr[i])  // 左括号入栈
>     } else {	
>       // 判断是否为右括号 且 是否形成闭环
>       // (注意：需要数据是右括号才行，否则会破坏数据结构)
>       if (map[strArr[i]] > 0 && map[stack.pop()] + map[strArr[i]] != 0) return false;
>     }
>   }
>   return stack.length == 0
> }
> console.log(isValid('{9()8}'))  // true
> console.log(isValid('{9(])8}'))  // false
> console.log(isValid('{222)'))  // false
> console.log(isValid('{'))   // false
> ```
>
> 

## 栈和队列

> ```bash
> ## 栈和队列
> 在数组中，我们可通过索引随机访问元素，但在某些情况下，我们可能要限制数据的访问顺序，于是有了两种限制访问顺序的数据结构：
> 1. 栈：先进后出
> 2. 队列：先进先出
> 
> 
> ## 应用
> 1. 队列和栈的互相实现
> 2. 包含 min 函数的栈
> 3. 栈的压入弹出序列
> 4. 滑动窗口最大值
> 5. 接雨水
> ```
>
> 
> 

## 堆 Heap

> ```bash
> ## 堆
> 堆的底层实际上是一颗完全二叉树，可以用数组实现。
> - 每个的节点元素值不小于其子节点 - 最大堆
> - 每个的节点元素值不大于其子节点 - 最小堆
> 
> 
> ### 应用
> 堆在处理某些特殊场景时可以大大降低代码的事件复杂度，例如在庞大的数据中找到最大的几个数或者最小的几个数，可以借助堆来完成这个过程。
> 1. 堆的基本操作
> 2. 数据流中的中位数
> 3. 最小的K个数
> ```
>
> ![堆](./image/%E5%A0%86.webp)

### 堆的构建 CreateHeap

#### 大顶堆 createMaxHeap

> ```bash
>## 大顶堆 createMaxHeap
> 从第一个非叶子节点开始依次对数组中的元素进行下沉操作。
> 1. 和孩子节点的最大值 max 比较。
>     - 大于 max：不需要再下沉。
>     - 小于 max：和 max 交换位置，然后继续和下一层孩子节点比较，直到队列末尾。
> ```
> 
> ```js
>const ajustMaxHeap = function (arr, index, len) {
>   for (let i = 2 * index + 1; i < len; i = 2 * i + 1) {
>     if (i + 1 < len && arr[i + 1] > arr[i]) {
>       i++
>     }
>     if (arr[index] >= arr[i]) {
>       break
>     } else {
>       [arr[index], arr[i]] = [arr[i], arr[index]]
>       index = i
>     }
>   }
> }
> 
> /** 创建大顶堆 */
> const createMaxHeap = function (arr, len) {
>   for (let i = Math.floor(len / 2) - 1; i >= 0; i--) {
>     ajustMaxHeap(arr, i, len)
>   }
> 
>   console.log(arr)
>   return arr
> }
> 
> createMaxHeap([1, 2, 3, 4, 5, 6, 7], 7)
> ```





## 哈希表 HashTable

> ```bash
> ## 哈希表
> 哈希的基本原理是将给定的键值转换为偏移地址来检索记录。
> 键转换为地址是通过一种关系（公式）来完成的，这就是哈希（散列）函数。
> 虽然哈希表是一种有效的搜索技术，但它还是有些缺点。两个不同的关键字，由于哈希函数值相同，因而被映射到同一表位置上。该现象称为冲突。发生冲突的两个关键字称为该哈希函数的同义词。
> 
> ### 哈希函数设计问题
> 如何设计哈希函数以及避免冲突就是哈希表的常见问题，好的哈希函数的选择有两条标准：
> 1. 简单并且能够快速计算
> 2. 能够在地址空间中获得键的均匀人分布
> 
> 
> ## 应用
> 1. 常数事件插入、删除和获取随机元素
> （当用到哈希表时我们通常要开辟一个额外空间来记录一些计算过的值，同时我们又要在下一次计算的过程中快速检索到它们，例如两数之和、三数之和等都利用了这种思想）
> 2. 两数之和、三数之和
> 3. 字符流中第一个不重复的字符
> 4. 宝石与石头
> ```
>
> ![哈希表](./image/%E5%93%88%E5%B8%8C%E8%A1%A8.webp)
>
> 

## 二叉树 BinaryTree

> ```bash
> ## 完全二叉树的公式
> - 第 n 层的节点数最对为 2^n 个节点
> - n 层二叉树最多有 2^0 + ... + 2^n = 2^(n+1) -1 个节点
> - 第一个非野子节点：length/2
> - 一个节点的孩子节点：2n 或 2n+1
> ```
>
> ![二叉树的基本形态](./image/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%BD%A2%E6%80%81.webp)
>
> ![image-20230327165455597](./image/image-20230327165455597.png)
>

### 二叉树基本操作

> ```bash
> ## 二叉树的基本操作
> 1. 插入树节点
> 2. 前序遍历
> 3. 中序遍历
> 4. 后序遍历
> 5. 获取最大值的节点
> 6. 获取最小值的节点
> 7. 获取树的深度
> ```
>
> ```ts
> /** 树节点约束 */
> interface ITreeNode {
>   /** 值 */
>   value: number
>   /** 左孩子 */
>   left: ITreeNode | null
>   /** 右孩子 */
>   right: ITreeNode | null
> }
> /** 树的 root 存储的可能值 */
> type ITree = ITreeNode | null
> 
> /** 节点类（记录每个节点上下关联） */
> class TreeNode implements ITreeNode {
>   public value = 0
>   public left = null
>   public right = null
> 
>   constructor (value: number) {
>     this.value = value
>   }
> 
>   show () {
>     console.log(this.value)
>   }
> }
> 
> /** 树类 */
> class Tree {
>   /** 根节点 */
>   private root: ITree
> 
>   constructor (treeNode: ITree = null) {
>     this.root = treeNode
>   }
> 
>   /** 插入节点 */
>   insertNode (nodeValue: number): ITree {
>     const treeNode = new TreeNode(nodeValue)
>     if (!this.root) {
>       this.root = treeNode
>       return this.root
>     }
> 
>     let curNode: ITree = this.root
>     let parent: ITree = null
> 
>     while (curNode) {
>       parent = curNode
> 
>       if (nodeValue < parent.value) {
>         curNode = curNode.left
>         if (!curNode) {
>           parent.left = treeNode
>           return this.root
>         }
>       } else {
>         curNode = curNode.right
>         if (!curNode) {
>           parent.right = treeNode
>           return this.root
>         }
>       }
>     }
> 
>     return this.root
>   }
> 
>   /** 插入多个节点 */
>   inserNodes (nodeValues: number[]): ITree {
>     nodeValues.forEach(nodeValue => {
>       this.insertNode(nodeValue)
>     })
>     return this.root
>   }
> 
>   /** 前序遍历 */
>   preOrder (treeNode = this.root): Array<number> {
>     if (treeNode === null) return []
>     return [
>       treeNode.value,
>       ...this.preOrder(treeNode.left),
>       ...this.preOrder(treeNode.right),
>     ]
>   }
> 
>   /** 中序遍历 */
>   middleOrder (treeNode = this.root): Array<number> {
>     if (treeNode === null) return []
>     return [
>       ...this.middleOrder(treeNode.left),
>       treeNode.value,
>       ...this.middleOrder(treeNode.right),
>     ]
>   }
> 
>   /** 后序遍历 */
>   laterOrder (treeNode = this.root): Array<number> {
>     if (treeNode === null) return []
>     return [
>       ...this.laterOrder(treeNode.left),
>       ...this.laterOrder(treeNode.right),
>       treeNode.value,
>     ]
>   }
> 
>   /** 获取树的最小值的节点 */
>   getMin (): ITree {
>     let current = this.root
>     while (current) {
>       if (!current.left) {
>         return current
>       }
>       current = current.left
>     }
>     return null
>   }
> 
>   /** 获取树的最大值的节点 */
>   getMax (): ITree {
>     let current = this.root
>     while (current) {
>       if (!current.right) {
>         return current
>       }
>       current = current.right
>     }
>     return null
>   }
> 
>   /** 获取树的深度 */
>   getDeep (treeNode = this.root, deep = 0) {
>     if (treeNode === null) return deep
>     deep++
>     const dleft = this.getDeep(treeNode.left, deep)
>     const dright = this.getDeep(treeNode.right, deep)
>     return Math.max(dleft, dright)
>   }
> }
> 
> /** 测试代码 */
> const t = new Tree()
> t.insertNode(3)
> t.inserNodes([8, 1, 2, 5, 7, 6, 0])
> console.log(t)
> console.log('节点遍历', t.preOrder(), t.middleOrder(), t.laterOrder())
> console.log('节点最值：', t.getMin(), t.getMax())
> console.log('节点深度：', t.getDeep())
> ```

### 二叉树的遍历

#### 二叉树的前序遍历

> ```bash
> ## 二叉树的前序遍历
> 取根节点为目标节点，开始遍历：
> 	1. 访问目标节点。
>   2. 左孩子入栈 -> 直至左孩子为空的节点。
>   3. 节点出栈，以右孩子为目标节点，再依次执行步骤 1、2、3。
> 
> 
> ### 示例
> 输入: [1,null,2,3]  
>    1
>     \
>      2
>     /
>    3 
> 输出: [1,2,3]
> ```
>
> #### 【非递归实现前序遍历】
>
> ```js
> /**
>  * 二叉树的前序遍历
>  * @param root 树的根节点
>  */
> const preorderTraversal = function (root) {
>   const result = []
>   const stack = []
>   let curNode = root
> 
>   while (curNode || stack.length > 0) {
>     while (curNode) {
>       result.push(curNode.value)
>       stack.push(curNode)
>       curNode = curNode.left
>     }
> 
>     curNode = stack.pop()
>     curNode = curNode.right
>   }
> 
>   return result
> }
> ```
>
> #### 【递归实现前序遍历】
>
> ```js
> /**
>  * 二叉树的前序遍历
>  * @param root 树的根节点
>  * @param result 导出的遍历结果：数组
>  */
> const preorderTraversal = function (root, result = []) {
>   if (root !== null) {
>     result.push(root.value)
>     preorderTraversal(root.left, result)
>     preorderTraversal(root.right, result)
>   }
>   return result
> }
> ```

#### 二叉树的中序遍历

> ```bash
> ## 二叉树的中序遍历
> 取根节点为目标节点，开始遍历：
>   1. 左孩子入栈 -> 直至左孩子为空的节点。
>   2. 节点出栈 -> 访问该节点。
>   3. 以右孩子为目标节点，再依次执行步骤 1、2、3。
> 
> 
> ### 示例
> 输入: [1,null,2,3]
>    1
>     \
>      2
>     /
>    3
> 输出: [1,3,2]
> ```
>
> #### 【非递归实现中序遍历】
>
> ```js
> /**
>  * 二叉树的中序遍历
>  * @param root 树的根节点
>  */
> const inorderTraversal = function (root) {
>   const result = []
>   const stack = []
>   let curNode = root
> 
>   while (curNode || stack.length > 0) {
>     while (curNode) {
>       stack.push(curNode)
>       curNode = curNode.left
>     }
> 
>     curNode = stack.pop()
>     result.push(curNode.value)
>     curNode = curNode.right
>   }
> 
>   return result
> }
> ```
>
> #### 【递归实现中序遍历】
>
> ```js
> /**
>  * 二叉树的中序遍历
>  * @param root 树的根节点
>  * @param result 导出的遍历结果：数组
>  */
> const inorderTraversal = function (root, result = []) {
>   if (root !== null) {
>     inorderTraversal(root.left, result)
>     result.push(root.value)
>     inorderTraversal(root.right, result)
>   }
>   return result
> }
> ```

#### 二叉树的后序遍历

> ```bash
> ## 二叉树的后序遍历
> 取根节点为目标节点，开始遍历：
>   1. 左孩子入栈 -> 直至左孩子为空的节点。
>   2. 栈顶节点的右节点为空或右节点被访问过 -> 节点出栈并访问它，将节点标记为已访问。
>   3. 栈顶节点的右节点不为空且未被访问，以右孩子为目标节点，再依次执行步骤 1、2、3。
> 
> 
> ### 示例
> 输入: [1,null,2,3]  
>    1
>     \
>      2
>     /
>    3 
> 输出: [3,2,1]
> ```
>
> #### 【非递归实现后序遍历】
>
> ```js
> /**
>  * 二叉树的后序遍历
>  * @param root 树的根节点
>  */
> const postorderTraversal = function (root) {
>   const result = []
>   const stack = []
>   let last = null // 标记上一个访问的节点
>   let curNode = root
> 
>   while (curNode || stack.length > 0) {
>     while (curNode) {
>       stack.push(curNode)
>       curNode = curNode.left
>     }
> 
>     curNode = stack[stack.length - 1]
>     if (!curNode.right || curNode.right === last) {
>       curNode = stack.pop()
>       result.push(curNode.value)
>       last = curNode
>       curNode = null // 继续弹栈
>     } else {
>       curNode = curNode.right
>     }
>   }
> 
>   return result
> }
> ```
>
> #### 【递归实现后序遍历】
>
> ```js
> /**
>  * 二叉树的后序遍历
>  * @param root 树的根节点
>  * @param result 导出的遍历结果：数组
>  */
> const postorderTraversal = function (root, result: any[] = []) {
>   if (root !== null) {
>     postorderTraversal(root.left, result)
>     postorderTraversal(root.right, result)
>     result.push(root.value)
>   }
>   return result
> }
> ```

### 二叉树的重建

> ```bash
> ## 二叉树的重建
> 
> ```
>
> 

### 二叉树的对称性

#### 对称的二叉树

> ```bash
> 
> ```
>
> 

#### 对称的二叉树

> ```bash
> 
> ```
>
> 1

### 二叉树的深度

#### 二叉树的最大深度

> ```bash
> 
> ```
>
> 

#### 二叉树的最小深度

> ```bash
> 
> ```
>
> 

#### 平衡二叉树

> ```bash
> 
> ```
>
> 

### 二叉搜索树 BST

> ```bash
> ## 二叉搜索树 BST(Binary Search Tree)
> ### 描述
> 是二叉树的一种，专注于检索，特点是让节点按照一定的规律摆放，从而让搜索某个节点特别的高效。
> 如果以根节点划分二叉搜索树，左子树里的节点全部小于根节点，右子树全部大于根节点；而且无论以哪个节点作为根节点来划分，规律亦是如此。
> 注意：二叉搜索树每个节点的值必须具备可比较性。
> 
> ## 作用
> 当我们需要检索一个值时，如果大于该节点就去右子树查找，如果小于就去该节点的左子树查找，每次都可以过滤一半查找返回。例如图中一共有15个数字，找到数字33根据比对只需要查找4次即可。
> 
> 
> ## 插入
> 根据二叉搜索树的定义，所以需要保证无论往这棵树上增加多少个节点，都需要保证其定义不被破坏。
> 当遇到一个新的节点需要插入时，我们可以与根节点进行比较：
>   - 如果比根节点值大就放入右子树内；
>   - 如果比根节点值小，就放入左子树内；
> 使用这样的插入规则，逐层往下，当遇到一个节点的孩子为空，将新节点设置为其新的孩子节点即可。
> 
> 
> ## 查找
> 关于二叉搜素树的搜索，根据二叉搜索树的特性从根节点开始逐层递归进行比较，对于每个节点：
>   - 如果目标值等于节点的值，则返回节点；
>   - 如果目标值小于节点的值，则继续在左子树中搜索；
>   - 如果目标值大于节点的值，则继续在右子树中搜索；
>   - 如果根据规则最后遇到了空节点，则说明这棵树里没有这个节点。
> 
> 
> ## 删除
> 二叉搜索树最繁琐的就是删除，因为删除一个节点后，原来位置的节点并不会空着，必须找到替代的节点续上才行。续上后续节点而又保持二叉搜索树的定义分为几种情况：
>   1. 只有一边有孩子节点：将另一边孩子节点续上即可。
>   2. 两边都有孩子节点：有两种处理方式，
>     - 一种是在待删除节点的左子树里找到最大的值替代，然后切断其链接；
>       指定树的最大值一定是在其左子树沿着右边一直找到最后那个非空节点的值。
>     - 另一种是在待删除的右子树里找到最小值替代，然后切断其链接。
>       根据二叉搜索树的特性，指定树的最小值一定是沿着左边一直找，最后找到的那个非空节点；而删除指定树的最小值节点，也只需用被删除节点的右子树续上即可。
> 需要注意点如下：
>     - 如果目标节点 '没有子节点'，我们可以 '直接移除' 该目标节点。
>     - 如果目标节点 '只有一个子节点'，我们可以用其子节点作为 '替换'。
>     - 如果目标节点 '有两个子节点'，我们需要用其中序 '后继节点或前驱结点' 来替换，再删除该节点。
> 		
> 		
> ## 性能对比
> 存储需要占用额外空间去保存节点的指针，但这一些是为了在搜索时使得性能优化。比如从 100 万条数据里查找对应数据，数组需要 O(n) 的复杂度，而二叉搜索树平均只需要 O(logn) 即可，也就是查找 20 次即可找到，当树的节点数量每次 ×2 的倍增时，查找的次数只是 +1 而已。而从 100 万条数据里移除某条数据时，数组需要 O(n) 的搬家操作，而二叉树每次也只需要 O(logn) 即可完成操作。
> - 增加数据：数组 O(1)		二叉搜索树(平均)	O(logn)
> - 查找数据：数组 O(n)		二叉搜索树(平均)	O(logn)
> - 删除数据：数组 O(n)		二叉搜索树(平均)	O(logn)
> 
> 在二叉搜索树的性能对比中需要加上平均时，是因为会出现极端的情况，如整一颗二叉树只有右节点，会使得查找的次数急剧增加。
> 所以二叉搜索树的缺点也很明显，极端情况下回退化成链表，这时它的任何操作会变成 O(n)。
> 为了避免这种情况出现，就需要使用自平衡二叉搜索树（AVL树、红黑树）。
> ```
>
> ![二叉查找树](./image/%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91.png)
>
> ![二叉搜索树添加节点](./image/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E6%B7%BB%E5%8A%A0%E8%8A%82%E7%82%B9.png)
>
> ![二叉搜索树查找节点](./image/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E6%9F%A5%E6%89%BE%E8%8A%82%E7%82%B9.png)
>
> ![二叉搜索树删除节点](./image/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E5%88%A0%E9%99%A4%E8%8A%82%E7%82%B9.png)
>
> ```js
> /** 节点类（记录每个节点上下关联） */
> class TreeNode {
>   constructor(value) {
>     this.value = value
>     this.left = null // 左孩子
>     this.right = null // 右孩子
>   }
> }
> 
> 
> /** 树类 */
> class BST {
>   constructor() {
>     this.root = null // 根节点
>   }
> 
>   /** 插入新节点 */
>   insertNode(...insertArr) {
>     const _helper = (node, val) => {
>       // 如果某个节点的子节点为空，创建新节点返回
>       if (node === null) {
>         return new TreeNode(val)
>       }
>       // 如果当前节点比 val 大，新节点需要放在其左子树里
>       if (node.value > val) {
>         // 以当前节点左孩子为起点，返回新的左孩子节点
>         node.left = _helper(node.left, val)
>         return node // 返回新的结点
>       } else {
>         node.right = _helper(node.right, val)
>         return node
>       }
>     }
>     // 从根节点开始插入value，返回新节点
>     insertArr.forEach((value) => {
>       this.root = _helper(this.root, value)
>     })
>   }
> 
> 
>   /** 查找子节点 */
>   searchNode(value) {
>     const _helper = (node, val) => {
>       // 如果找到最底层节点也没找到
>       if (node === null) return null
>       // 正好找到
>       if (node.value === val) return node
>       // 如果比当前节点小，则去左子树查找，否则往右子树查找
>       if (node.value > val) {
>         return _helper(node.left, val)
>       } else {
>         return _helper(node.right, val)
>       }
>     }
>     // 从跟节点开始查找
>     return _helper(this.root, value)
>   }
> 
> 
>   /** 删除子节点 */
>   deleteNode(value) {
>     // 找到要删除的节点
>     const search = (node, val) => {
>       if (val === node.left.value || val === node.right.value) {
>         const parent = node.left.value === val ? node.left : node.right
>         const where = node.left.value === val ? 'left' : 'right'
>         return [node, parent, where]
>       } else {
>         const where = node.value < val ? 'right' : 'left'
>         return search(node[where], val)
>       }
>     }
> 
>     // 保存要删除的节点，要删除节点的父节点，已经删除的左右方向
>     let [node, parent, where] = search(this.root, value)
>     if (node) {
>       if (parent.left === null && parent.right === null) {
>         node[where] = null
>       } else if (parent.left === null) {
>         node[where] = parent.right
>       } else if (parent.right === null) {
>         node[where] = parent.left
>       } else {
>         let empty = parent
>         // 找到左子树中最小的节点
>         while (empty.left.left !== null) {
>           empty = empty.left
>         }
>         // 把最左侧的底层节点移动到被删除的节点位置上
>         parent.value = empty.left.value
>         empty.left = null
>       }
>     }
>   }
> 
>   
>   /** 修改节点（注意：该实现在修改后并没有重排树，可能会造成使得树不再是二叉搜索树结构） */
>   replaceNode(oldVal, newVal) {
>     const replaceHelper = (node) => {
>       if (node === null) return false
>       if (node.value === oldVal) {
>         return node.value = newVal
>       } else if (node.value === oldVal) {
>         replaceHelper(node.right, oldVal)
>       } else {
>         replaceHelper(node.left, oldVal)
>       }
>     }
>     replaceHelper(this.root)
>   }
> }
> 
> const bst = new BST()
> bst.insertNode(15, 10, 7, 12, 8, 26, 22, 24, 37, 33)
> bst.insertNode(28)
> console.log(bst.root) // 插入节点
> console.log(bst.searchNode(24)) // 查找节点
> bst.deleteNode(7)
> console.log(bst.root) // 删除节点
> bst.replaceNode(15)
> console.log(bst.root) // 修改节点
> ```

